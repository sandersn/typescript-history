[
  {
    "Id": "1068995",
    "ThreadId": "450181",
    "Html": "I have been playing with Typescript for a while now but am still slightly confused as to how exporting of modules works.\r<br />\n<br />\nAs my current approach is to made all modules internal and just export the classes, then if I use the ///reference syntax to include them I can use the exported classes via the module as a namespace.\r<br />\n<br />\nSo for example:<br />\n<pre><code>// foo/bar.ts\nmodule Foo\n{\n    export class Bar\n    {\n        public DoSomething(){};\n    }\n}\n\n// yellow/blue.ts\n\n///&lt;reference path=&quot;../../foo/bar.ts&quot; /&gt;\nmodule Yellow\n{\n    export class Blue\n    {\n        public Bar Instance;\n    }\n}</code></pre>\n\nNow this worked ok for smaller projects, however now I am using typescript with a NodeJS based project I would like to be able to export my modules and them import (or require  in v0.9) them so they are more modular and not a huge mess of interconnected files.\r<br />\n<br />\nNow in the example above I may have 20 files within the 'Foo' module, and from what I can tell the 'export module' syntax only works on an individual file, so if I were to have 2 files within the 'Foo' directory which both were part of the 'Foo' module and both had the 'export module Foo' syntax it is implied that this wont work as there should only be one module exported, although I dont know if this is actually correct or not, I kept getting errors around this when I tried to compile this way with multiple files.\r<br />\n<br />\nSo I am wondering how I can lay my classes out in a namespace style fashion, but then just generate a single output for this module so node can just import it, I was thinking I could keep all the namespaces but remove the root &quot;Foo&quot; module and then somehow make a wrapper ts file which is the single export module declaration and somehow composes all the internal modules within itself to export them, if that makes sense... but the documentation around all of this stuff is sparse, so has anyone got any hints on best way to have it so I can have multiple classes/files within a module at varying depths within a namespace but compile it to a single file which can be imported like so:<br />\n<pre><code>import foo = require(&quot;Foo&quot;);\nvar something = new foo.Bar();</code></pre>\n\n",
    "PostedDate": "2013-07-16T06:21:12.053-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1070090",
    "ThreadId": "450181",
    "Html": "There are a couple of points here.\r<br />\n<br />\nWorking with external modules, which you're doing by using 'import foo', moves us into the module loader style of code.  We landed on a design here that tries to play to the style that people generally use with module loaders, which is that each separate bit of contained functionality is its own separately loaded module.  This is in contract to treating them as a namespace.  Instead, external modules each fit in separate files, and use top-level imports and exports to coordinate across this file boundary with the module loader.\r<br />\n<br />\nTypeScript also has internal modules using the 'module' keyword, which you also show.  These do tend to work a lot more like namespaces and are more of a convenience for grouping related functionality together.  There is some similarities with external modules, in that you can export properties to make them visible outside of the module.  But they're don't have any affect working with module loaders.<br />\n",
    "PostedDate": "2013-07-18T08:57:22.317-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1070687",
    "ThreadId": "450181",
    "Html": "Hi Jon, Grofit and fellow TypeScript enthusiasts,<br />\n<br />\nI decided to use this thread as an opportunity to share a simple looking pattern that solves just this problem - of using internal modules (namespaces) with CommonJS (in Node.js). With this little &quot;magic trick&quot;, my application can use the same (internal) modules both in the browser and in Node without any issues and almost no constraints or limitations. It is based on the assumption that an internal module is basically a regular Javascript object that is being continuously referenced and extended in multiple source files.<br />\n<br />\nThis &quot;hack&quot; may look quite trivial at first (though in practice it isn't really, as it's quite subtle) but actually depends on correct cycle resolution capability of the module loader to work correctly. It is also based on a second assumption that a CommonJS module is loaded only once and has a single, unique, object that is associated with it. This object is then used to provide a &quot;context&quot; and then further extended the same way that a browser based &quot;Internal&quot; Module object would. Here's the general layout of the pattern:<br />\n<pre><code>InternalModuleLoader.ts\n-----------------------\nrequire(&quot;./ModuleFile1&quot;);\nrequire(&quot;./ModuleFile2&quot;);\nrequire(&quot;./ModuleFile3&quot;);\nrequire(&quot;./ModuleFile4&quot;);\n\n\nModuleFile1.ts\n--------------\n///&lt;reference path='ModuleFile1.ts'/&gt;\n///&lt;reference path='ModuleFile2.ts'/&gt;\n///&lt;reference path='ModuleFile3.ts'/&gt;\n///&lt;reference path='ModuleFile4.ts'/&gt;\n\nif (typeof require == &quot;function&quot;)\n    InternalModule = require(&quot;./InternalModuleLoader&quot;);\n\nmodule InternalModule\n{\n    export class Class1\n    {\n    ..\n    }\n}\n\nModuleFile2.ts\n--------------\n///&lt;reference path='ModuleFile1.ts'/&gt;\n///&lt;reference path='ModuleFile2.ts'/&gt;\n///&lt;reference path='ModuleFile3.ts'/&gt;\n///&lt;reference path='ModuleFile4.ts'/&gt;\n\nif (typeof require == &quot;function&quot;)\n    InternalModule = require(&quot;./InternalModuleLoader&quot;);\n\nmodule InternalModule\n{\n    export class Class2\n    {\n    ..\n    }\n}\n\n...\n</code></pre>\n\nSome remarks and caveats:<br />\n1: Module source files may load in an arbitrary order (depending on the &quot;entry&quot; file that's been loaded first). Code that exists inside the module scope but not deferred within a class or function may fail or not work as expected (in my app I never assume any order so that's not a problem). [<strong>Edit:</strong> this assertion appears to be incorrect - at least in the Node implementation - source files do load in the order they are required - see next post below for experimental results]<br />\n<br />\n2: As I've mentioned, this pattern creates (a lot! of) cyclical references and depends upon the ability of the loader to resolve them (which Node seems to do correctly - using &quot;partially done objects&quot;, but other loaders may not). It also assumes that once a CommonJS module has been &quot;required&quot; it will always maintain the same memory reference and never be reloaded again.<br />\n<br />\nMore detail from the Node manual:<br />\n(<a href=\"http://nodejs.org/api/modules.html#modules_caching\" rel=\"nofollow\">http://nodejs.org/api/modules.html#modules_caching</a>)<br />\n<blockquote>\nCaching:<br />\nModules are cached after the first time they are loaded. This means (among other things) that every call to require('foo') will get exactly the same object returned, if it would resolve to the same file.<br />\n<br />\nMultiple calls to require('foo') may not cause the module code to be executed multiple times. This is an important feature. <em>With it, &quot;partially done&quot; objects can be returned, thus allowing transitive dependencies to be loaded even when they would cause cycles.</em><br />\n</blockquote>\nSome more info on cycles can be found here:<br />\n<a href=\"http://nodejs.org/api/modules.html#modules_cycles\" rel=\"nofollow\">http://nodejs.org/api/modules.html#modules_cycles</a><br />\n<br />\n<br />\n3: If trying to use the pattern in conjunction with CommonJS modules described in external module declarations (pretty much all of them), TypeScript will complain it doesn't allow mixing internal and external modules on the same source file. My current (and rather tedious) solution is to convert the &quot;external&quot; module declarations to &quot;internal&quot; ones (though I have two regular expressions that automate this). I then load the modules in the following way: &quot;var http = &lt;http&gt; require(&quot;http&quot;);&quot;. (Perhaps after reading this the TypeScript team might reconsider the decision to be so strict on that matter. At the end it's a developer choice - if they want to mix, why not?)<br />\n<br />\n4: Note that the variable for the internal module object was chosen to be the &quot;loader&quot; module object simply out of convenience. I could, as well have put it on the &quot;global&quot; object (or some other shared object) but I thought this would give even better encapsulation (though it might create a bit of confusion since <em>the loader itself does not actually export anything</em>).<br />\n<br />\n.. some other &quot;complications&quot; I'm not aware of / never encountered ..<br />\n<br />\n<br />\nOverall it works very well for my needs and I'm generally satisfied with it. I'm interested to hear what the TypeScript team has to say about this (perhaps you'll consider integrating something of this sort into the compiler? or at least make it easier to implement?). I guess it's not the way they intended the module system to be used but this is indeed very simple and have saved me a lot (!) of headache (something others have described as the &quot;module hell/confusion&quot; and I have to agree on that).<br />\n<br />\nBasically there are 3 different module systems that are not compatible with each other - to the point where the compiler even actively (and somewhat forcibly!) forbids any attempt to create some sort of compatibility layer between them. I doubt this is an optimal (or even, in practice, manageable) solution? Anyway this is my best attempt at trying to &quot;bridge the gap&quot;, at least where it was important for my own work.<br />\n",
    "PostedDate": "2013-07-19T14:44:18.507-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1070964",
    "ThreadId": "450181",
    "Html": "Reading the Node module docs again (specifically about circular references and incomplete objects) I started to have a doubt on one of my assertions and it appears to be wrong. The module files do load in the order they are required, with the exception of the &quot;entry&quot; file (the file that's first to invoke the loader) - that will always be loaded last - and that makes sense anyway. Here is some experimental code I wrote to confirm this (this is also verified to compile correctly, of course):<br />\n<br />\nModuleLoader.ts:<br />\n<pre><code>///&lt;reference path='References.ts'/&gt;\n\nrequire(&quot;./ModuleFile1&quot;);\nrequire(&quot;./ModuleFile2&quot;);\nrequire(&quot;./ModuleFile3&quot;);\nrequire(&quot;./ModuleFile4&quot;);</code></pre>\n\nModule1.ts:<br />\n<pre><code>///&lt;reference path='References.ts'/&gt;\n\nif (typeof require == &quot;function&quot;)\n    InternalModule = require(&quot;./ModuleLoader&quot;);\n\nmodule InternalModule\n{\n    export var test1 = 1;\n}\n\nconsole.log(&quot;ModuleFile1 loaded, content: &quot; + JSON.stringify(InternalModule));</code></pre>\n\nModule2.ts:<br />\n<pre><code>///&lt;reference path='References.ts'/&gt;\n\nif (typeof require == &quot;function&quot;)\n    InternalModule = require(&quot;./ModuleLoader&quot;);\n\nmodule InternalModule\n{\n    export var test2 = 2;\n}\n\nconsole.log(&quot;ModuleFile2 loaded, content: &quot; + JSON.stringify(InternalModule));</code></pre>\n\nModule3.ts:<br />\n<pre><code>///&lt;reference path='References.ts'/&gt;\n\nif (typeof require == &quot;function&quot;)\n    InternalModule = require(&quot;./ModuleLoader&quot;);\n\nmodule InternalModule\n{\n    export var test3 = 3;\n}\n\nconsole.log(&quot;ModuleFile3 loaded, content: &quot; + JSON.stringify(InternalModule));</code></pre>\n\nModule4.ts:<br />\n<pre><code>///&lt;reference path='References.ts'/&gt;\n\nif (typeof require == &quot;function&quot;)\n    InternalModule = require(&quot;./ModuleLoader&quot;);\n\nmodule InternalModule\n{\n    export var test4 = 4;\n}\n\nconsole.log(&quot;ModuleFile4 loaded, content: &quot; + JSON.stringify(InternalModule));</code></pre>\n\nReferences.ts:<br />\n<pre><code>///&lt;reference path='ModuleFile1.ts'/&gt;\n///&lt;reference path='ModuleFile2.ts'/&gt;\n///&lt;reference path='ModuleFile3.ts'/&gt;\n///&lt;reference path='ModuleFile4.ts'/&gt;\n\ndeclare var require;</code></pre>\n\nOutput when invoking Module4.ts as an &quot;entry point&quot;:<br />\n<pre><code>ModuleFile1 loaded, content: {&quot;test1&quot;:1}\nModuleFile2 loaded, content: {&quot;test1&quot;:1,&quot;test2&quot;:2}\nModuleFile3 loaded, content: {&quot;test1&quot;:1,&quot;test2&quot;:2,&quot;test3&quot;:3}\nModuleFile4 loaded, content: {&quot;test1&quot;:1,&quot;test2&quot;:2,&quot;test3&quot;:3,&quot;test4&quot;:4}</code></pre>\n\nOutput when invoking Module2.ts as an &quot;entry point&quot;:<br />\n<pre><code>ModuleFile1 loaded, content: {&quot;test1&quot;:1}\nModuleFile3 loaded, content: {&quot;test1&quot;:1,&quot;test3&quot;:3}\nModuleFile4 loaded, content: {&quot;test1&quot;:1,&quot;test3&quot;:3,&quot;test4&quot;:4}\nModuleFile2 loaded, content: {&quot;test1&quot;:1,&quot;test3&quot;:3,&quot;test4&quot;:4,&quot;test2&quot;:2}</code></pre>\n\nSo basically this shows that &quot;internal&quot; module source files can be loaded in the exact same way and order as they load in the browser. I've been using this pattern for about two months now with great success (and with more than 10 source files included). There are still some limitations imposed by the compiler that make this pattern difficult to work in conjunction with the more &quot;standard&quot; CommonJS language support. I hope that with the collaboration of the TypeScript team and users we can make this a more &quot;standardized&quot; method - rather than just a &quot;hack&quot; or &quot;design pattern&quot; - since the language is still in alpha and hasn't been stabilized, I think this might the right time to discuss this.<br />\n",
    "PostedDate": "2013-07-21T06:33:43.99-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]