[
  {
    "Id": "1042297",
    "ThreadId": "443356",
    "Html": "Method Overloading is available in TypeScript, I know. But it would be very useful to have the logic done by the compiler.\r<br />\n<br />\nFor example if I have the following:<br />\n<pre><code>class ArgumentMismatchException {}\n\nclass OverloadExample {\n    public DoSomething(); // (1)\n    public DoSomething(param1: string, param2: string); // (2)\n    \n    public DoSomething(p1?: any, p2?: any) {\n        if (!p1 &amp;&amp; !p2)\n            alert('No Parameters -&gt; (1)');\n        else if (typeof p1 == 'string' &amp;&amp; typeof p2 == 'string')\n            alert('Two Parameters -&gt; (2)');\n        else\n            throw new ArgumentMismatchException();\n    }\n}\n\nvar oe = new OverloadExample();\noe.DoSomething();\noe.DoSomething('hello', 'world');\noe.DoSomething(234);</code></pre>\n\nit would be very nice if I could also write this instead:<br />\n<pre><code>class OverloadExample {\n    public DoSomething() {\n        alert('No Parameters -&gt; (1)');\n    } // (1)\n    \n    public DoSomething(param1: string, param2: string) {\n        alert('Two Parameters -&gt; (2)');\n    } // (2)\n}\n\nvar oe = new OverloadExample();\noe.DoSomething();\noe.DoSomething('hello', 'world');\noe.DoSomething(234);</code></pre>\n\nand the code two route to the requested overloaded method would be automatically generated by the compiler. <br />\n",
    "PostedDate": "2013-05-11T12:59:00.763-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1042324",
    "ThreadId": "443356",
    "Html": "From my non-extensive knowledge of language and compiler design (OK, from reading Eric Lippert's blog) the problem here is that in the example case you've given, the resolution is simple, but in the complete set of all possible cases, the resolution can range from trivial to extremely complicated to &quot;impossible in a dynamic language&quot;.\r<br />\n<br />\nFor example, if I am working in a typed language that supports overloaded methods, I should be able to do this:<br />\n<pre><code>class Resetter {\n  public reset(HtmlElement element) {\n    while (element.children.length &gt; 0) {\n      element.removeChild(element.children[0]);\n    }\n  }\n\n  public reset(HTMLCanvasElement element {\n    element.getContext(&quot;2d&quot;).clearRect(0, 0, element.width, element.height);\n  }\n}</code></pre>\n\nThat's a very simple, realistic use case, and there is no simple, object-model- or API-independent way that TypeScript can know how to resolve that overload in the JavaScript it produces.<br />\n",
    "PostedDate": "2013-05-11T16:04:09.893-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1042870",
    "ThreadId": "443356",
    "Html": "As markrendle says, there are a few issues, which have come up before (e.g. <a href=\"https://typescript.codeplex.com/discussions/397788\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/397788</a>).\r<br />\n<br />\nIn general, we try to keep the amount of code-rewriting to a minimum, and focus on the kind of code you would normally write in JavaScript.  In this case, we'd need to rewrite the function to be called through another function (introducing new names into the output) and reflect on the types of the values given (not possible in all cases).  By sticking to only overloading on the function prototype, we can stay closer to the JavaScript, and enable describing &quot;overloading&quot; as its done in JavaScript.<br />\n",
    "PostedDate": "2013-05-13T08:17:27.803-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]