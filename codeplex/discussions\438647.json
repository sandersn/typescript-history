[
  {
    "Id": "1023684",
    "ThreadId": "438647",
    "Html": "In C#, awaits are performed on Task objects. The most obvious allegory for Task objects in JavaScript right now are promises, and the <a href=\"http://promises-aplus.github.com/promises-spec/\" rel=\"nofollow\">Promises/A+ spec</a> seems to be most popular.<br />\n<br />\nSo, it would look something like this:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">// Note that in the following code, WinJS.Promise implicitly implements</span>\n<span style=\"color:Green;\">// this interface:</span>\n<span style=\"color:Blue;\">interface</span> Promise&lt;T&gt; {\n     then&lt;U&gt;(onFulfilled?: (value?: T) =&gt; U, onRejected?: (reason?: <span style=\"color:Blue;\">any</span>) =&gt; <span style=\"color:Blue;\">any</span>): Promise&lt;U&gt;;\n}\n\n<span style=\"color:Green;\">// Operates on standard promise objects</span>\nasync <span style=\"color:Blue;\">function</span> getBlogPost(id: <span style=\"color:Blue;\">number</span>): WinJS.Promise&lt;BlogPost&gt; {\n     <span style=\"color:Blue;\">var</span> request = await WinJS.xhr({ url: <span style=\"color:#A31515;\">&quot;www.mywebsite.com/blog/post/&quot;</span> + id });\n     <span style=\"color:Blue;\">return</span> &lt;BlogPost&gt; JSON.parse(request.innerText);\n}\n\n<span style=\"color:Green;\">// If the function returns, it must have the async modifier to indicate that</span>\n<span style=\"color:Green;\">// it returns a promise.</span>\n<span style=\"color:Green;\">// Try/catches can be used for the onRejected function call of the promise.</span>\n<span style=\"color:Green;\">// In the output JavaScript, the code following the try catch loop would</span>\n<span style=\"color:Green;\">// need to be wrapped in a function called by both onResolved and</span>\n<span style=\"color:Green;\">// onRejected.</span>\nasync <span style=\"color:Blue;\">function</span> loadComment(id: <span style=\"color:Blue;\">number</span>): WinJS.Promise&lt;Comment&gt; {\n     <span style=\"color:Blue;\">var</span> request = <span style=\"color:Blue;\">null</span>;\n     <span style=\"color:Blue;\">try</span> {\n          request = await WinJS.xhr({ url: <span style=\"color:#A31515;\">&quot;www.mywebsite.com/comments/&quot;</span> + id });\n     } <span style=\"color:Blue;\">catch</span> {\n          request = <span style=\"color:#A31515;\">&quot;This comment could not be loaded.&quot;</span>\n     }\n     <span style=\"color:Blue;\">return</span> &lt;Comment&gt; JSON.parse(request.innerText);\n}\n\n<span style=\"color:Green;\">// An array of promises can be return as a promise for all values.</span>\n<span style=\"color:Green;\">// Unfortunately, I don&#39;t know any way to do this without adding new </span>\n<span style=\"color:Green;\">// functions like __extends. Potentially user could define a function </span>\n<span style=\"color:Green;\">// with a specific name that wraps an array of promises with their favorite</span>\n<span style=\"color:Green;\">// library? (Q, WinJS, etc.)</span>\nasync <span style=\"color:Blue;\">function</span> loadComments(post: BlogPost): Promise&lt;Comment[]&gt; {\n     <span style=\"color:Blue;\">var</span> comments = &lt;Comment[]&gt;<span style=\"color:Blue;\">new</span> Array(post.commentIds.length);\n\n     <span style=\"color:Blue;\">for</span>(<span style=\"color:Blue;\">var</span> i = 0; i &lt; post.commentIds.length; i++) {\n          comments[i] = await loadComment(post.commentIds[i]);\n     }\n\n     <span style=\"color:Blue;\">return</span> comments;\n}\n\n<span style=\"color:Green;\">// Async doesn&#39;t have to be used as long as there&#39;s no return</span>\n<span style=\"color:Blue;\">function</span> displayBlogPost(id: <span style=\"color:Blue;\">number</span>): <span style=\"color:Blue;\">void</span> {\n     getBlogPost(id).then(<span style=\"color:Blue;\">function</span>(post) { <span style=\"color:Green;\">// Can still be used like a promise</span>\n          loadComments(post).then(<span style=\"color:Blue;\">function</span>(comments) { \n               ui.append(comments);\n          }\n          ui.append(post);\n     }\n}\r\n</pre></div>My reasons that this is how async/await need to be done are as follows:<br />\n<ol>\n<li>Don't need to add a lot of plumbing code to the output JavaScript. The compiler just looks that the return of an async function implements the implicit Promises/A+ interface, or is an array of such types. Makes it interoperable with any promise implementation as long as it's &quot;correct&quot;.</li>\n<li>Closely matches the conceptual model people are already using with promises. i.e. that promises are just a way to think about asynchronous code in a synchronous manner.</li>\n<li>\nIs similar to how C# uses Task as the object await acts on.<br />\n</li>\n</ol>\nSome possible drawbacks:<br />\n<ol>\n<li>Awaiting on arrays of async operations will require extra functions to be added </li>\n<li>\nDealing with rejected promises could be a tricky in a way that meshes well with the synchronous model of try/catch.<br />\n</li>\n</ol>\nAnd maybe you devs have already created the actual spec and it looks nothing like this. I'm just envisioning in my head waking up to TypeScript async/await support and having it be instantly useful and syntactically awesome with all of my existing libraries that use promises.<br />\n<br />\nLet me know what you guys think.<br />\n",
    "PostedDate": "2013-04-01T02:32:21.967-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023854",
    "ThreadId": "438647",
    "Html": "@AndrewGaspar, how will the JavaScript implementation of this look? <br />\n<pre><code>async function getBlogPost(id: number): WinJS.Promise&lt;BlogPost&gt; {\n     var request = await WinJS.xhr({ url: &quot;www.mywebsite.com/blog/post/&quot; + id });\n     return &lt;BlogPost&gt; JSON.parse(request.innerText);\n}</code></pre>\n\nAlso assuming the calling code will look like this<br />\n<pre><code>function onGetBlogClick(){\n  var post = await getBlogPost(5);\n\n var foo = new Foo();\n foo.displayPost(post);\n}</code></pre>\n\n",
    "PostedDate": "2013-04-01T10:41:32.907-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023865",
    "ThreadId": "438647",
    "Html": "\r\n<p dir=\"ltr\">&#43;1 to nabog's question. It's all very well asserting that the JavaScript plumbing code won't be complicated, but have you seen what the C# compiler has to do with await calls even in simple for loops?</p>\r\n<div></div>\r\n",
    "PostedDate": "2013-04-01T11:09:13.317-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023922",
    "ThreadId": "438647",
    "Html": "<strong>nabog wrote:</strong><br />\n<blockquote>\n@AndrewGaspar, how will the JavaScript implementation of this look? <br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\nasync <span style=\"color:Blue;\">function</span> getBlogPost(id: <span style=\"color:Blue;\">number</span>): WinJS.Promise&lt;BlogPost&gt; {\n     <span style=\"color:Blue;\">var</span> request = await WinJS.xhr({ url: <span style=\"color:#A31515;\">&quot;www.mywebsite.com/blog/post/&quot;</span> + id });\n     <span style=\"color:Blue;\">return</span> &lt;BlogPost&gt; JSON.parse(request.innerText);\n}\r\n</pre></div></blockquote>\nThis would translate to<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> getBlogPost(id) { \n     <span style=\"color:Blue;\">return</span> WinJS.xhr({ url: <span style=\"color:#A31515;\">&quot;www.mywebsite.com/blog/post/&quot;</span> + id }).then(<span style=\"color:Blue;\">function</span>(request) {\n          <span style=\"color:Blue;\">return</span> JSON.parse(request.innerText);\n     });\n}\r\n</pre></div><blockquote>\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> onGetBlogClick(){\n  <span style=\"color:Blue;\">var</span> post = await getBlogPost(5);\n\n <span style=\"color:Blue;\">var</span> foo = <span style=\"color:Blue;\">new</span> Foo();\n foo.displayPost(post);\n}\r\n</pre></div></blockquote>\nThis would translate to:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> onGetBlogClick() {\n     getBlogPost(5).then(<span style=\"color:Blue;\">function</span>(post) {\n          <span style=\"color:Blue;\">var</span> foo = <span style=\"color:Blue;\">new</span> Foo();\n          foo.displayPost(post);\n     });\n}\r\n</pre></div>Basically, any code following an await would be performed inside of the &quot;onResolved&quot; function of the promise.<br />\n",
    "PostedDate": "2013-04-01T13:50:36.803-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023937",
    "ThreadId": "438647",
    "Html": "That's a very naive implementation, basically just syntactic sugar for a callback. Proper C# style async/await can cope with await statements in loops, using very complicated iterator-based state machines.<br />\n",
    "PostedDate": "2013-04-01T14:24:22.26-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1032325",
    "ThreadId": "438647",
    "Html": "That seems like a really bad idea, it gives the illusion that &quot;onGetBlogClick&quot; would say &quot;foo.displayPost&quot; before it exits, but the fact is that it dont...<br />\n<br />\nImagine:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Foo {\n    Baz: <span style=\"color:Blue;\">string</span>;\n    Bar() {\n        <span style=\"color:Blue;\">this</span>.Baz = await someservice.getBaz();\n    }\n    \n    Boo() {\n        <span style=\"color:Blue;\">this</span>.Bar();\n        console.log(<span style=\"color:Blue;\">this</span>.Baz);\n    }\n}\r\n</pre></div>Which would most likely result in undefined, where the programmer would go &quot;Ehhh... what???&quot;... Because Baz aint set until later...<br />\n<br />\nI don't feel comfortable by adding the async/await keywords to TS considering that your not meant to block in JavaScript, I think it's better that people actually learn to use those promises...<br />\n<br />\nI don't mind syntactical sugar around the pattern, but it should make it clear what is going on.<br />\n<br />\nBut then again... IS it really needed... it's not like promises are a big burden to use... They might have a learning curve, but that's about it.<br />\n",
    "PostedDate": "2013-04-18T02:38:56.923-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1033663",
    "ThreadId": "438647",
    "Html": "<strong>jmelgaard wrote:</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Foo {\n    Baz: <span style=\"color:Blue;\">string</span>;\n    Bar() {\n        <span style=\"color:Blue;\">this</span>.Baz = await someservice.getBaz();\n    }\n    \n    Boo() {\n        <span style=\"color:Blue;\">this</span>.Bar();\n        console.log(<span style=\"color:Blue;\">this</span>.Baz);\n    }\n}\r\n</pre></div>This won't compile. If a method contains <code>await</code> then it must be marked as <code>async</code> and called with <code>await</code>. Without <code>await</code>, it will just return a promise. <br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Foo {\n    Baz: <span style=\"color:Blue;\">string</span>;\n    async Bar() {\n        <span style=\"color:Blue;\">this</span>.Baz = await someservice.getBaz();\n    }\n    \n    async Boo() {\n        await <span style=\"color:Blue;\">this</span>.Bar();\n        console.log(<span style=\"color:Blue;\">this</span>.Baz);\n    }\n}\r\n</pre></div>",
    "PostedDate": "2013-04-21T14:36:10.71-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1033675",
    "ThreadId": "438647",
    "Html": "@jmelgaard<br />\n<br />\nI don't think the criticism that Baz isn't set at that log statement is fair criticism. Firstly, the compiler would reject that code because Bar is not marked as async. Secondly, since Bar is an asynchronous function, the developer should not expect Baz to be set at that log statement without &quot;awaiting&quot; it. For example, see the following C# code:<br />\n<br />\nAsyncTest.cs<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">using</span> System;\n<span style=\"color:Blue;\">using</span> System.Threading;\n<span style=\"color:Blue;\">using</span> System.Threading.Tasks;\n<span style=\"color:Blue;\">using</span> System.IO;\n\n<span style=\"color:Blue;\">namespace</span> AsyncTest\n{\n    <span style=\"color:Blue;\">class</span> TestClass {\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">int</span> Value { <span style=\"color:Blue;\">get</span>; <span style=\"color:Blue;\">set</span>; }\n\n        <span style=\"color:Blue;\">private</span> Task wait()\n        {\n            <span style=\"color:Blue;\">return</span> Task.Delay(1000);\n        }\n\n        <span style=\"color:Blue;\">public</span> async Task IncrementValue() {\n            await wait();\n            Value++;\n        }\n\n        <span style=\"color:Blue;\">public</span> TestClass()\n        {\n            Value = 0;\n        }\n\n        <span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">static</span> async Task AsyncMain()\n        {\n            <span style=\"color:Blue;\">var</span> tc = <span style=\"color:Blue;\">new</span> TestClass();\n            <span style=\"color:Blue;\">var</span> task = tc.IncrementValue();\n\n            Console.WriteLine(tc.Value);\n\n            await task;\n\n            Console.WriteLine(tc.Value);\n        }\n\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">void</span> Main()\n        {\n            TestClass.AsyncMain().Wait();\n        }\n    }\n}\r\n</pre></div>The output, in general, should look like:<br />\n<pre><code>PS E:\\Personal Files\\Local\\Projects\\temp&gt; csc .\\AsyncTest.cs\nMicrosoft (R) Visual C# Compiler version 4.0.30319.17929\nfor Microsoft (R) .NET Framework 4.5\nCopyright (C) Microsoft Corporation. All rights reserved.\n\nPS E:\\Personal Files\\Local\\Projects\\temp&gt; .\\AsyncTest.exe\n0\n1</code></pre>\n\nA comparable TypeScript implementation would look like:<br />\n<br />\nAsyncTest.ts<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">/// &lt;reference path=&#39;q.module.d.ts&#39; /&gt;</span>\n\n<span style=\"color:Blue;\">import</span> q = <span style=\"color:Blue;\">module</span>(<span style=\"color:#A31515;\">&quot;q&quot;</span>);\n\n<span style=\"color:Blue;\">module</span> AsyncTest {\n    <span style=\"color:Blue;\">interface</span> Promise {\n        then(onFulfilled?: (value?: <span style=\"color:Blue;\">any</span>) =&gt; <span style=\"color:Blue;\">any</span>, onRejected?: (reason?: <span style=\"color:Blue;\">any</span>) =&gt; <span style=\"color:Blue;\">any</span>): Promise;\n    }\n\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> TestClass {\n\n        <span style=\"color:Blue;\">constructor</span>(<span style=\"color:Blue;\">public</span> value: <span style=\"color:Blue;\">number</span> = 0) { }\n\n        <span style=\"color:Blue;\">private</span> wait(): Promise {\n            <span style=\"color:Blue;\">var</span> def = q.defer();\n\n            setTimeout(() =&gt; def.resolve(), 1000);\n\n            <span style=\"color:Blue;\">return</span> def.promise;\n        }\n\n        <span style=\"color:Blue;\">public</span> incrementValue(): Promise {\n            <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>.wait().then(\n                () =&gt; <span style=\"color:Blue;\">this</span>.value++);\n        }\n\n        <span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">static</span> asyncMain() {\n            <span style=\"color:Blue;\">var</span> tc = <span style=\"color:Blue;\">new</span> TestClass();\n            <span style=\"color:Blue;\">var</span> task = tc.incrementValue();\n\n            console.log(tc.value);\n\n            <span style=\"color:Blue;\">return</span> task.then(<span style=\"color:Blue;\">function</span> () {\n                console.log(tc.value);\n            });\n        }\n\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> main() {\n            TestClass.asyncMain();\n        }\n    }\n}\n\nAsyncTest.TestClass.main();\r\n</pre></div>With an output of:<br />\n<pre><code>PS E:\\Personal Files\\Local\\Projects\\temp&gt; tsc AsyncTest.ts\nPS E:\\Personal Files\\Local\\Projects\\temp&gt; node AsyncTest.js\n0\n1</code></pre>\n\nObviously these two examples have a meaningful difference in that C# has multi-threading creating the asynchronous behavior and TypeScript's asynchronous behavior is due to the Event Loop, but I don't see how this is relevant to the purpose of async/await, which is to make reasoning about asynchronous programs easier. This syntactic sugar would be nice especially since seemingly compatible Futures for the DOM have been proposed by WHATWG. <a href=\"http://dom.spec.whatwg.org/#futures\" rel=\"nofollow\">http://dom.spec.whatwg.org/#futures</a><br />\n<br />\nNow, my proposed async/await version of this would look like:<br />\n<br />\nAsyncAwaitTest.ts<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">/// &lt;reference path=&#39;q.module.d.ts&#39; /&gt;</span>\n\n<span style=\"color:Blue;\">import</span> q = <span style=\"color:Blue;\">module</span>(<span style=\"color:#A31515;\">&quot;q&quot;</span>);\n\n<span style=\"color:Blue;\">module</span> AsyncTest {\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> TestClass {\n\n        <span style=\"color:Blue;\">constructor</span>(<span style=\"color:Blue;\">public</span> value: <span style=\"color:Blue;\">number</span> = 0) { }\n\n        <span style=\"color:Blue;\">private</span> wait(): Promise {\n            <span style=\"color:Blue;\">var</span> def = q.defer();\n\n            setTimeout(() =&gt; def.resolve(), 1000);\n\n            <span style=\"color:Blue;\">return</span> def.promise;\n        }\n\n        <span style=\"color:Blue;\">public</span> async incrementValue(): Promise {\n            await <span style=\"color:Blue;\">this</span>.wait();\n            <span style=\"color:Blue;\">this</span>.value++;\n        }\n\n        <span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">static</span> async asyncMain() {\n            <span style=\"color:Blue;\">var</span> tc = <span style=\"color:Blue;\">new</span> TestClass();\n            <span style=\"color:Blue;\">var</span> task = tc.incrementValue();\n\n            console.log(tc.value);\n\n            await task;\n\n            console.log(tc.value);\n        }\n\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> main() {\n            TestClass.asyncMain();\n        }\n    }\n}\n\nAsyncTest.TestClass.main();\r\n</pre></div>I completely agree that this doesn't really reduce the complexity of Promises at all since it effectively just adds syntactic sugar on top of them, but since Async/Await are currently being investigated for the 1.x according to the roadmap, it would be awesome if the pattern was implemented to conform to an existing, accepted community standard. It would instantly make many existing libraries, like WinJS and jQuery, compatible with the pattern.<br />\n",
    "PostedDate": "2013-04-21T16:06:53.95-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1033693",
    "ThreadId": "438647",
    "Html": "What would the output JavaScript look like for this:<br />\n<pre><code>class Argh {\n  constructor(private someService, private otherService, private yetAnotherService) { }\n\n  public async complicated(things: string[]) {\n    if (await someService.validate(things) &amp;&amp; await otherService.verify(things)) {\n      for (var i = 0; i &lt; things.length; i++) {\n        await yetAnotherService.save(things[i]);\n      }\n    } else {\n      throw new Error(&quot;Bother.&quot;);\n    }\n  }\n}</code></pre>\n\n",
    "PostedDate": "2013-04-21T17:26:58.153-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1033762",
    "ThreadId": "438647",
    "Html": "Just so you know, I'm working on a detailed response that hashes out some of the details better, but it's worth noting those services would have to be &quot;strongly&quot; typed because await would necessarily only operate on those types that implement the Promise interface described up top.<br />\n",
    "PostedDate": "2013-04-21T23:03:04.727-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1033832",
    "ThreadId": "438647",
    "Html": "@AndrewGaspar\r<br />\n<br />\nFair point, and I agree that if they are looking at async/await it should comply with promises, it's just that &quot;await&quot; gives me completely different associations than being a &quot;continuation&quot;, so I just think I in general don't like the keywords as they are...\r<br />\n<br />\nAnd then I am like... It's kind of simple enough as is, do we really need anything on top of it.<br />\n",
    "PostedDate": "2013-04-22T02:16:21.623-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1084580",
    "ThreadId": "438647",
    "Html": "Related work item: <a href=\"https://typescript.codeplex.com/workitem/38\" rel=\"nofollow\">Implement the &quot;await&quot; keyword for async calls</a>\r<br />\n<br />\nWith musical support! <a href=\"https://www.codeplex.com/Download/AttachmentDownload.ashx?ProjectName=typescript&amp;WorkItemId=38&amp;FileAttachmentId=500523\" rel=\"nofollow\">01 Async-Await.mp3</a><br />\n",
    "PostedDate": "2013-08-24T22:37:15.37-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]