[
  {
    "Id": "1230613",
    "ThreadId": "541277",
    "Html": "There are a few places in the current spec where it looks like the language design had to make a choice between type soundness and ease of using existing javascript libraries. In a couple of instances that I am aware of (function argument bivariance and optional/rest arguments), the choice was made to make it easier to use existing javascript libraries at the expense of soundness.<br />\n<br />\nHowever, I think a lot of developers would like the option to make the opposite trade-off - preferring soundness over convenience, especially when there is a workaround. I have a few proposals for addressing this (I don't think they are mutually exclusive) while not making it 'all-or-nothing'.<br />\n<br />\nThe first is to have a compiler switch that enforces soundness more strictly. In the example of function argument bivariance, enabling the soundness flag would mean that function arguments would succeed only if the source parameter is assignable to the target parameter:<br />\n<pre><code>// this is an error with the switch on, but compiles fine with the switch off\nlistenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x + ', ' + e.y));</code></pre>\n\nNow, when you have the soundness switch on and you want to &quot;opt-in&quot; to use the current behavior (e.g. structural bivariance), then I think there could be ways to make this less cumbersome.<br />\n<br />\nFirst, introduce an 'as' keyword. This keyword would be valid in function arguments only as a modifier to a type:<br />\n<pre><code>listenEvent(EventType.Mouse, (e: Event as MouseEvent) =&gt; console.log(e.x + ', ' + e.y));</code></pre>\n\nHere, the type of the lambda expression as a whole is (e: Event) =&gt; void, but in the body of the lambda, e is considered a MouseEvent. You can use the 'as' keyword for any function argument. For example:<br />\n<pre><code>interface IEventListener { listenEvent(eventType: EventType, e: Event): void; }\nclass MouseEventListener extends IEventListener {  listenEvent(eventType: EventType, e: Event as MouseEvent): void { console.log(e.x + ', ' + e.y); } }\naddListener(EventType.Mouse, new MouseEventListener());</code></pre>\n\nif introducing a new keyword is troublesome for whatever reason, maybe something that looks like a cast, but to the left of a type annotation. Slightly uglier, but less likely to conflict?<br />\n<pre><code>listenEvent(EventType.Mouse, (e: &lt;Event&gt;MouseEvent) =&gt; console.log(e.x + ', ' + e.y));</code></pre>\n\nAnother idea would be to introduce the idea of a inferred cast. An inferred cast would work as a regular cast, except that the target type of the cast would be inferred from context. For example:<br />\n<br />\nthis:<br />\n<pre><code>listenEvent(EventType.Mouse, &lt;&gt;(e: MouseEvent) =&gt; console.log(e.x + ', ' + e.y));</code></pre>\n\nwould be equivalent to this:<br />\n<pre><code>listenEvent(EventType.Mouse, &lt;(e: Event) =&gt; void&gt;(e: MouseEvent) =&gt; console.log(e.x+ ', ' + e.y));</code></pre>\n\nbecause the second argument of listenEvent expects an argument of type (e: Event) =&gt; void. <br />\n<br />\nHere's another example:<br />\n<pre><code>var event: Event = &lt;&gt;getMouseEvent(); // getMouseEvent returns a MouseEvent.</code></pre>\n\nFinally, if you support a &quot;soundness on&quot; switch, there should probably be some scoped way to turn it on or off, similar to the 'use strict' directive. There are probably a few ways to do this, from a keyword, to a 'use strict'; style statement, to an annotation, etc.. Here I'm using a comment:<br />\n<pre><code>// file compiled with soundness on\nvar foo = function() {\n  // @Sound(false)\n  listenEvent(EventType.Mouse, (e: MouseEvent) =&gt; ...etc... );\n  if(etc..) {\n    // @Sound(true)\n    listenEvent(EventType.Mouse, (e: Event as MouseEvent) =&gt; etc...);\n  }\n  // still off here\n  listenEvent(EventType.Mouse, (e: MouseEvent) =&gt; ...etc...);\n}\n\n// still on here\nlistenEvent(EventType.Mouse, (e: Event as MouseEvent) =&gt; etc....);</code></pre>\n\n[Edit: couple of typos, and I had e: MouseEvent as Event instead of, I think, the more intuitive e: Event as MouseEvent]<br />\n",
    "PostedDate": "2014-04-04T20:17:06.567-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]