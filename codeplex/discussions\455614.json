[
  {
    "Id": "1088771",
    "ThreadId": "455614",
    "Html": "A couple of issues have been raised recently to do with placing access modifiers on constructor functions (one raised by myself):<br />\n<br />\n<a href=\"https://typescript.codeplex.com/workitem/1639\" rel=\"nofollow\">https://typescript.codeplex.com/workitem/1639</a><br />\n<a href=\"https://typescript.codeplex.com/workitem/1591\" rel=\"nofollow\">https://typescript.codeplex.com/workitem/1591</a><br />\n<br />\nThese issues were closed with comments indicating that the compiler is working as intended in these cases. <br />\n<br />\nCurrent behaviour when placing an access modifier against a constructor function is that it ceases to be a constructor function and simply becomes a function called &quot;constructor&quot;.<br />\n<br />\ne.g.<br />\n<pre><code>class test1 {\n  constructor() {\n    // a constructor\n  }\n}\n\nclass test2 {\n  public constructor() {\n    // a function called constructor\n  }\n}\n\nclass test3 {\n  constructor() {\n    // a constructor\n  }\n\n  private constructor() {\n    // a function called constructor\n  }\n}</code></pre>\n\nCompiles to:<br />\n<pre><code>var test1 = (function () {\n    function test1() {\n        // a constructor\n    }\n    return test1;\n})();\n\nvar test2 = (function () {\n    function test2() {\n    }\n    test2.prototype.constructor = function () {\n        // a function called constructor\n    };\n    return test2;\n})();\n\nvar test3 = (function () {\n    function test3() {\n        // a constructor\n    }\n    test3.prototype.constructor = function () {\n        // a function called constructor\n    };\n    return test3;\n})();</code></pre>\n\nThis behaviour seems extremely unintuitive. Anyone who hasn't come across this behaviour before will assume that the constructor function in 'test2' is that class's actual constructor. The class 'test3' looks like it should raise a &quot;Multiple constructor implementations are not allowed.&quot; error. <br />\n<br />\nIt's an unnecessary pitfall for new Typescript developers to fall into given that no compile errors or warnings are generated but the code is unlikely to run as the developer anticipated.<br />\n<br />\nI'm not sure there's a case to be made for ever naming a function &quot;constructor&quot; thats not a constructor.<br />\n<br />\ne.g.<br />\n<pre><code>new test2();\ntest2.constructor(); // there's definitely a better name for whatever this function does</code></pre>\n\nIs there a reason behind the current implementation or is it simply a foible of the compiler?<br />\n<br />\nIf access modifiers aren't going to be supported for constructors a compile time error seems a better solution than the current odd behaviour.<br />\n",
    "PostedDate": "2013-09-05T07:27:14.143-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1099649",
    "ThreadId": "455614",
    "Html": "The <code>constructor</code> property on a prototype object has a special role in JavaScript. A function's prototype has its <code>constructor</code> property set to reference the function itself.<br />\n<pre><code>function MyConstructor() {};\nMyConstructor.prototype.constructor === MyConstructor; // true</code></pre>\n\nAlso, this <code>constructor</code> property is not enumerable by default.<br />\n<br />\nThis, however, is broken in situations where we build a prototype chain and assign the prototype property explicitly.<br />\n<pre><code>function MyOtherConstructor() {};\nMyOtherConstructor.prototype = new MyConstructor();\nMyOtherConstructor.prototype.constructor === MyOtherConstructor; // false</code></pre>\n\nThis is why a common pattern is to set the <code>constructor</code> property on the prototype manually. This is what TypeScript's <code>__extends</code> function does (besides other things):<br />\n<pre><code>var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};</code></pre>\n\nSo in the scheme of things, I wonder what the purpose of allowing to override the <code>constructor</code> property on the prototype is?<br />\n<br />\nIf I am not mistaken, the <code>constructor</code> property does not serve any specific purpose in prototype based inheritance (e.g. <code>instanceof</code> checks against the <code>prototype</code> property, not the <code>constructor</code> property), but it allows to reference the constructor function on an object from 'user' code.<br />\n<br />\nAlso, if I remember correctly the TS compiler used to fail on &quot;constructor&quot; definitions that had access modifier in earlier versions of the compiler (0.8?).<br />\n<br />\nIt would be interesting to hear more about the reasoning of the current implementation.<br />\n<br />\nMaybe the straight-forward answer is that it follows the ES.next spec?<br />\n",
    "PostedDate": "2013-09-26T06:25:38.873-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1099725",
    "ThreadId": "455614",
    "Html": "We've decided that 'public constructor' will just be the same as 'constructor' going forward. 'private constructor' will be an error (for now).<br />\n",
    "PostedDate": "2013-09-26T08:57:53.497-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]