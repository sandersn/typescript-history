[
  {
    "Id": "1266207",
    "ThreadId": "551687",
    "Html": "Some recent posts (<a href=\"https://typescript.codeplex.com/workitem/2622\" rel=\"nofollow\">#2622</a>, <a href=\"https://typescript.codeplex.com/workitem/2624\" rel=\"nofollow\">#2624</a>), or <a href=\"https://twitter.com/mapastr/status/487613047650144257\" rel=\"nofollow\">tweets</a>, were talking about the type <em>any</em>, in which the developers were using it 'wrong', or 'not as intended', or... anyway.<br />\n<br />\n<strong>@danquirk</strong> said in #2624: <br />\n<blockquote>\nA value of type 'any' is simply assignable to or from a value of any type. That assignability rule is precisely why the type exists. It is to model how JavaScript works.<br />\n</blockquote>\nUnderstandable. Any normal JavaScript variables should have <em>any</em> type because we don't know their exact type. However, the type name &quot;any&quot; itself is somewhat misleading.<br />\n<pre><code>interface Foo {\n    a: any;\n}\n</code></pre>\n\nThis interface has a property <em>a</em>, which type is <em>any</em>. Here, a programmer would expect that they can assign any types of values to the property.<br />\n<pre><code>interface Foo extends Bar {\n    a: any;\n}\ninterface Bar {\n    a: number\n}\n</code></pre>\n\nIn this example, we now have a Bar interface that has a number type variable, and Foo now extends Bar. That is, every objects that is compatible with Foo should be compatible with Bar. As you know, this code would not match that criteria because <em>a</em> property in interface Foo <strong>would not be always compatible</strong> with the one in interface Bar. However, this anyway is valid code, because the <em>any</em> type is designed so.<br />\n<pre><code>var bar: Bar = { a: 3 }; // Valid\nvar foo: Foo = { a: 'not a number' }; // Valid\nvar foobar: Bar = &lt;Foo&gt;{ a: &quot;I'm a string&quot; }; // Valid... wait, really?\n</code></pre>\n\nThe value assigned to <em>foobar</em> is not really compatible with interface Bar, but this is valid TypeScript code, because <strong>a value of type 'any' is simply assignable to</strong> or from a value of <strong>any type</strong>!<br />\n<br />\nFortunately, we have a way to prevent this.<br />\n<pre><code>interface Foo extends Bar {\n    a: {};\n}\ninterface Bar {\n    a: number\n}\n</code></pre>\n\nNow the type checker will report that the property <em>a</em> in interface Foo has an incompatible type &quot;{}&quot;, because type {} does not have the same assignability rule that the type <em>any</em> have.<br />\n<br />\n<strong>What's the point?</strong> I would say that the existing type name <strong>any</strong> should be changed to <strong>unknown</strong>, and the new type <strong>any</strong> should be <strong>an alias for the type {}</strong>. (The name <em>any</em> is anyway better than {});<br />\n<br />\nLet's note that W3C WebIDL also have their own <em>any</em> type. Its <em>any</em> type is defined as <strong>the union of all other possible non-union types</strong>. It works as the type {} does (while TypeScript has no union type yet). This type is used to specify the parameter type of standard APIs. That is, the name <em>any</em> is/will be known to many, many Web developers. It should not be misleading because it would frustrate those developers who may try TypeScript later.<br />\n<br />\nI suggest the new <em>any</em>/<em>unknown</em> type, so that we can give the type <em>any</em> to literally assign any values of any types, but without any specialized assignability rule designed for JavaScript.<br />\n",
    "PostedDate": "2014-07-16T04:38:20.187-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1266342",
    "ThreadId": "551687",
    "Html": "One thing to keep in mind is that names are not selected by random &quot;just because&quot;.  Those behind TypeScript are focusing the semantics on what lays ahead for the future of JavaScript.  One must always ask first &quot;is this in TS because it's in ES6/7?&quot;, because if it is, it's not going to change.  I found this link here on ecmascript.org that references the &quot;any&quot; type as well: <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:typed_objects#built-in_reference_types\" rel=\"nofollow\">http://wiki.ecmascript.org/doku.php?id=harmony:typed_objects#built-in_reference_types</a><br />\n",
    "PostedDate": "2014-07-16T10:42:40.21-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1267422",
    "ThreadId": "551687",
    "Html": "<strong>@jamesnw</strong> Current type {} also can reference any ECMAScript value. Would there a problem if we define <em>any</em> type as an alias for type {}?<br />\n",
    "PostedDate": "2014-07-16T13:05:50.983-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1268083",
    "ThreadId": "551687",
    "Html": "Yes, <code>{}</code> means &quot;an empty object&quot;, which matches &quot;all objects&quot; as a base type.<br />\n<pre><code>var o1: {} = {x: 1}; // ok\nvar o2: {x} = &lt;{}&gt;{x: 1}; // error</code></pre>\n\n<code>o1</code> is not type &quot;any&quot;, its a type of &quot;empty object&quot; (a base type for all types only), which is why this also fails: <code>o1.x = 1; // error: The property 'x' does not exist on value of type '{}'.</code><br />\n<br />\nIf <code>o1</code> was of of type 'any', then <code>o1.x = 1;</code> would work.<br />\n<br />\nLet's try something else:<br />\n<pre><code>var n1: number = 1;\nvar n2: {} = 2;\nn1 = n2; // fails: Cannot convert '{}' to 'number'.</code></pre>\n\nSo, though you can assign <em>anything</em> to n2, what use is it? You can't assign it to anything else other than another <code>{}</code>, <code>Object</code>, or <code>any</code> type only.<br />\n",
    "PostedDate": "2014-07-16T13:50:55.033-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1268453",
    "ThreadId": "551687",
    "Html": "That consequence is exactly what I want.<br />\n<pre><code>var param: any = arg1; // an unexpectable value from external source\nvar num: number = param;\n</code></pre>\n\nCurrent <em>any</em> type just allows this. Why it should be allowed in TypeScript? I think that the only reason is to guarantee the compatibility with regular JavaScript. TypeScript supports type casting which is more strict, and we can do this:<br />\n<pre><code>var param: {} = arg1; // an unexpectable value from external source\nvar num: number = &lt;number&gt;param; // Valid casting\n</code></pre>\n\nWe can explicitly cast the type so that we can always assure what's going on.<br />\n",
    "PostedDate": "2014-07-16T14:28:52.773-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1268544",
    "ThreadId": "551687",
    "Html": "What I want is:<br />\n<br />\ncurrent type <em>any</em> -&gt; new type <em>unknown</em><br />\ncurrent type {} -&gt; make an alias for it with new <em>any</em> so that <em>any</em> refers {}<br />\n<br />\nThen, type-less ordinary JavaScript variables would have new type <em>unknown</em> which is same as current <em>any</em>, and new <em>any</em> would lose its specialized assignability rule while <em>unknown</em> still have it.<br />\n",
    "PostedDate": "2014-07-16T14:38:31.46-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1269259",
    "ThreadId": "551687",
    "Html": "Well, in either case, &quot;unknown&quot; is not a good alternative IMHO.  Sometimes a type IS known, just cast in a special way, like this:<br />\n<pre><code>class A { static n: number; }\nvar callConstructorA: {():A} = &lt;any&gt;A; // &lt;unkown&gt;A; is not right, because I know it.</code></pre>\n\nI've actually done something similar in a project already (though this is a special case).\r<br />\n<br />\nI really doubt this will change.  There are tons of developers with projects that have over 150 scripts each, and they are not going to break it because one person doesn't want to type <code>{}</code>, and prefers <code>any</code> to personally mean something else. ;)  Best you can hope for is type alias support, like here: <a href=\"https://typescript.codeplex.com/workitem/119\" rel=\"nofollow\">https://typescript.codeplex.com/workitem/119</a><br />\n",
    "PostedDate": "2014-07-16T16:03:47.03-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1270640",
    "ThreadId": "551687",
    "Html": "A couple things:\r<br />\n<br />\nChanging 'any' to mean {} would break essentially every piece of existing TypeScript out there. We would never do this.\r<br />\n<br />\nSecond, I think you're misreading how the WebIDL is describing 'any'. What it describes is basically what TypeScript models with 'any'. It says<br />\n<pre><code>The any type is like a discriminated union type, in that each of its values has a specific non-any type associated with it. For example, one value of the any type is the unsigned long 150, while another is the long 150. These are distinct values. </code></pre>\n\nA discriminated union essentially defines a list of types and an instance of the discriminated union type can only be a single one of those types. Generally you would need to handle all of its possible states in order to have a provably sound program. For a more concrete example, in F# you could define a discriminated union type like <code>type MyThings = | Foo | Bar</code> and now when processing a value x of type MyThing the compiler will give you an error if you do not explicitly handle the case where x is of type Foo and the case where x is of type Bar. In our case here the type Any is a discriminated union representing not just the Foo and Bar types, but ALL types that could ever exist. Obviously it's impossible to ask someone to explicitly handle how to process a value for each individual type it could ever be. Instead the compiler does no checking and leaves you free to handle it as you see fit as this is how JavaScript manages this type of world.\r<br />\n<br />\n{} means something very precise and very different. It means an object with no members (other than those inherited from Object). It is almost completely the opposite of 'any' in a lot of cases. You can assign a value of type 'any' to anything. You can assign a value of type {} to nothing except {}, Object and any. Defining something as type {} makes that value almost unusable as a result. At almost every point where you use an object of type {} you would need to cast it to a more specific type to do something as simple as property access or assignment. This is surely not what people want to do.<br />\n",
    "PostedDate": "2014-07-16T19:42:18.037-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1273323",
    "ThreadId": "551687",
    "Html": "<strong>@jamesnw</strong>, Um... I think this is better to do that.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> A { <span style=\"color:Blue;\">static</span> n: <span style=\"color:Blue;\">number</span>; }\n<span style=\"color:Blue;\">var</span> callConstructorA: { <span style=\"color:Blue;\">new</span> (): A } = A;\r\n</pre></div>Now you don't have to do any type cast, while the resulting compiled JavaScript is same.\r<br />\n<br />\nAnd... the name <em>unknown</em> can be thought as: <br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">enum</span> KeyboardEventNames {\n    KeyDown = &lt;unknown&gt;<span style=\"color:#A31515;\">&quot;keydown&quot;</span>, <span style=\"color:Green;\">// OK, you know that this is a string, but let&#39;s &quot;forget&quot; it and treat it as number.</span>\n    KeyUp = &lt;unknown&gt;<span style=\"color:#A31515;\">&quot;keyup&quot;</span>\n    ...\n}\r\n</pre></div>... though this is really tricky case.\r<br />\n<br />\nThe name <em><a href=\"http://msdn.microsoft.com/en-us/library/dd264736.aspx\" rel=\"nofollow\">dynamic</a></em> may be more friendly for some C# users, as <a href=\"https://twitter.com/diullei/status/487622511417643008\" rel=\"nofollow\">user @diullei say</a>.\r<br />\n<br />\n<strong>@danquirk</strong>, Yes... I don't know much about F# and discriminated union. Thank you for your explanation.\r<br />\n<br />\nHowever, it seems that F# have &quot;pattern matching&quot; to work type-safely.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">type</span> Variant =\n    | Numeric <span style=\"color:Blue;\">of</span> int\n    | Text <span style=\"color:Blue;\">of</span> string\n    | Empty\n      \n<span style=\"color:Blue;\">let</span> print v =\n    <span style=\"color:Blue;\">match</span> v <span style=\"color:Blue;\">with</span>\n    | Numeric n <span style=\"color:Blue;\">-&gt;</span> printfn <span style=\"color:#A31515;\">&quot;Num %d&quot;</span> n\n    | Text s    <span style=\"color:Blue;\">-&gt;</span> printfn <span style=\"color:#A31515;\">&quot;Txt %s&quot;</span> s\n    | Empty     <span style=\"color:Blue;\">-&gt;</span> printfn <span style=\"color:#A31515;\">&quot;Empty&quot;</span>\r\n</pre></div>TypeScript users also would want to know the exact type of <em>any</em>-typed objects and then use it, if they want to be type-safe. What do we have? We have type-casting, and we still can check the type somehow.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">//A pre-defined function</span>\n<span style=\"color:Green;\">//function getResultFromSomething(): any {</span>\n<span style=\"color:Green;\">//  if (someoneAsksTheAnswer)</span>\n<span style=\"color:Green;\">//      return 42;</span>\n<span style=\"color:Green;\">//  else if (anywaySomethingHappens)</span>\n<span style=\"color:Green;\">//      return &quot;the result I want&quot;</span>\n<span style=\"color:Green;\">//}</span>\n\n<span style=\"color:Blue;\">var</span> result: <span style=\"color:Blue;\">string</span>;\nresult = getResultFromSomething();\n<span style=\"color:Green;\">/*\n    Hmm... I&#39;m new to TypeScript.\n    I assigned a value to string typed variable and type checker does not show any error.\n    The data should be a string here.\n    I can safely keep going...\n    ...\n    ...\n    D&#39;oh?!\n*/</span>\r\n</pre></div>Instead, one would do this:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> result: <span style=\"color:Blue;\">string</span>;\n<span style=\"color:Green;\">//result = getResultFromSomething();</span>\n<span style=\"color:Green;\">/* \nOh, My IDE says I cannot do an implicit conversion here! \nSomething is wrong.\nOh, result.data is not a string type property. Thank you type checker.\n*/</span>\n\nresult = &lt;<span style=\"color:Blue;\">string</span>&gt;getResultFromSomething();\n<span style=\"color:Blue;\">if</span> (<span style=\"color:Blue;\">typeof</span> result !== <span style=\"color:#A31515;\">&#39;string&#39;</span>) <span style=\"color:Green;\">// I have to check this to be type-safe</span>\n    <span style=\"color:Blue;\">throw</span> <span style=\"color:Blue;\">new</span> Error(<span style=\"color:#A31515;\">&quot;D&#39;oh! the result was not a string type.&quot;</span>);\r\n</pre></div>... while it would be more complex when the return value type is not a primitive one. It's JavaScript anyway... \r<br />\n<br />\nAs a former C# user, I want <em>any</em> to be more strict. Lot's of <em>any</em>s are in TypeScript, but I would not use that much <em>dynamic</em>s in my C# code. People who want strict types would be confused, <a href=\"https://twitter.com/mapastr/status/487613047650144257\" rel=\"nofollow\">as Mr. Pastorelli was</a>. We definitely need the special type for the compatibility with JavaScript, but we can do better in type-safe TypeScript zone, can't we?<br />\n",
    "PostedDate": "2014-07-17T02:49:17.36-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1273574",
    "ThreadId": "551687",
    "Html": "@SaschaNaz  Sorry, that code is not what the example is trying to do.  The point was to call the constructor directly without &quot;new&quot;.<br />\n",
    "PostedDate": "2014-07-17T07:53:46.673-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1273687",
    "ThreadId": "551687",
    "Html": "I don't think that argument holds.  Just because you force cast something doesn't mean it will be enforced at runtime, so like in your example, you have to check it anyhow.  This is true in all cases, since in the JavaScript world, you could get something other than string.  Consider this:<br />\n<pre><code>function doSomething(s: string) { }\n</code></pre>\n\nSo, when end users use that API function (in <strong>JavaScript</strong>, not TypeScript), can I guarantee that 's' is a string?  Of course not.  I need to check it anyway.  This is the nature of JavaScript.  TypeScript is not a new language, it just adds type information to the existing JavaScript behavior.  Adding a cast from 'any' doesn't solve the problem, except forcing developers to cast to the type the variable already is.  When I add functions, I always check the return type.  If a user wanted to call &quot;getResultFromSomething()&quot;, I think they'd be pretty dumb not to also know what it does, and check the return type (unless they're a monkey just hitting keys).  In the case for user callback functions with return types, even if the return type is &quot;string&quot;, that means nothing, because in the JS world, it can be anything, so I'd still have to check it.  When I was new to TypeScript back near the beginning, this was never ever an issue at all.  Perhaps this is more an issue for those coming from C#.<br />\n<br />\nDon't compare with F# or C#, because this is JavaScript, and behaves very different.  For those coming from JavaScript, any type checking is many times better than none at all. (for the record, though I know dozens of languages [and even created some of my own scripting languages], and created many JS libraries for personal use, I recently came into TypeScript from C#/Silverlight myself, and was perfectly happy).<br />\n",
    "PostedDate": "2014-07-17T11:42:34.42-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1273695",
    "ThreadId": "551687",
    "Html": "As a current TypeScript user, I want &quot;any&quot; to carry on working as documented in the TypeScript specification. I've got tens of thousands of lines of production code in this language, and you want to stop them compiling because the semantics don't make\r\n sense to you?<br>\r\n<br>\r\n",
    "PostedDate": "2014-07-17T12:29:38.713-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1274216",
    "ThreadId": "551687",
    "Html": "<strong>@jamesnw</strong>, right, we always have to check it when we make <em>end-point API</em>. However, we don't always make end-point APIs ;)<br />\n<br />\nHmm... The reason why I started this discussion is because I feel fairly odd about this code. (already in the post)<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">interface</span> Foo {\n    x: <span style=\"color:Blue;\">string</span>;\n}\n<span style=\"color:Blue;\">interface</span> Bar <span style=\"color:Blue;\">extends</span> {\n    x: <span style=\"color:Blue;\">any</span>;\n}\r\n</pre></div>Interface Bar here is definitely broader than interface Foo. However, this is anyway valid code, because that's what <em>any</em> is. People who use <em>any</em> just to assign any types of values also have to deal with the special rule, which allows <em>any</em>-type value to be assigned to any non-<em>any</em> type variables.<br />\n<br />\nThe main point of my last example was not about the manual type checking that we actually always have to do when we make JavaScript APIs. I just wanted to describe some scenarios that more strict <em>any</em> might be more helpful. It seems that it was unsuccessful.<br />\n<br />\nWell... when I wrote my last example, I found that my suggestion would be really painful when we want to do this.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> foo(x: <span style=\"color:Blue;\">any</span>) {\n    <span style=\"color:Blue;\">if</span> (x.specificProperty) { <span style=\"color:Green;\">// Let&#39;s check the type by checking a certain property is there</span>\n    }\n    <span style=\"color:Blue;\">else</span> <span style=\"color:Blue;\">if</span> (x.otherProperty) { <span style=\"color:Green;\">// Checking another specific type</span>\n    }\n}\n\r\n</pre></div>We have to cast all the time to do simple things if this is prevented, as <strong>@danquirk</strong> said. Definitely we don't want to do this.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> foo(x: <span style=\"color:Blue;\">any</span>) {\n    <span style=\"color:Blue;\">if</span> ((&lt;SomeSpecificType&gt;x).specificProperty) { <span style=\"color:Green;\">// Fairly painful... while someone may prefer this</span>\n    }\n    <span style=\"color:Blue;\">else</span> <span style=\"color:Blue;\">if</span> ((&lt;AnotherSpecificType&gt;x).otherProperty) {\n    }\n}\n\r\n</pre></div>Well, I'm not an evil trying to break tens of thousands of lines of production code in this language. Then, I thought about <strong>the less-strict <em>any</em></strong> than my first suggestion.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">// Declaring variables</span>\n<span style=\"color:Blue;\">var</span> a; <span style=\"color:Green;\">// implicit unknown</span>\n<span style=\"color:Blue;\">var</span> a2: unknown; <span style=\"color:Green;\">// explicit unknown</span>\n<span style=\"color:Blue;\">var</span> b: <span style=\"color:Blue;\">any</span>; <span style=\"color:Green;\">// new any</span>\n<span style=\"color:Blue;\">var</span> c: {} <span style=\"color:Green;\">// {}</span>\n\n<span style=\"color:Green;\">// Accessing properties</span>\na.x <span style=\"color:Green;\">// allowed</span>\nb.x <span style=\"color:Green;\">// allowed</span>\nc.x <span style=\"color:Green;\">// not allowed</span>\n\n<span style=\"color:Green;\">// Assigning</span>\n<span style=\"color:Blue;\">var</span> foo: <span style=\"color:Blue;\">string</span>;\nfoo = a; <span style=\"color:Green;\">// allowed</span>\nfoo = b; <span style=\"color:Green;\">// not allowed. Hey, are you sure you know what you are doing? If so, consider a type casting ;)</span>\nfoo = &lt;unknown&gt;b; <span style=\"color:Green;\">// allowed</span>\nfoo = c; <span style=\"color:Green;\">// not allowed</span>\n\n<span style=\"color:Green;\">// Extending interfaces</span>\n<span style=\"color:Blue;\">interface</span> Foo {\n    x: <span style=\"color:Blue;\">string</span>;\n}\n<span style=\"color:Blue;\">interface</span> A <span style=\"color:Blue;\">extends</span> Foo {\n    x: unknown; <span style=\"color:Green;\">// allowed</span>\n}\n<span style=\"color:Blue;\">interface</span> B <span style=\"color:Blue;\">extends</span> Foo {\n    x: <span style=\"color:Blue;\">any</span>; <span style=\"color:Green;\">// not allowed. B is broader than Foo here</span>\n}\n<span style=\"color:Blue;\">interface</span> C <span style=\"color:Blue;\">extends</span> Foo {\n    x: {}; <span style=\"color:Green;\">// not allowed</span>\n}\r\n</pre></div><ol>\n<li><em>Unknown</em>, or maybe <em>dynamic</em>, here is exactly the same one as current <em>any</em>. It still have the special assignability rule.</li>\n<li><em>Any</em> now loses the rule but we can still access its properties without any type casting.</li>\n<li>\n{} is the {} we know.<br />\n</li>\n</ol>\nThis still will break existing codes, but that would not be as severe as my first suggestion. <strong>Maybe we can add a compiler option</strong> that does nothing to <em>any</em> but just adds <em>unknown</em> as an alias for <em>any</em>, to protect existing codes.<br />\n<br />\nWould this still be unacceptable and break all tens of thousands of lines of production code in this language so drastically? Please note that I just want to prevent any possible misleading and confusion. I like TypeScript, and I don't want to be evil but rather just discuss this.<br />\n",
    "PostedDate": "2014-07-19T05:06:37.01-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]