[
  {
    "Id": "923019",
    "ThreadId": "398363",
    "Html": "\r\n<p>&quot;chaining&quot; APIs are popular (and cool) in JavaScript and it would be nice to have a _this type to handle them seamlessly with class hierarchies.</p>\r\n<p>Consider the following example:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">interface</span> Base {\n  m1() : Base; <span style=\"color:green\">// returns this for chaining</span>\n}\n\n<span style=\"color:blue\">interface</span> Derived <span style=\"color:blue\">extends</span> Base {\n  m2(): Derived; <span style=\"color:green\">// returns this for chaining</span>\n}\n\n<span style=\"color:blue\">new</span> Derived().m2().m1(); <span style=\"color:green\">// works</span>\n<span style=\"color:blue\">new</span> Derived().m1().m2(); <span style=\"color:green\">// error: m2 not defined in Base</span>\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>Would be nice to be able to type all these interface elements as returning _this rather than Base/Derived.</p>\r\n<p>Note: this feature exists in Eiffel (like Current). It has some issues (the &quot;catcall&quot; problem) but I have the impression that the issue goes away if we only allow it on return types (not on parameter types).</p>\r\n<p>I got around the problem in my APIs by typing the return as &quot;any&quot; but then I lose all type checking in the remainder on the chain.</p>\r\n",
    "PostedDate": "2012-10-07T04:14:34.09-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923067",
    "ThreadId": "398363",
    "Html": "<p>I actually think this is a bug!</p>\r\n<p>Coming from the other typed javascript land (closure tools), I think it is only natural for a compiler to be able to understand the type of the instance that is calling prototype methods. In the example provided it is obvious that the m1 method called is called with 'this' being an instance of the subclass and that it is called as a method, so basically the compiler should be able to determine that in this case the returned object is no longer the one set in the method definition (or for that mater, the inferred one), because it was actually invoked in in another class using the prototype chain.</p>\r\n<p><br />I believe this should be fixed.</p>\r\n<p>Can someone from the team confirm that it is a bug?</p>\r\n<p>Thanks</p>",
    "PostedDate": "2012-10-07T08:44:02.093-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923110",
    "ThreadId": "398363",
    "Html": "<p>@pstj</p>\r\n<p>You mean that the `Base` return type should be implicitly covariant. Would work but it may a bit too permissive (accept Derived in contexts where the developer really means Base).</p>\r\n<p>Consider:</p>\r\n<pre>interface Node {\r\n  next() : Node; \r\n  fooAndChain() : _this;\r\n}\r\ninterface Node1 extends Node {}\r\ninterface Node2 extends Node {}</pre>\r\n<p>if obj is a Node1:</p>\r\n<ul>\r\n<li> obj.next() may return a Node1 or a Node2 </li>\r\n<li>obj.fooAndChain() may only return a Node1</li>\r\n</ul>\r\n<p>Would be nice to have the ability to distinguish between the two.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-10-07T10:51:15.403-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923120",
    "ThreadId": "398363",
    "Html": "\r\n<p>Well, I was hoping that the compiler can derive the type based on the actual code and not only by the type annotation: considering the following code:\r\n</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">class</span> ANode {\n  <span style=\"color:blue\">private</span> next_: ANode;\n  setNode(next: ANode):<span style=\"color:blue\">void</span> {\n    <span style=\"color:blue\">this</span>.next_ = next;\n  }\n  next(): ANode {\n    <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>.next_;\n  }\n}\n\n<span style=\"color:blue\">class</span> Node1 <span style=\"color:blue\">extends</span> ANode {\n  method1(): Node1 {\n    <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>;\n  }\n}\n\n<span style=\"color:blue\">class</span> Node2 <span style=\"color:blue\">extends</span> ANode {\n  method2(): Node2 {\n    <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>;\n  }\n}\n\n<span style=\"color:blue\">var</span> a = <span style=\"color:blue\">new</span> Node1();\n<span style=\"color:blue\">var</span> b = <span style=\"color:blue\">new</span> Node2();\na.setNode(b);\n\na.next().method2();\n\n</pre>\r\n</div>\r\n<p></p>\r\n<p>It is clear that this is valid and believed the compiler should be able to determine that the type returned by 'next' is actually Node2 and that it only checks if it is a valid 'ANode' interface (and it should be because it extends ANode) but still consider\r\n its real type (Node2).</p>\r\n<p>&nbsp;</p>\r\n<p>However it seems the compiler is casting the returned item type to the one defined. Bummer.</p>\r\n<p>&nbsp;</p>\r\n<p>This is why I think this is a bug or at least should be a feature request: The returned type should be Node2 and only checked if it matches the type definition (ANode) instead of being considered ANode. If this is not fixed lots of code will not be possible\r\n to be type checked because this is a widely used pattern.</p>\r\n",
    "PostedDate": "2012-10-07T11:26:49.3-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923130",
    "ThreadId": "398363",
    "Html": "<p>@pstj you can do what you're trying to do in TypeScript but you have to do it with interfaces.&nbsp; Here's one approach to creating a chainable library that can be extended with plugins:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>\r\n<span style=\"color: green;\">// Base library</span>\r\n<span style=\"color: blue;\">class</span> MyLib {\r\n\t<span style=\"color: blue;\">public</span> method1(): IMyLib { <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span>; }\r\n\t\r\n\t<span style=\"color: blue;\">static</span> create(): IMyLib {\r\n\t\t<span style=\"color: blue;\">return</span> &lt;any&gt;<span style=\"color: blue;\">new</span> MyLib();\r\n\t}\r\n}\r\n\r\n<span style=\"color: blue;\">interface</span> IMyLib {\r\n\tmethod1(): IMyLib;\r\n}\r\n\r\n<span style=\"color: green;\">// Extend library with a plugin</span>\r\nMyLib.prototype[<span style=\"color: #a31515;\">'method2'</span>] = <span style=\"color: blue;\">function</span> (): IMyLib { <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span>; };\r\n\r\n<span style=\"color: blue;\">interface</span> IMyLib {\r\n\tmethod2(): IMyLib;\r\n}\r\n\r\n<span style=\"color: blue;\">var</span> lib = MyLib.create();\r\nlib.method1().method2().method1();\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>This is leveraging the fact that interfaces are open in TypeScript and this is&nbsp;one of the key scenarios they had in mind&nbsp;for interfaces.&nbsp; There are a number of ways you could approach extending MyLib's prototype with your plugins methods&nbsp;but the main point is that&nbsp;to get the fluid&nbsp;style approach you're wanting you're going to need to use interfaces.</p>\r\n<p>&nbsp;&nbsp;</p>",
    "PostedDate": "2012-10-07T12:01:42.613-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923134",
    "ThreadId": "398363",
    "Html": "\r\n<p>Let me restate the problem with classes (I described it with interfaces because I was writing definitions for existing JS code). Consider:</p>\r\n<p>&nbsp;</p>\r\n<pre>class Base {\n  m() { return this }; // returns this for chaining\n}\n\nclass Derived1 extends Base {\n  m1() { return this } // returns this for chaining\n}\n\nclass Derived2 extends Base {\n  m2() { return this } // returns this for chaining\n}<br><br>function foo(d1: Derived1, d2: Derived2) {\n  d1.m1().m1().m(); // works\n  d2.m2().m2().m(); // works\n  d1.m().m1(); // error: m1 not defined in Base\n  d2.m().m2(); // error: m2 not defined in Base<br>}<br></pre>\r\n<p>The compiler cannot infer that m() returns a Derived1 when applied to a Derived1 (*). So, unless we have a type annotation like _this, we cannot solve the problem.</p>\r\n<p>The interface solution would be a kludge. It would force us to put all methods (m, m1 and m2) into a single interface.</p>\r\n<p>(*) Consider the following:</p>\r\n<pre>class BreaksChain extends Derived1 {\n  m() { return new Derived2(); } \n}\n</pre>\r\n",
    "PostedDate": "2012-10-07T12:30:34.703-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923136",
    "ThreadId": "398363",
    "Html": "\r\n<p>I see... Yes that looks like an issue worth raising.</p>\r\n",
    "PostedDate": "2012-10-07T12:37:55.22-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923279",
    "ThreadId": "398363",
    "Html": "<p>but this example would work, right?</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">class</span> Base {\r\n  <span style=\"color: blue;\">public</span> self;\r\n  constructor() { <span style=\"color: blue;\">this</span>.self = <span style=\"color: blue;\">this</span>; }\r\n  m() { <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span>.self }; <span style=\"color: green;\">// returns this for chaining</span>\r\n \r\n}\r\n\r\n<span style=\"color: blue;\">class</span> Derived1 <span style=\"color: blue;\">extends</span> Base {\r\n  m1() { <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span>.self } <span style=\"color: green;\">// returns this for chaining</span>\r\n}\r\n\r\n<span style=\"color: blue;\">class</span> Derived2 <span style=\"color: blue;\">extends</span> Base {\r\n  m2() { <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span>.self } <span style=\"color: green;\">// returns this for chaining</span>\r\n}\r\n\r\n<span style=\"color: blue;\">function</span> foo(d1: Derived1, d2: Derived2) {\r\n  d1.m1().m1().m(); <span style=\"color: green;\">// works</span>\r\n  d2.m2().m2().m(); <span style=\"color: green;\">// works</span>\r\n  d1.m().m1(); <span style=\"color: green;\">// works, because of self</span>\r\n  d2.m().m2(); <span style=\"color: green;\">// works, because of self</span>\r\n}\r\n\r\n\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-10-08T00:30:44.233-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923297",
    "ThreadId": "398363",
    "Html": "\r\n<p>It works but it is way too permissive. The corresponding definitions are:</p>\r\n<p>&nbsp;</p>\r\n<pre>class Base {\n    public self;\n    constructor ();\n    public m();\n}\nclass Derived1 extends Base {\n    public m1();\n}\nclass Derived2 extends Base {\n    public m2();\n}\nfunction foo(d1: Derived1, d2: Derived2): void;\n</pre>\r\n<p>&nbsp;</p>\r\n<p>So self, m, m1 and m2 are typed as &quot;any&quot;. The &quot;because of self&quot; comment is misleading, it should be &quot;because of any&quot;. Try:</p>\r\n<p>&nbsp;</p>\r\n<pre>function foo(d1: Derived1, d2: Derived2) { <br>    d2.m().m3(); // works, although it should not <br>} </pre>\r\n<p>&nbsp;</p>\r\n<p>What I'm proposing is:</p>\r\n<pre>class Base {\n    public m() : _this;\n}\nclass Derived1 extends Base {\n    public m1() : _this;\n}\nclass Derived2 extends Base {\n    public m2() : _this;\n}\n</pre>\r\n",
    "PostedDate": "2012-10-08T01:21:22.193-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923308",
    "ThreadId": "398363",
    "Html": "<p>This is not the use case discussed in this thread: We are instead discussing the fact that the compiler does not understand/remembers the type of the object that is the 'this' pointer in the method calls. I know how to overcome the limitation, but it leads to ugly code. This is not what should the objective be in TypeScript, we have enough&nbsp;spaghetti&nbsp;in JavaScript no need to port those.</p>\r\n<p>As of your example, if I have two different subclasses if they implement the same interface at the end the interface will have one base method, one sub class method from first subclass and one sub method from the other class and basically making it unusable because it represents non existing objects (a mix of subclass 1 and subclass 2). This is not what is looked for in this case.</p>",
    "PostedDate": "2012-10-08T01:54:31.787-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923596",
    "ThreadId": "398363",
    "Html": "\r\n<p>Hello All,&nbsp;</p>\r\n<p>I Love this discussion and I was handling the problem myself on another topic (\r\n<a href=\"http://typescript.codeplex.com/discussions/398239#post923536\">here </a>) till someone pointed me to here.</p>\r\n<p>I read all the point of view and indeed there is this issue where the compiler does not understand the &quot;context&quot;.</p>\r\n<p>Btw, the problem is actually deeper. Improving the compiler to understand the context would not match the following case scenario:</p>\r\n<ul>\r\n<li>Module <strong>declaration</strong>&nbsp;to be used with an external, not written in TS, library\r\n</li></ul>\r\n<p>Indeed, consider this snippet ( Note the <strong>declare</strong>&nbsp;keyword )&nbsp;:&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>declare module lime {\n\t\n\t<span style=\"color:blue\">export</span> <span style=\"color:blue\">class</span> Node {\n\t\t<span style=\"color:blue\">private</span> customEvent_;\n\t\t<span style=\"color:blue\">private</span> eventHandlers_;\n\t\tinTree_: Boolean;\n\t\tsupportedRenderers: any[];\n<br></pre>\r\n<pre>\t\tsetAnchorPoint(x:number, y:number):Node;\n\t\tsetPosition(x:number, y:number): Node;\n\n\t\tsetOpacity(x:number): Node;\n\n\t\tappendChild(child:lime.Node, opt_pos?:number): Node;\n\t\trunAction(action:lime.animation.Animation):<span style=\"color:blue\">void</span>;\n\n\t}\n\t\n\t<span style=\"color:blue\">export</span> <span style=\"color:blue\">class</span> Scene <span style=\"color:blue\">extends</span> lime.Node {\n\t\tconstructor();\n\t\tgetScene(): Scene;\n\t\tmeasureContents(): <span style=\"color:blue\">void</span>;\n\t}\n}\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>This is, indeed, a snippet of a lime.d.ts file which aims to be a declaration file ready to be used with lime.js . As you probably already see the lime.Scene class extends lime.Node which contains a couple of methods which are there just for chainability.</p>\r\n<p>So, as already said a lot of times in this topic the following code will work:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">var</span> tmp = <span style=\"color:blue\">new</span> lime.Scene();\ntmp.getScene().setPosition(0,0);\n</pre>\r\n</div>\r\n<p>while the following won't:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">var</span> tmp = <span style=\"color:blue\">new</span> lime.Scene();\ntmp.setPosition(0,0).getScene();\n</pre>\r\n</div>\r\n<p>But, in this example, where the source code is just a declaration, there's no way for the compiler to understand what the method will return since the declaration file will contain only the class/method signature.</p>\r\n<p>So I'd like more the reserved keyword idea so that refactoring the code Above with _this as return type will fix the problem:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>declare module lime {\n\t\n\t<span style=\"color:blue\">export</span> <span style=\"color:blue\">class</span> Node {\n\t\t<span style=\"color:blue\">private</span> customEvent_;\n\t\t<span style=\"color:blue\">private</span> eventHandlers_;\n\t\tinTree_: Boolean;\n\t\tsupportedRenderers: any[];\n\n\t\tsetAnchorPoint(x:number, y:number): _this;\n\t\tsetPosition(x:number, y:number): _this;\n\n\t\tsetOpacity(x:number): _this;\n\n\t\tappendChild(child:lime.Node, opt_pos?:number): _this;\n\t\trunAction(action:lime.animation.Animation):<span style=\"color:blue\">void</span>;\n\n\t}\n\t\n\t<span style=\"color:blue\">export</span> <span style=\"color:blue\">class</span> Scene <span style=\"color:blue\">extends</span> lime.Node {\n\t\tconstructor();\n\t\tgetScene(): Scene;\n\t\tmeasureContents(): <span style=\"color:blue\">void</span>;\n\t}\n}\n</pre>\r\n</div>\r\n<p>Note that getScene method is not _this cause I don't want chainability to happen there.</p>\r\n",
    "PostedDate": "2012-10-08T11:12:02.817-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923626",
    "ThreadId": "398363",
    "Html": "<p>Using the _this modifier will imply that the compiler is able to perfectly understand the 'this' property in every possible call and I don't think this is working right now, at least I could not make it work in my tests.</p>\r\n<p>I think this code clearly demonstrates that:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">class</span> A {\r\n  <span style=\"color: blue;\">public</span> age: number = 0;\r\n  constructor(<span style=\"color: blue;\">public</span> name:string){\r\n\r\n  }\r\n  setAge(age: number) {\r\n    <span style=\"color: blue;\">this</span>.age = age;\r\n    <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span>;\r\n  }\r\n}\r\n\r\n<span style=\"color: blue;\">class</span> B <span style=\"color: blue;\">extends</span> A {\r\n  constructor(name: string, age: number, profession: string) {\r\n    <span style=\"color: blue;\">super</span>(name);\r\n    <span style=\"color: blue;\">this</span>.setAge(age).setProfession(profession);\r\n\r\n  }\r\n  setProfession(occ: string) {\r\n    <span style=\"color: blue;\">this</span>.occupation = occ;\r\n    <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span>;\r\n  }\r\n}\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>Annotations aside, we have 2 keywords that in other cases has been provden for the compiler to understand: 'return' (it is able to find the types of return, for example if you declare a function to return number but you write the implementation as return ''; it will complain) and 'this' - it is used to check if the method name after that is actually present so if you write in a method this.nonExisting it will complain again. All this means that the compiler simply has to be able to determine correclty the type of the returned value and it does. Partially. In the above code I did not have to say that the call to 'setAge' returns 'A', compiler was able to figure out that on its own, however because the method was called from a subclass it should have casted automatically to B, because this is how it works in javascript: it knows what 'this' is on method call. The compiler however seem to 'forgets' it. This need to be fixed clearly, otherwise no chainable apis in subclasses will work, with or without _this. To make it clear: no need for special '_this' modifier, the compiler understands that 'this' is returned, it simply mistakes what is 'this'.</p>",
    "PostedDate": "2012-10-08T12:07:14.233-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923670",
    "ThreadId": "398363",
    "Html": "<p>@<a class=\"UserProfileLink\" href=\"http://www.codeplex.com/site/users/view/vekexasia\">vekexasia</a></p>\r\n<p>We are on the same boat. I got the problem with my streams API (https://github.com/Sage/streamlinejs/blob/master/lib/streams/server/streams.md). The ReadableStream/WritableStream classes define chaining methods that get inherited from the other classes of the module.</p>\r\n<p>@pstj</p>\r\n<p>If you have a method that returns \"this\" in a base class, you cannot infer that this method will *always* return this because the method may be overriden in a derived class to return something else. Consider the following:</p>\r\n<p>\r\n<pre>class Base {\r\n  m() { return this; }; \r\n}\r\n\r\nclass Derived1 extends Base {\r\n  m1() { };\r\n}\r\n\r\nclass Derived2 extends Base {\r\n   m2() {};\r\n}\r\n\r\nclass Derived3 extends Derived1 {\r\n  m() { return new Derived2(); }\r\n}\r\n\r\nfunction foo(d1: Derived1, d2: Derived2) {\r\n  d1.m1();\r\n  d1.m().m1(); // rejected\r\n}</pre>\r\n</p>\r\n<p>The compiler is right when it rejects d1.m().m1() because d1 may be an instance of Derived3</p>\r\n<p>So this is not a bug nor a limitation of the compiler. The compiler is OK but you have to give him a little hint to handle this case. If we could write:</p>\r\n<pre>class Base {\r\n  m() : _this { return this; }; \r\n}\r\n</pre>\r\n<p>Then, in the example above, the compiler would reject the override of m() in Derived3 and it would accept d1.m().m1(). Precisely what we want for chaining!</p>",
    "PostedDate": "2012-10-08T13:28:01.51-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923716",
    "ThreadId": "398363",
    "Html": "\r\n<p>@<a href=\"http://www.codeplex.com/site/users/view/bjouhier\">bjouhier</a></p>\r\n<p>glad to know i'm not alone :).</p>\r\n<p>Btw i dislike your idea that the compiler would reject the override of any method marked for chainability. Consider, for example, a mock object that needs to be subclass of something and, obviously, needs to override almost any method. That restriction could\r\n cause a lot of problems.</p>\r\n<p>Best solution ever (IMHO) is just mark the method with _this so that the compiler will know that the method will return the current object instance type ( not necessary the same instance ).</p>\r\n<p>Consider the following:&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">class</span> LinkedList {\n    value:any;\n    nextNode: _this;\n    <span style=\"color:blue\">public</span> getNextNode(): _this {\n         <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>.nextNode;\n    }\n}\n\n<span style=\"color:green\">// Yeah i know it's a long name</span>\n<span style=\"color:blue\">interface</span> DoubleLinkedListDataInterface {\n       prev: DoubleLinkedList;\n       next: DoubleLinkedList;\n}\n\n<span style=\"color:blue\">class</span> DoubleLinkedList <span style=\"color:blue\">extends</span> LinkedList{\n    \n    nodeData: DoubleLinkedListDataInterface;\n\n    <span style=\"color:blue\">public</span> getPrevNode(): _this {\n          <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>.nodeData.prev;\n    }\n\n    <span style=\"color:blue\">public</span> getNextNode(): _this {\n          <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>.nodeData.next;\n    }\n\n   \n}\n<span style=\"color:blue\">var</span> myList = <span style=\"color:blue\">new</span> DoubleLinkedList(); myList.getNextNode().getPrevNode(); <span style=\"color:green\">// this should work.</span></pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>Also notice:</p>\r\n<ul>\r\n<li>the _this keywrd as field type inside LinkedList =&gt; could come handy for another subclass which actually uses that field.\r\n</li><li>the override of the getPrevNode() </li></ul>\r\n",
    "PostedDate": "2012-10-08T15:22:33.793-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923822",
    "ThreadId": "398363",
    "Html": "<blockquote style=\"border: solid .1em #ccc; font-style: italic; margin: .25em 1em 0 1em; padding: 0 .25em 0 .25em;\"><strong>bjouhier wrote:</strong><br />\r\n<p>@<a href=\"http://www.codeplex.com/site/users/view/vekexasia\">vekexasia</a></p>\r\n<p>We are on the same boat. I got the problem with my streams API (https://github.com/Sage/streamlinejs/blob/master/lib/streams/server/streams.md). The ReadableStream/WritableStream classes define chaining methods that get inherited from the other classes of  the module.</p>\r\n<p>@pstj</p>\r\n<p>If you have a method that returns \"this\" in a base class, you cannot infer that this method will *always* return this because the method may be overriden in a derived class to return something else. Consider the following:</p>\r\n<p>&nbsp;</p>\r\n<pre>class Base {\r\n  m() { return this; }; \r\n}\r\n\r\nclass Derived1 extends Base {\r\n  m1() { };\r\n}\r\n\r\nclass Derived2 extends Base {\r\n   m2() {};\r\n}\r\n\r\nclass Derived3 extends Derived1 {\r\n  m() { return new Derived2(); }\r\n}\r\n\r\nfunction foo(d1: Derived1, d2: Derived2) {\r\n  d1.m1();\r\n  d1.m().m1(); // rejected\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>The compiler is right when it rejects d1.m().m1() because d1 may be an instance of Derived3</p>\r\n<p>So this is not a bug nor a limitation of the compiler. The compiler is OK but you have to give him a little hint to handle this case. If we could write:</p>\r\n<pre>class Base {\r\n  m() : _this { return this; }; \r\n}\r\n</pre>\r\n<p>Then, in the example above, the compiler would reject the override of m() in Derived3 and it would accept d1.m().m1(). Precisely what we want for chaining!</p>\r\n</blockquote>\r\n<p>Cannot agree with this. The compiler makes AST and is walking it (at least this is how is should work to be able to make all its checks). It is pretty obvious when a method is returning THIS and when a method is returning new Instance and it is also pretty clear what is the type of the instance it is returning, this is so natural I cannot believe we are still arguing about it!</p>\r\n<p>last example and I am giving up:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">class</span> A {\r\n  m1() {\r\n    <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span>;\r\n  }\r\n}\r\n\r\n<span style=\"color: blue;\">class</span> B <span style=\"color: blue;\">extends</span> A {\r\n  m2() {\r\n    <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span>;\r\n  }\r\n}\r\n\r\n<span style=\"color: blue;\">class</span> SomethingElse {\r\n\r\n}\r\n\r\n<span style=\"color: blue;\">class</span> C <span style=\"color: blue;\">extends</span> B {\r\n  m3() {\r\n    <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">new</span> SomethingElse();\r\n  }\r\n}\r\n\r\n<span style=\"color: blue;\">var</span> instance = <span style=\"color: blue;\">new</span> C();\r\ninstance.m1().m2().m3().m1();\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>Here is how a compiler will work normally (and should work):</p>\r\n<p>(starting from the initiation, I skip the code above but it is okay, because JS works tops down anyway, one can never make it read later lines first):</p>\r\n<p>&lt;Compiler at work - fiction by pstj&gt;</p>\r\n<p>I have an instance, what it is instance of? oh, okay it is a C, cool.</p>\r\n<p>m1() -&gt; a method call, cool, lets see if I have it defined on the class... nope, too bad, lets look at the prototype chain (aka the parent class)... next in chain is B, but it does not have it defined there... should check if it has something in the prototype chain... next in chain is A, lets see it I have it defined in A... Oh YEAH! I have it, lets see what does this method do.. hum, returns 'THIS', now what is this... lets look back to see what instance called it.. oh it is a C, great to the return is a C instance. Fine by me.., so the result of the call is instance of C, in fact it is the same instance!!! (this cannot be changed inside the method call, so it is safe to assume that is THIS is returned it is still the instance that called it.)</p>\r\n<p>m2() -&gt; hm... another method call, who is calling it - ah yeas, i remember, it is the C instance, lets see if I have it defined on C... no... ah, bad luck, check the parent... what is the parent of C, oh yeah, its B, check if B has it defined... yes it does, cool, what does it return... it return THIS, wohow, so my return type will be the calling instance, look back what it was - a C, so the return is instance of C!</p>\r\n<p>m3() -&gt; Again method call, a bit of a boring program... lets see if C has it defined.. ah it does! how great is that: now what is the return type.. hum.. a new instance of another class... okay then, mark a new instance of that class and remember that it is the value that is returned. great now the value I am working with is instance of SomethingElse (stupid name huh?)</p>\r\n<p>m1() -&gt; Ha, another method call, someone gotta be kidding me with those chained calls. Lets see do I have m1 defined on SomethingElse... nope. Does it have a parent. Nope. Ha! RAISE AN ERROR! Ha! How smart of a compiler I am....</p>\r\n<p>&nbsp;</p>\r\n<p>So this is the tale of the brave compiler that knows what it is doing. Everything else with the '_this' is just plain fairy tales of the developer that went doing the compiler's job.&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>Disclaimer: The&nbsp;narrative is only possible when one is compiling a whole program or when the class pattern in TypeScript is not abused. Why? Because of the dynamic type of the language one can go and simply override the method and lets say the instance is called by a function, which can also be called in another file:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">function</span> test() {\r\n  (<span style=\"color: blue;\">new</span> C()).m1().m2().m3().m1();\r\n}\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>And lets say in yet another file I have:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>A.prototype.m1 = <span style=\"color: blue;\">function</span>() { <span style=\"color: blue;\">return</span> <span style=\"color: #a31515;\">'ha!'</span>};\r\n</pre>\r\n</div>\r\n<p>Now what will happen depends&nbsp;entirely on the order of the files. If one compiles only the the code that has the definitions and not the prototype method override, of course this will lead to errors. But let me ask this: even if you annotate that the method is returning _this and then again one goes and overrides the prototype \"manually\" and THEN the instance is created and methods chained, will the _this annotation help? I bet it will not. marking _this is simply a contract the developer makes with himself, not compiler directive. This is why it is pointless IMO, as long as the compiler can figure out the instance type of 'this' and it can, it is just a small bug IMO and it should be fixed. And of source if the compiler is compiling the whole application (i.e. --out) it should be able to figure out that m1 on A was overriden and return to the AST representation of it and override it and continue to the next line and from then on it will know that m1 returns). This &nbsp;is how one can be sure, compiling the whole application together. Something that most JavaScript developers rarely use or even know.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-10-09T00:14:15.847-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923835",
    "ThreadId": "398363",
    "Html": "<p>@<a class=\"UserProfileLink\" href=\"http://www.codeplex.com/site/users/view/pstj\">pstj</a></p>\r\n<p>I agree with you mainly for actual code. So that if the class is actually built in ts your ideas are ok. The problem comes when you want to create a declaration file where the implementation does not exists.</p>\r\n<p>In this scenario ( see my previous post ) the compiler needs to get an help from the developer itself. Don't you agree?</p>",
    "PostedDate": "2012-10-09T00:51:14.62-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "924051",
    "ThreadId": "398363",
    "Html": "<p>Hum... yes it is now much more clear what you might need this for. In that case the compiler cannot determine the correct type indeed.</p>\r\n<p>So to clarify: _this might indeed be useful, but at least the compiler should be able to 'get it right' from actual implementation if provided.</p>\r\n<p>Now that this is settled should someone file a bug/feature request?</p>",
    "PostedDate": "2012-10-09T08:03:53.583-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "924255",
    "ThreadId": "398363",
    "Html": "<p>@pstj<br /><br />Sorry but I continue to disagree with you. More precisely:<br /><br />Your analysis of your example is right (did not read it through but I got the gist).<br /><br />Your analysis of my example would be right if I had written the last lines as:<br /><br />\r\n<pre>var d1 = new Derived1(); \r\nd1.m1();\r\nd1.m().m1(); // rejected\r\n</pre>\r\nBut I wrote something different;<br /><br />\r\n<pre>function foo(d1: Derived1, d2: Derived2) {\r\n  d1.m1();\r\n  d1.m().m1(); // rejected\r\n}\r\n</pre>\r\nThe foo function may be called (from who knows where) as:<br /><br />\r\n<pre>foo(new Derived3(), new Derived2());\r\n</pre>\r\nThis is perfectly valid because Derived3 extends Derived1<br /><br />Then d1 is a Derived3 and the compiler is right to have rejected d1.m().m1() because d1.m() is a Derived2 !!!<br /><br />When the compiler encounters a declaration like var s: string; it knows that s is *exactly* a string because string is a non-derivable type.<br /><br />When it encounters a declaration like var d1 : Derived1, it only knows that d1 is an instance of Derived1 or of one of its subclasses. So it should not make inferences that assume that d1 is *exactly* a Derived1.<br /><br />And if you push the analysis further, you will see that, if we introduce the _this type annotation on Base.m(), then the compiler has not much choice but reject the Derived3.m override that returns a Derived2 (Derived2 and Derived3 are different types).<br /><br /></p>",
    "PostedDate": "2012-10-09T13:10:02.86-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "924494",
    "ThreadId": "398363",
    "Html": "<p>What you seem to not understand by not reading my explanation is that the compiler should threat method(): _this {} and method(): {return this} exactly the same.Anything beyond that is just waste of time that we argue here. Right now neither your preferred scenario nor mine work.</p>\r\n<p>Mine is the correct behavior if the compiler is ever to pretend to understand a bit of class inheritance. Yours is not correct because you assume that the compiler does not know how (with what params) foo is called and if the compiler does not know (i.e. the code that invokes foo is not compiled together with the file providing foo) then the types do not matter at all. If the compiler is compiling the file invoking foo, it should be able to SEE that Direved3 m() method returns Derived2 and that in its inheritance chain is does not have m1(). Simple as that.</p>\r\n<p>People should stop thinking of JS programs as independent pieces. This is what brought us to what we have today - a million libraries that all have different interfaces and do not work together and this is why it is so common to see in one and same page jquery (at least 2 versions of it of course), prototype and mootools.</p>\r\n<p>If you think of all your code as 'one whole' and compile everything together the compiler will know exactly each type at each invocation. Right now even having all the code it cannot figure out what is what. Until that happens with or without _this special magical word, it is in internal alpha and should not be considered seriously by any one.</p>",
    "PostedDate": "2012-10-09T23:16:11.55-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "924514",
    "ThreadId": "398363",
    "Html": "<p>You claim that the compiler should treat method(): _this {} and method():{ return this; } exactly the same BUT IT DOES NOT. Either it is a bug, or it is intentional. People from the compiler team should know. Can anyone from the MS compiler team comment?</p>\r\n<p>You claim that this is a deficiency in the current compiler because the compiler should be able to know exactly each type at each invocation when compiling the source as a whole. This is wrong. Consider</p>\r\n<pre>class Base {}; class Derived1 extends Base {}; class Derived2 extends Base {}<br />function foo(b: Base) { }\r\nMath.random() % 2 ? foo(new Derived1()) : foo(new Derived2());\r\n</pre>\r\n<p>What is the exact type of b inside foo?</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-10-10T00:20:08.023-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "925645",
    "ThreadId": "398363",
    "Html": "<p>You are right, I have researched this a little bit further (also asked about types of classes and method's type / params type in closure compiler forums). Turns out a subclass should be same or more permissive than the superclass. So if the return type of super class method is Base it is okay according to type system.</p>\r\n<p>So the fact that it is possible in JavaScript to chain methods mixed from sub and super classes is well known but not possible from type system's perspective.</p>\r\n<p>Having 'return this' is same as having method(): Base, then it is only natural that you would expect Base...</p>\r\n<p>At this point I think that it is not clear how to express the possibilities of JavaScript in types when users want to use all javascript. In closure land it is not possible. I think it will never be possible in TypeScritp either.</p>\r\n<p>Even if we mark the method with _this the example you have provided is defeating the type system because it simply cannot know at compile time what type will be submitted. So if one wants type check simply does not use code like this.</p>",
    "PostedDate": "2012-10-11T23:53:48.46-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "926124",
    "ThreadId": "398363",
    "Html": "<p>Yes, subclass should be the same or more permissive than the superclass. This is what B. Meyer phrases as \"subclassing is subcontracting\" (when you subcontract you are supposed to fullfil at least all the terms of the original contract - rarely happens with building contractors :-( ).</p>\r\n<p>This is also why returning new Derived2() in Derived3.m() in my previous example should be rejected by the compiler (because m() is annotated as returning _this).</p>\r\n<p>I don't understand your last sentence. If we add a _this annotation to m() in the base class, we tell the compiler that m() and all its overrides (per the above rule) return the same type as this. Then the compiler can infer that d1.m() has the same type as d1 and can continue its type checking along the chain, and for example, find out that d1.m().m1() is ok but d1.m().m2() is not.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-10-13T04:19:17.247-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "926172",
    "ThreadId": "398363",
    "Html": "<p>True. But then you provide an example in which the run time determines the type of the param</p>\r\n<p>In that case I belive no compiler for JS currently existing can determine the type of the result of m(), unless it is casted as it is now (to the base type) In which case no methods defined on the subclass will be allowed</p>\r\n<p>example:\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">class</span> Base { m(): _this {}}\r\n<span style=\"color: blue;\">class</span> A <span style=\"color: blue;\">extends</span> Base {ma(): _this{}}\r\n<span style=\"color: blue;\">class</span> B <span style=\"color: blue;\">extends</span> Base {mb(): _this{}}\r\n\r\n<span style=\"color: blue;\">var</span> instance = (RANDOM?<span style=\"color: blue;\">new</span> A():<span style=\"color: blue;\">new</span> B());\r\ninstance.m().mb();\r\n\r\n</pre>\r\n</div>\r\nIn this example what should the compiler say about the mb() part? I think the most sane thing is to say that _this is the base type (it is doing that right now so no need for _this annotation). What do you think?</p>",
    "PostedDate": "2012-10-13T10:18:18.51-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "926177",
    "ThreadId": "398363",
    "Html": "<p>In this example the compiler should infer that instance is a Base (common ancestor of A and B). Then it can infer that instance.m() is a Base (which means that it could also be a A or B but we don't know which one). And then it rejects the mb() method because Base does not define it. This is not a problem, rather a feature.</p>\r\n<p>What's nice on the other hand is that chaining APIs get correctly type checked. If you know that a is an A, the compiler accepts a.ma().m().ma() but rejects a.ma().m().mb(). And this works even if A has subclasses like A1, A2, etc. and if a is not exactly an A but an A1 or A2 (and we don't really know which one at the point where a is defined).</p>",
    "PostedDate": "2012-10-13T10:45:25.803-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "926282",
    "ThreadId": "398363",
    "Html": "<p>You can solve this now without compiler support by giving it a little hint:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">class</span> Base {\r\n  m() { <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span> }; <span style=\"color: green;\">// returns this for chaining</span>\r\n}\r\n\r\n<span style=\"color: blue;\">class</span> Derived1 extends Base {\r\n  m: () =&gt; Derived1;\r\n  m1() { <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span> } <span style=\"color: green;\">// returns this for chaining</span>\r\n}\r\n\r\n<span style=\"color: blue;\">class</span> Derived2 extends Base {\r\n  m: () =&gt; Derived2;\r\n  m2() { <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span> } <span style=\"color: green;\">// returns this for chaining</span>\r\n}\r\n\r\nfunction foo(d1: Derived1, d2: Derived2) {\r\n  d1.m1().m1().m(); <span style=\"color: green;\">// works</span>\r\n  d2.m2().m2().m(); <span style=\"color: green;\">// works</span>\r\n  d1.m().m1(); <span style=\"color: green;\">// works</span>\r\n  d2.m().m2(); <span style=\"color: green;\">// works</span>\r\n}\r\n</pre>\r\n</div>\r\nIt is little tedious, but it works, and doesn't require redefining m().</p>",
    "PostedDate": "2012-10-13T21:18:24.76-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "926320",
    "ThreadId": "398363",
    "Html": "<p>@ian320</p>\r\n<p>Not ideal (you have to redeclare all chaining methods in all subclasses) but will do for now. Thanks for the tip.</p>",
    "PostedDate": "2012-10-14T04:21:28.443-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1261565",
    "ThreadId": "398363",
    "Html": "I've found a solution which may be more palatable for some. It using a generic base parameter similar to CRTP in C-PlusPlus. The trick to is to instantiate the instance using an interface parameter which self-extends the hierarchy. You then deal with instances of the interface in your code, rather than the concrete types.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> First&lt;Base&gt;\n{\n    one(): Base\n    {\n        <span style=\"color:Blue;\">return</span> &lt;Base&gt;&lt;<span style=\"color:Blue;\">any</span>&gt;<span style=\"color:Blue;\">this</span>;\n    }\n}\n\n\n<span style=\"color:Blue;\">class</span> Second&lt;Base&gt; <span style=\"color:Blue;\">extends</span> First&lt;Base&gt;\n{\n    two(): Base\n    {\n        <span style=\"color:Blue;\">return</span> &lt;Base&gt;&lt;<span style=\"color:Blue;\">any</span>&gt;<span style=\"color:Blue;\">this</span>;\n    }\n}\n\n\n<span style=\"color:Blue;\">interface</span> ISecond <span style=\"color:Blue;\">extends</span> Second&lt;ISecond&gt; \n{ \n}\n\n\n<span style=\"color:Blue;\">var</span> second: ISecond = <span style=\"color:Blue;\">new</span> Second&lt;ISecond&gt;();\n\n<span style=\"color:Blue;\">var</span> two = second.one().two();\r\n</pre></div>",
    "PostedDate": "2014-07-01T07:03:30.923-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]