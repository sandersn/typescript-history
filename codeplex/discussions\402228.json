[
  {
    "Id": "937821",
    "ThreadId": "402228",
    "Html": "\r\n<p>Creating strongly typed events for jQuery style bind() events is tough because of the way you have to pass a list of named events you want to bind to. &nbsp;Since any number of events can be bound to in a single bind() call there's really no great way of\r\n strongly typing these events beyond just typing the actual params passed to bind(). &nbsp;Furthermore, there's an even bigger issue with bind() style events in that there's no way of discovering (via tooling) what events a class actually supports. &nbsp;Basically,\r\n bind() style events have major issues when it comes to a strongly typed language like TypeScript.</p>\r\n<p>I thought I'd share with the community a pattern that I've been using for my TypeScript classes which allows for exposing a strongly typed set of events from a class:</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:green\">// Base IEvent interface and implementation</span>\n\n<span style=\"color:blue\">interface</span> IEvent {\n    add(listener: () =&gt; <span style=\"color:blue\">void</span>): <span style=\"color:blue\">void</span>;\n    remove(listener: () =&gt; <span style=\"color:blue\">void</span> ): <span style=\"color:blue\">void</span>;\n    trigger(...a:any[]): <span style=\"color:blue\">void</span>;\n}\n\n<span style=\"color:blue\">class</span> TypedEvent <span style=\"color:blue\">implements</span> IEvent {\n    <span style=\"color:green\">// Private member vars</span>\n\t<span style=\"color:blue\">private</span> _listeners: any[] = [];\n\n\t<span style=\"color:blue\">public</span> add (listener: () =&gt; <span style=\"color:blue\">void</span>): <span style=\"color:blue\">void</span> {\n\t\t<span style=\"color:green\">/// &lt;summary&gt;Registers a new listener for the event.&lt;/summary&gt;</span>\n\t\t<span style=\"color:green\">/// &lt;param name=&quot;listener&quot;&gt;The callback function to register.&lt;/param&gt;</span>\n\t\t<span style=\"color:blue\">this</span>._listeners.push(listener);\n\t}\n\t<span style=\"color:blue\">public</span> remove (listener?: () =&gt; <span style=\"color:blue\">void</span>): <span style=\"color:blue\">void</span> {\n\t\t<span style=\"color:green\">/// &lt;summary&gt;Unregisters a listener from the event.&lt;/summary&gt;</span>\n\t\t<span style=\"color:green\">/// &lt;param name=&quot;listener&quot;&gt;The callback function that was registered. If missing then all listeners will be removed.&lt;/param&gt;</span>\n        <span style=\"color:blue\">if</span> (<span style=\"color:blue\">typeof</span> listener === <span style=\"color:#a31515\">'function'</span>) {\n\t\t    <span style=\"color:blue\">for</span> (<span style=\"color:blue\">var</span> i = 0, l = <span style=\"color:blue\">this</span>._listeners.length; i &lt; l; l&#43;&#43;) {\n\t\t\t    <span style=\"color:blue\">if</span> (<span style=\"color:blue\">this</span>._listeners[i] === listener) {\n\t\t\t\t    <span style=\"color:blue\">this</span>._listeners.splice(i, 1);\n\t\t\t\t    <span style=\"color:blue\">break</span>;\n\t\t\t    }\t\n\t\t    }\n        } <span style=\"color:blue\">else</span> {\n            <span style=\"color:blue\">this</span>._listeners = [];\n        }\n    }\n\n    <span style=\"color:blue\">public</span> trigger (...a: any[]): <span style=\"color:blue\">void</span> {\n\t\t<span style=\"color:green\">/// &lt;summary&gt;Invokes all of the listeners for this event.&lt;/summary&gt;</span>\n\t\t<span style=\"color:green\">/// &lt;param name=&quot;args&quot;&gt;Optional set of arguments to pass to listners.&lt;/param&gt;</span>\n\t\t<span style=\"color:blue\">var</span> context = {};\n\t\t<span style=\"color:blue\">var</span> listeners = <span style=\"color:blue\">this</span>._listeners.slice(0);\n\t\t<span style=\"color:blue\">for</span>(<span style=\"color:blue\">var</span> i = 0, l = listeners.length; i &lt; l; i&#43;&#43;) {\n\t\t    listeners[i].apply(context, a || []);\n\t\t}\n\t}\n}\n\t\n<span style=\"color:green\">// Exposing events</span>\n<span style=\"color:blue\">interface</span> IMessageEvent <span style=\"color:blue\">extends</span> IEvent {\n    add(listener: (message: string) =&gt; <span style=\"color:blue\">void</span>): <span style=\"color:blue\">void</span>;\n    remove(listener: (message: string) =&gt; <span style=\"color:blue\">void</span> ): <span style=\"color:blue\">void</span>;\n    trigger(message: string): <span style=\"color:blue\">void</span>;\n}\n\n<span style=\"color:blue\">class</span> Foo {\n\t<span style=\"color:green\">// Events</span>\n\t<span style=\"color:blue\">public</span> onMessage: IMessageEvent = <span style=\"color:blue\">new</span> TypedEvent();\n\t\n\t<span style=\"color:green\">// Methods</span>\n\t<span style=\"color:blue\">public</span> bar(): <span style=\"color:blue\">void</span> {\n\t\t<span style=\"color:blue\">this</span>.onMessage.trigger(<span style=\"color:#a31515\">'event fired'</span>);\n\t}\n}\n\n<span style=\"color:green\">// Consuming events</span>\n<span style=\"color:blue\">var</span> foo = <span style=\"color:blue\">new</span> Foo();\nfoo.onMessage.add((message) =&gt; {\n\talert(message);\n});\nfoo.bar();\n\n</pre>\r\n</div>\r\n<p></p>\r\n<p>If you run the code snippet above in the playground you should see an alert() pop saying 'event fired'. &nbsp;This pattern uses interfaces and takes advantage of TypeScripts ability to extend an inherited methods signature. &nbsp;</p>\r\n<p>To declare new events you simply define a new interface that extends IEvent and strongly types the arguments for add(), remove(), and trigger(). &nbsp;Your class can then expose an instance of this event as a property that casts a new instance of TypedEvent()\r\n to your interface. Consumers can then listen for events by calling add in pretty much the same way you would have called bind() before. &nbsp;Now you just have a separate property for each event supported by the class so no more discover issue.</p>\r\n<p>At compile time all of these interfaces boil out so there's really no significant overhead added over the top of how bind() events work and in general should be just as performant. &nbsp;The tooling improvement, however, is a massive upgrade over bind()\r\n style events.</p>\r\n",
    "PostedDate": "2012-11-07T02:52:47.237-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "952974",
    "ThreadId": "402228",
    "Html": "\r\n<p>Wanted to thank you for posting this. Exactly what I was looking for. Hopefully in the future, TypeScript will support more native events like C# does.</p>\r\n",
    "PostedDate": "2012-12-07T07:30:42.203-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "953057",
    "ThreadId": "402228",
    "Html": "\r\n<p>If you are looking for DOM-less events, you might look into a simple little library that I wrote a month or two ago. You can find it on GitHub as&nbsp;<a href=\"https://github.com/jmvrbanac/EventDispatcher-ts\">EventDispatcher-ts</a>. It was inspired by my work\r\n with ActionScript 3. Personally, I've always liked the descriptiveness of naming such as &quot;addEventListener&quot; or &quot;dispatchEvent.&quot; Anyhow, feel free to fork, modify, and send pull requests. I'm always open to improvements.</p>\r\n",
    "PostedDate": "2012-12-07T10:20:39.117-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "953208",
    "ThreadId": "402228",
    "Html": "\r\n<p>Thanks jdmichal, we wanted simple C# style events that could be strongly typed and this is the simplest way of achieving that we've found.&nbsp;</p>\r\n<p>jmvrbanaca, I looked at EventDispatcher-ts and I think if you're looking for something that supports &quot;named&quot; events it's a pretty good option. &nbsp;One suggestion I'd make though is that instead of making _listeners an array you have to loop over you should\r\n use an object that's indexed by type as your operations will be more&nbsp;efficient. &nbsp;I hope you don't mind but I made a pass at updating your code to reflect this. I also made things a little more strongly typed:</p>\r\n<p>&nbsp;</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">export</span> <span style=\"color:blue\">class</span> Event {\r\n\t<span style=\"color:blue\">private</span> _type:string;\r\n\t<span style=\"color:blue\">private</span> _target;\r\n\r\n\tconstructor(type:string, targetObj:any) {\r\n\t\t<span style=\"color:blue\">this</span>._type = type;\r\n\t\t<span style=\"color:blue\">this</span>._target = targetObj;\r\n\t}\r\n\r\n\t<span style=\"color:blue\">public</span> getTarget():any {\r\n\t\t<span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>._target;\r\n\t}\r\n\r\n\t<span style=\"color:blue\">public</span> getType():string {\r\n\t\t<span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>._type;\r\n\t}\r\n}\r\n<span style=\"color:blue\">interface</span> EventListener {\r\n\t(evt: Event): <span style=\"color:blue\">void</span>;\r\n}\r\n\r\n<span style=\"color:blue\">export</span> <span style=\"color:blue\">class</span> EventDispatcher {\r\n\t<span style=\"color:blue\">private</span> _events: { [x:string]: EventListener[]; } = {};\r\n\r\n\t<span style=\"color:blue\">public</span> hasEventListener(type:string, listener: EventListener): bool {\r\n\t\t<span style=\"color:blue\">var</span> listeners = <span style=\"color:blue\">this</span>._events[type];\r\n\t\t<span style=\"color:blue\">if</span> (listeners) {\r\n\t\t\t<span style=\"color:blue\">for</span> (<span style=\"color:blue\">var</span> i = 0, l = listeners.length; i &lt; l; i++) {\r\n\t\t\t\t<span style=\"color:blue\">if</span> (listeners[i] === listener) {\r\n\t\t\t\t\t<span style=\"color:blue\">return</span> <span style=\"color:blue\">true</span>;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t<span style=\"color:blue\">return</span> <span style=\"color:blue\">false</span>;\r\n\t}\r\n\r\n\t<span style=\"color:blue\">public</span> addEventListener (type: string, listener: EventListener): <span style=\"color:blue\">void</span> {\r\n\t\t<span style=\"color:green\">// Not sure you absolutely need this test</span>\r\n\t\t<span style=\"color:blue\">if</span> (!<span style=\"color:blue\">this</span>.hasEventListener(type, listener)) {\r\n\t\t\t<span style=\"color:blue\">var</span> listeners = <span style=\"color:blue\">this</span>._events[type];\r\n\t\t\t<span style=\"color:blue\">if</span> (!listeners) {\r\n\t\t\t\tlisteners = <span style=\"color:blue\">this</span>._events[type] = [];\r\n\t\t\t}\r\n\t\t\tlisteners.push(listener);\r\n\t\t}\r\n\t}\r\n\r\n\t<span style=\"color:blue\">public</span> removeEventListener (type: string, listener: EventListener): <span style=\"color:blue\">void</span> {\r\n\t\t<span style=\"color:blue\">var</span> listeners = <span style=\"color:blue\">this</span>._events[type];\r\n\t\t<span style=\"color:blue\">if</span> (listeners) {\r\n\t\t\t<span style=\"color:blue\">for</span> (<span style=\"color:blue\">var</span> i = 0, l = listeners.length; i &lt; l; i++) {\r\n\t\t\t\t<span style=\"color:blue\">if</span> (listeners[i] === listener) {\r\n\t\t\t\t\tlisteners.splice(i, 1);\r\n\t\t\t\t\t<span style=\"color:blue\">break</span>;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t<span style=\"color:blue\">public</span> dispatchEvent (evt: Event, thisArg = {}): <span style=\"color:blue\">void</span> {\r\n\t\t<span style=\"color:blue\">var</span> listeners = <span style=\"color:blue\">this</span>._events[evt.getType()];\r\n\t\t<span style=\"color:blue\">if</span> (listeners) {\r\n\t\t\t<span style=\"color:blue\">for</span> (<span style=\"color:blue\">var</span> i = 0, l = listeners.length; i &lt; l; i++) {\r\n\t\t\t\tlisteners[i].call(thisArg, evt);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n</pre>\r\n</div>\r\n&nbsp; &nbsp;\r\n<p></p>\r\n",
    "PostedDate": "2012-12-07T19:00:26.623-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "953390",
    "ThreadId": "402228",
    "Html": "\r\n<p>Woops! I misunderstood. You actually want types to denote events like in C#. Got it... Thanks for the input though. I'll look into making the modifications when I go on vacation in a week or so.&nbsp;</p>\r\n<p>As a side note, does anyone know the performance ramifications of using object type lookup vs a&nbsp;primitive&nbsp;string lookup in JavaScript? I know that in JavaScript you can have serious performance reductions when you start using the object variants of primitives,\r\n but I have never tried to test the&nbsp;performance&nbsp;of object type lookups in JS.&nbsp;</p>\r\n",
    "PostedDate": "2012-12-08T14:43:04.1-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "953891",
    "ThreadId": "402228",
    "Html": "\r\n<p>I went for a reverse map enum/proxy jquery approach</p>\r\n<p>edit: added $.proxy for this</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>module com.company.app.events {\n    \n    <span style=\"color:blue\">export</span> <span style=\"color:blue\">enum</span> EventType {\n        ApplicationReady\n    }\n    \n    <span style=\"color:blue\">export</span> <span style=\"color:blue\">class</span> Event {\n        <span style=\"color:blue\">private</span> _eventType: EventType;\n        Type(): EventType { <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>._eventType; }\n\n        <span style=\"color:blue\">private</span> _caller: any;\n        Caller(): any { <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>._caller; }\n        SetCaller(caller: any) { <span style=\"color:blue\">this</span>._caller = caller; }\n\n        <span style=\"color:blue\">private</span> _userInfo: any;\n        UserInfo(): any { <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>._userInfo; }\n        SetUserInfo(info: any) { <span style=\"color:blue\">this</span>._userInfo = info; }\n\n        constructor (eventType: EventType, userInfo?: any) {\n            <span style=\"color:blue\">this</span>._eventType = eventType;\n            <span style=\"color:blue\">this</span>._userInfo = userInfo;\n        }\n    }    \n\n    <span style=\"color:blue\">export</span> <span style=\"color:blue\">class</span> EventController {\n        constructor() {                    \n            <span style=\"color:green\">// Provide a global accessor a la singleton</span>\n            window[<span style=\"color:#a31515\">'company'</span>] = window[<span style=\"color:#a31515\">'company'</span>] || {};\n            window[<span style=\"color:#a31515\">'company'</span>][<span style=\"color:#a31515\">'eventcontroller'</span>] = self;\n        }\n        \n        Subscribe(event:EventType, fn:any, proxy: any) { \n\t    <span style=\"color:blue\">var</span> eventName:string = EventType[<span style=\"color:#a31515\">'_map'</span>][event];\n\t    $(<span style=\"color:blue\">this</span>).bind(eventName, jQuery.proxy(fn, proxy));\n\t}\n \n        Post(eventType:EventType, caller?:any, userInfo?:any) {\n            <span style=\"color:blue\">var</span> eventName:string = EventType[<span style=\"color:#a31515\">'_map'</span>][eventType];\n            <span style=\"color:blue\">var</span> event:Event = <span style=\"color:blue\">new</span> Event(eventType);\n            event.SetCaller(caller);\n            event.SetUserInfo(userInfo);\n            $(<span style=\"color:blue\">this</span>).triggerHandler(eventName, [event]);\n        }\n\n        <span style=\"color:blue\">static</span> DefaultEventController(): EventController {\n            <span style=\"color:blue\">return</span> &lt;EventController&gt;window[<span style=\"color:#a31515\">'company'</span>][<span style=\"color:#a31515\">'eventcontroller'</span>];\n        }\n    }\n}\n\n<span style=\"color:green\">// Create</span>\n<span style=\"color:blue\">var</span> eventController = <span style=\"color:blue\">new</span> Events.EventController();\n\n<span style=\"color:green\">// Subscribe</span>\neventController.Subscribe(Events.EventType.ApplicationReady, <span style=\"color:blue\">function</span>(evt, event:Event) {\n    console.log(<span style=\"color:#a31515\">'Application ready! Caller is '</span> &#43; event.Caller() &#43; <span style=\"color:#a31515\">' userInfo is '</span> &#43;  event.UserInfo());\n}, <span style=\"color:blue\">this</span>);\n\n<span style=\"color:green\">// Post</span>\neventController.Post(Events.EventType.ApplicationReady, <span style=\"color:blue\">this</span>);   \n\n</pre>\r\n</div>\r\n<p></p>\r\n",
    "PostedDate": "2012-12-10T05:06:55.033-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "956143",
    "ThreadId": "402228",
    "Html": "\r\n<p>I ended up using&nbsp;<a href=\"http://www.codeplex.com/site/users/view/ickman\">ickman</a>'s code thanks!</p>\r\n<p>I added this event to pass data out.</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">interface</span> IDataChangeEvent extends IEvent {\r\n    add(listener: (data: any) =&gt; <span style=\"color:blue\">void</span>): <span style=\"color:blue\">void</span>;\r\n    remove(listener: (data: any) =&gt; <span style=\"color:blue\">void</span> ): <span style=\"color:blue\">void</span>;\r\n    trigger(data: any): <span style=\"color:blue\">void</span>;\r\n}\r\n</pre>\r\n</div>\r\n<p></p>\r\n<p>It's&nbsp;working&nbsp;well! &nbsp;Nice and simple.</p>\r\n",
    "PostedDate": "2012-12-14T07:40:48.997-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "956294",
    "ThreadId": "402228",
    "Html": "\r\n<p>Thanks Jon... This systems been working pretty well for us too.&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>-steve</p>\r\n",
    "PostedDate": "2012-12-14T13:41:44.01-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "956296",
    "ThreadId": "402228",
    "Html": "\r\n<p>I should add a note for others that might use this approach. &nbsp;You'll notice there's a remove() method for unbinding events and that method works but there's a subtle caveat. &nbsp;If you plan to remove an added listener make sure the thing you added\r\n is a 'var' and what you remove is the SAME 'var' otherwise it won't find your handler. &nbsp;This is because I use &quot;===&quot; to compare listeners. Below is a revised example of that:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:green\">// Consuming events</span>\n<span style=\"color:blue\">var</span> foo = <span style=\"color:blue\">new</span> Foo();\n<span style=\"color:blue\">var</span> handler = () =&gt; {\n\talert(message);\n};\nfoo.onMessage.add(handler);\nfoo.bar();\nfoo.onMessage.remove(handler);\n\n</pre>\r\n</div>\r\n",
    "PostedDate": "2012-12-14T13:47:26.47-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1056577",
    "ThreadId": "402228",
    "Html": "I am trying to use the suggested method of creating and consuming events; but I am running into an issue - can someone please take a look at my code and let me know what I am doing incorrectly? The error I get is when the button is clicked and the Dialog class tried to call the trigger on the onSubmit event (Error = Uncaught TypeError: Cannot call method 'trigger' of undefined). I cannot figure out why onSubmit is undefined.\r<br />\n<br />\nmyclasses.ts\r<br />\n// Base IEvent Interface\r<br />\ninterface IEvent {...}\r<br />\n<br />\nclass TypedEvent implements IEvent {...}\r<br />\n<br />\n// Exposing events\r<br />\ninterface IMessageEvent extends IEvent {...}\r<br />\n<br />\n// Module\r<br />\nmodule myClasses {<br />\n<pre><code>// Class\nexport class Dialog {\n...\n    // EVENTS - TEST PROCESSING\n    onSubmit: IMessageEvent = new TypedEvent();\n\n    // Constructor\n    constructor() {\n...\n        // Get a reference to the buttons\n        this.btnSubmit = $('#signInBtnSubmit');\n\n        // CREATE EVENT HANDLERS\n        this.btnSubmit.click(function () {\n            this.onSubmit.trigger('event fired');\n        });\n     ...\n    }\n...\n}</code></pre>\n\n}\r<br />\n<br />\napp.ts\r<br />\n...<br />\n<pre><code>    var newDialog = new MyClasses.Dialog();\n    var handler = (message) =&gt; {\n        alert('Pressed Dialog Submit' + message);\n    };\n    newDialog.onSubmit.add(handler);</code></pre>\n\n...<br />\n",
    "PostedDate": "2013-06-13T15:20:21.733-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1056581",
    "ThreadId": "402228",
    "Html": "Well I thought I had it figured out; help still needed.<br />\n<br />\n&quot;I think I figured it out; it was a variable scoping error; I had to define my function that raises the event as public (as indicated) and then call that from my button click event virtual method. (Duh!).&quot;<br />\n<br />\nThanks,<br />\n",
    "PostedDate": "2013-06-13T15:30:35.563-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1056595",
    "ThreadId": "402228",
    "Html": "<pre><code>this.btnSubmit.click(function () {\n      this.onSubmit.trigger('event fired');\n});</code></pre>\n\nIn the above code, your second &quot;this&quot; is not the &quot;this&quot; you think it is.. :)\r<br />\nTry using the Fat Arrow syntax instead, as that preserve the class &quot;this&quot;<br />\n<pre><code>this.btnSubmit.click( () =&gt; {\n      this.onSubmit.trigger('event fired');\n});</code></pre>\n\n",
    "PostedDate": "2013-06-13T16:16:48.65-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1106892",
    "ThreadId": "402228",
    "Html": "With the help of generics, there can be defined generic interfaces for ickman's code:\r<br />\n<br />\nevents.ts<br />\n<pre><code>export interface I1ArgsEvent&lt;T&gt; extends IEvent {\n    add(listener: (message: T) =&gt; any): void;\n    remove(listener: (message: T) =&gt; any): void;\n    trigger(message: T): void;\n}\n\nexport interface I2ArgsEvent&lt;T, U&gt; extends IEvent {\n    add(listener: (message1: T, message2: U) =&gt; any): void;\n    remove(listener: (message: T, message2: U) =&gt; any): void;\n    trigger(message: T, message2: U): void;\n}</code></pre>\n\nEvents can then be written with the concrete parameter types as arguments<br />\n<pre><code>import Events = require(&quot;events.ts&quot;);\n\nclass Foo {\n    // Events\n    public onMessage: Events.I1ArgsEvent&lt;string&gt;= new Events.TypedEvent();\n        public onTwoArgsMessage: Events.I2ArgsEvent&lt;string, number&gt; = new Events.TypedEvent();\n    \n    // Methods\n    public bar(): void {\n        this.onMessage.trigger('event fired');\n                this.onTwoArgsMessage.trigger('event fired', 2);\n    }\n}</code></pre>\n\n",
    "PostedDate": "2013-10-13T10:36:03.49-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1119815",
    "ThreadId": "402228",
    "Html": "I found the answer to my own question.<br />\n",
    "PostedDate": "2013-11-07T07:57:11.483-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1120380",
    "ThreadId": "402228",
    "Html": "I personally use this : <br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:#A31515;\">&#39;use strict&#39;</span>;\n\n<span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">interface</span> ISignal&lt;T&gt; {\n    add(listener: (parameter: T) =&gt; <span style=\"color:Blue;\">any</span>, priority?: <span style=\"color:Blue;\">number</span>): <span style=\"color:Blue;\">void</span>;\n    remove(listener: (parameter: T) =&gt; <span style=\"color:Blue;\">any</span>): <span style=\"color:Blue;\">void</span>;\n    dispatch(parameter: T): <span style=\"color:Blue;\">boolean</span>;\n    clear(): <span style=\"color:Blue;\">void</span>;\n    hasListeners(): <span style=\"color:Blue;\">boolean</span>;\n}\n\n<span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> Signal&lt;T&gt; <span style=\"color:Blue;\">implements</span> ISignal&lt;T&gt; {\n    <span style=\"color:Blue;\">private</span> listeners: { (parameter: T): <span style=\"color:Blue;\">any</span> }[] = [];\n    <span style=\"color:Blue;\">private</span> priorities: <span style=\"color:Blue;\">number</span>[] = [];\n    \n    add(listener: (parameter: T) =&gt; <span style=\"color:Blue;\">any</span>, priority = 0): <span style=\"color:Blue;\">void</span> {\n        <span style=\"color:Blue;\">var</span> index = <span style=\"color:Blue;\">this</span>.listeners.indexOf(listener);\n        <span style=\"color:Blue;\">if</span> (index !== -1) {\n            <span style=\"color:Blue;\">this</span>.priorities[index] = priority;\n            <span style=\"color:Blue;\">return</span>;\n        }\n        <span style=\"color:Blue;\">for</span> (<span style=\"color:Blue;\">var</span> i = 0, l = <span style=\"color:Blue;\">this</span>.priorities.length; i &lt; l; i++) {\n            <span style=\"color:Blue;\">if</span> (<span style=\"color:Blue;\">this</span>.priorities[i] &lt; priority) {\n                <span style=\"color:Blue;\">this</span>.priorities.splice(i, 0, priority);\n                <span style=\"color:Blue;\">this</span>.listeners.splice(i, 0, listener);\n                <span style=\"color:Blue;\">return</span>;\n            }\n        }\n        <span style=\"color:Blue;\">this</span>.priorities.push(priority);\n        <span style=\"color:Blue;\">this</span>.listeners.push(listener);\n    }\n    \n    remove(listener: (parameter: T) =&gt; <span style=\"color:Blue;\">any</span>): <span style=\"color:Blue;\">void</span> {\n        <span style=\"color:Blue;\">var</span> index = <span style=\"color:Blue;\">this</span>.listeners.indexOf(listener);\n        <span style=\"color:Blue;\">if</span> (index &gt;= 0) {\n            <span style=\"color:Blue;\">this</span>.priorities.splice(index, 1);\n            <span style=\"color:Blue;\">this</span>.listeners.splice(index, 1);\n        }\n    }\n    \n    dispatch(parameter: T): <span style=\"color:Blue;\">boolean</span> {\n        <span style=\"color:Blue;\">var</span> indexesToRemove: <span style=\"color:Blue;\">number</span>[];\n        <span style=\"color:Blue;\">var</span> hasBeenCanceled = <span style=\"color:Blue;\">this</span>.listeners.every((listener: (parameter: T) =&gt; <span style=\"color:Blue;\">any</span>) =&gt;  {\n            <span style=\"color:Blue;\">var</span> result = listener(parameter);\n            <span style=\"color:Blue;\">return</span> result !== <span style=\"color:Blue;\">false</span>;\n        });\n        \n        <span style=\"color:Blue;\">return</span> hasBeenCanceled;\n    }\n    \n    clear(): <span style=\"color:Blue;\">void</span> {\n        <span style=\"color:Blue;\">this</span>.listeners = [];\n        <span style=\"color:Blue;\">this</span>.priorities = [];\n    }\n    \n    hasListeners(): <span style=\"color:Blue;\">boolean</span> {\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>.listeners.length &gt; 0;\n    }\n}\n\n\n<span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> JQuerySignalWrapper&lt;JQueryEventObject&gt; <span style=\"color:Blue;\">implements</span> ISignal&lt;JQueryEventObject&gt;  {\n  \n    <span style=\"color:Blue;\">constructor</span>(\n        <span style=\"color:Blue;\">private</span> target: JQuery, \n        <span style=\"color:Blue;\">private</span> event: <span style=\"color:Blue;\">string</span>\n    ) {}\n    \n    <span style=\"color:Blue;\">private</span> signal: Signal&lt;JQueryEventObject&gt; = <span style=\"color:Blue;\">new</span> Signal&lt;JQueryEventObject&gt;();\n    <span style=\"color:Blue;\">private</span> jqueryEventHandler = (parameter: JQueryEventObject) =&gt; {\n        <span style=\"color:Blue;\">this</span>.signal.dispatch(parameter);\n    }    \n    \n    add(listener: (parameter: JQueryEventObject) =&gt; <span style=\"color:Blue;\">any</span>, priority?: <span style=\"color:Blue;\">number</span>): <span style=\"color:Blue;\">void</span> {\n        <span style=\"color:Blue;\">this</span>.signal.add(listener, priority);\n        <span style=\"color:Blue;\">this</span>.target.on(<span style=\"color:Blue;\">this</span>.event, <span style=\"color:Blue;\">this</span>.jqueryEventHandler); \n    }\n    \n    remove(listener: (parameter: JQueryEventObject) =&gt; <span style=\"color:Blue;\">any</span>): <span style=\"color:Blue;\">void</span> {\n        <span style=\"color:Blue;\">this</span>.signal.remove(listener);\n        <span style=\"color:Blue;\">if</span> (!<span style=\"color:Blue;\">this</span>.hasListeners()) {\n            <span style=\"color:Blue;\">this</span>.removeJQueryEventListener();\n        }\n    } \n    \n    dispatch(parameter: JQueryEventObject): <span style=\"color:Blue;\">boolean</span> {\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>.signal.dispatch(parameter);\n    }\n    \n    clear(): <span style=\"color:Blue;\">void</span> {\n        <span style=\"color:Blue;\">this</span>.signal.clear();\n        <span style=\"color:Blue;\">this</span>.removeJQueryEventListener();\n    }\n    \n    hasListeners(): <span style=\"color:Blue;\">boolean</span> {\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>.signal.hasListeners();\n    }\n    \n    <span style=\"color:Blue;\">private</span> removeJQueryEventListener() {\n        <span style=\"color:Blue;\">this</span>.target.off(<span style=\"color:Blue;\">this</span>.event, <span style=\"color:Blue;\">this</span>.jqueryEventHandler);\n    }\n}\n\n\n<span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> DomSignalWrapper&lt;T <span style=\"color:Blue;\">extends</span> Event&gt; <span style=\"color:Blue;\">implements</span> ISignal&lt;T&gt;  {\n  \n    <span style=\"color:Blue;\">constructor</span>(\n        <span style=\"color:Blue;\">private</span> target: EventTarget, \n        <span style=\"color:Blue;\">private</span> event: <span style=\"color:Blue;\">string</span>,\n        <span style=\"color:Blue;\">private</span> capture: <span style=\"color:Blue;\">boolean</span>\n    ) {}\n    \n    <span style=\"color:Blue;\">private</span> signal: Signal&lt;T&gt; = <span style=\"color:Blue;\">new</span> Signal&lt;T&gt;();\n    <span style=\"color:Blue;\">private</span> eventHandler = (parameter: T) =&gt; {\n        <span style=\"color:Blue;\">this</span>.signal.dispatch(parameter);\n    }    \n    \n    add(listener: (parameter: T) =&gt; <span style=\"color:Blue;\">any</span>, priority?: <span style=\"color:Blue;\">number</span>): <span style=\"color:Blue;\">void</span> {\n        <span style=\"color:Blue;\">this</span>.signal.add(listener, priority);\n        <span style=\"color:Blue;\">this</span>.target.addEventListener(<span style=\"color:Blue;\">this</span>.event, <span style=\"color:Blue;\">this</span>.eventHandler, <span style=\"color:Blue;\">this</span>.capture);\n    }\n    \n    remove(listener: (parameter: T) =&gt; <span style=\"color:Blue;\">any</span>): <span style=\"color:Blue;\">void</span> {\n        <span style=\"color:Blue;\">this</span>.signal.remove(listener);\n        <span style=\"color:Blue;\">if</span> (!<span style=\"color:Blue;\">this</span>.hasListeners()) {\n            <span style=\"color:Blue;\">this</span>.removeEventListener();\n        }\n    } \n    \n    dispatch(parameter: T): <span style=\"color:Blue;\">boolean</span> {\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>.signal.dispatch(parameter);\n    }\n    \n    clear(): <span style=\"color:Blue;\">void</span> {\n        <span style=\"color:Blue;\">this</span>.signal.clear();\n        <span style=\"color:Blue;\">this</span>.removeEventListener();\n    }\n    \n    hasListeners(): <span style=\"color:Blue;\">boolean</span> {\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>.signal.hasListeners();\n    }\n    \n    <span style=\"color:Blue;\">private</span> removeEventListener() {\n        <span style=\"color:Blue;\">this</span>.target.removeEventListener(<span style=\"color:Blue;\">this</span>.event, <span style=\"color:Blue;\">this</span>.eventHandler, <span style=\"color:Blue;\">this</span>.capture);\n    }\n}\r\n</pre></div>",
    "PostedDate": "2013-11-08T02:29:05.437-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1218944",
    "ThreadId": "402228",
    "Html": "My implementation:<br />\n<pre><code>class EventArgs {\n    public static get Empty(): EventArgs {\n        return new EventArgs();\n    }\n}\n\ninterface IEventHandler&lt;T extends EventArgs&gt; {\n    handle(sender: any, e: T): void;\n}\n\nclass EventHandler&lt;T extends EventArgs&gt; implements IEventHandler&lt;T&gt; {\n    private _handler: { (sender: any, e: T): void };\n\n    constructor(handler: { (sender: any, e: T): void }) {\n        this._handler = handler;\n    }\n\n    public handle(sender: any, e: T): void {\n        this._handler(sender, e);\n    }\n}\n\ninterface IDelegate&lt;T extends EventArgs&gt; {\n    subscribe(eventHandler: IEventHandler&lt;T&gt;): void;\n    unsubscribe(eventHandler: IEventHandler&lt;T&gt;): void;\n}\n\nclass Delegate&lt;T extends EventArgs&gt; implements IDelegate&lt;T&gt; {\n    private _eventHandlers: Array&lt;IEventHandler&lt;T&gt;&gt;;\n\n    constructor() {\n        this._eventHandlers = new Array&lt;IEventHandler&lt;T&gt;&gt;();\n    }\n\n    public subscribe(eventHandler: IEventHandler&lt;T&gt;): void {\n        if (this._eventHandlers.indexOf(eventHandler) == -1) {\n            this._eventHandlers.push(eventHandler);\n        }\n    }\n\n    public unsubscribe(eventHandler: IEventHandler&lt;T&gt;): void {\n        var i = this._eventHandlers.indexOf(eventHandler);\n        if (i != -1) {\n            this._eventHandlers.splice(i, 1);\n        }\n    }\n\n    public raise(sender: any, e: T): void {\n        for (var i = 0; i &lt; this._eventHandlers.length; i++) {\n            this._eventHandlers[i].handle(sender, e);\n        }\n    }\n}</code></pre>\n\nHow to use it:<br />\n<pre><code>class A {\n    private _changeOccurred: Delegate&lt;EventArgs&gt;;\n\n    public get ChangeOccurred(): IDelegate&lt;EventArgs&gt; {\n        return this._changeOccurred;\n    }\n\n    constructor() {\n        this._changeOccurred = new Delegate&lt;EventArgs&gt;();\n    }\n\n    public makeChange() {\n        this._changeOccurred.raise(this, EventArgs.Empty);\n    }\n}\n\nclass B {\n    private _changeOccurredEventHandler: IEventHandler&lt;EventArgs&gt;;\n\n    constructor(a: A) {\n\n        this._changeOccurredEventHandler = new EventHandler&lt;EventArgs&gt;((sender: any, e: EventArgs) =&gt; {\n            this.onChangeOccurred(sender, a);\n        });\n        a.ChangeOccurred.subscribe(this._changeOccurredEventHandler);\n    }\n\n    private onChangeOccurred(sender: any, e: EventArgs) {\n\n    }\n}</code></pre>\n\n",
    "PostedDate": "2014-03-04T03:52:18.477-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]