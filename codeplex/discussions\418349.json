[
  {
    "Id": "971064",
    "ThreadId": "418349",
    "Html": "\r\n<p>When defining getter and setter in a class, and overriding them in a subclass you often want to reuse the logic defined in the base class getter/setter, to do so i thought i could use the keyword super like that :&nbsp;</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">class</span> A {\r\n\t<span style=\"color:blue\">private</span> _property:string;\r\n\t\r\n\t<span style=\"color:blue\">public</span> get property():string {\r\n\t\t<span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>._property;\r\n\t}\r\n\t\r\n\t<span style=\"color:blue\">public</span> set property(value:string) {\r\n\t\t<span style=\"color:blue\">this</span>._property = value;\r\n\t} \r\n\t\r\n\t<span style=\"color:blue\">public</span> showMyValue() {\r\n\t\talert(<span style=\"color:blue\">this</span>._property);\r\n\t}\r\n\r\n}\r\n\r\n<span style=\"color:blue\">class</span> B <span style=\"color:blue\">extends</span> A {\r\n\t<span style=\"color:blue\">public</span> get property():string {\r\n\t\t<span style=\"color:blue\">return</span> <span style=\"color:blue\">super</span>.property;\r\n\t}\r\n\t\r\n\t<span style=\"color:blue\">public</span> set property(value:string) {\r\n\t\t<span style=\"color:blue\">super</span>.property = value;\r\n\t}\r\n}\r\n\r\n<span style=\"color:blue\">var</span> t:B = <span style=\"color:blue\">new</span> B();\r\nt.property = <span style=\"color:#a31515\">&quot;value&quot;</span>;\r\n<span style=\"color:blue\">var</span> t2:B = <span style=\"color:blue\">new</span> B();\r\n\r\nt.showMyValue() <span style=\"color:green\">//&quot;value&quot;</span>\r\nt2.showMyValue() <span style=\"color:green\">//&quot;value&quot;</span>\r\n</pre>\r\n</div>\r\n<p></p>\r\n<p>However like that examples demonstrate it the property is set on the prototype of the base class. Firstly this&nbsp;behavior&nbsp;is not really intuitive and could lead to bug, then without the possibility of reusing code logic of base class accessors, getter\r\n and setters become a lot less&nbsp;powerful.</p>\r\n",
    "PostedDate": "2012-12-25T16:02:06.867-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "981440",
    "ThreadId": "418349",
    "Html": "\r\n<p>JavaScript's prototype based inheritance can be a source of confusion at times.</p>\r\n<p>The interesting problem here is that you are shadowing the base class by using the same names in the derived class, so you need to&nbsp;call 'super' to access the base instance, but prefixing the call with &quot;super&quot; means the 'this' is the super in the call, so\r\n you're modifying the_property on the super prototype object. &nbsp;To make things trickier yet, as you are using getters/setters these appear as properties, and you can't &quot;call&quot; the function, thus proving the right 'this' for the invocation.</p>\r\n<p>One option is to refactor out the logic you want to reuse in the base class, so that you can call this from either class without needing to disambiguate (and even if you&nbsp;did, as it's a method you could specify the 'this', i.e. ( super.setHelper.call(this)\r\n ).</p>\r\n<p>Does something like the below work?</p>\r\n<p>&nbsp;</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">class</span> A {\r\n\t<span style=\"color:blue\">private</span> _property:string;\r\n\r\n\tsetHelper(val: string) {\r\n\t   <span style=\"color:blue\">return</span> val.toUpperCase();\r\n\t}\r\n\t\r\n\t<span style=\"color:blue\">public</span> get property():string {\r\n\t\t<span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>._property;\r\n\t}\r\n\t\r\n\t<span style=\"color:blue\">public</span> set property(value:string) {\r\n\t\t<span style=\"color:blue\">this</span>._property = <span style=\"color:blue\">this</span>.setHelper(value);\r\n\t} \r\n\r\n\t<span style=\"color:blue\">public</span> showMyValue() {\r\n\t\tconsole.log(<span style=\"color:blue\">this</span>._property);\r\n\t}\r\n\r\n}\r\n\r\n<span style=\"color:blue\">class</span> B <span style=\"color:blue\">extends</span> A {\r\n    <span style=\"color:blue\">private</span> _property;\r\n\r\n    <span style=\"color:blue\">public</span> get property(): string {\r\n        <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>._property;\r\n    }\r\n\r\n    <span style=\"color:blue\">public</span> set property(value: string) {\r\n        <span style=\"color:blue\">this</span>._property = <span style=\"color:blue\">this</span>.setHelper(value) + <span style=\"color:#a31515\">&quot;plus&quot;</span>;\r\n    }\r\n}\r\n\r\n<span style=\"color:blue\">var</span> a: A = <span style=\"color:blue\">new</span> A();\r\na.property = <span style=\"color:#a31515\">&quot;setA&quot;</span>;\r\n<span style=\"color:blue\">var</span> b:B = <span style=\"color:blue\">new</span> B();\r\nb.property = <span style=\"color:#a31515\">&quot;setB&quot;</span>;\r\n<span style=\"color:blue\">var</span> b2:B = <span style=\"color:blue\">new</span> B();\r\nb2.property = <span style=\"color:#a31515\">&quot;setB2&quot;</span>;\r\n\r\na.showMyValue();  <span style=\"color:green\">// &quot;SETA&quot;</span>\r\nb.showMyValue();  <span style=\"color:green\">// &quot;SETBplus&quot;</span>\r\nb2.showMyValue(); <span style=\"color:green\">// &quot;SETB2plus&quot; </span>\r\n\r\n</pre>\r\n</div>\r\n<p></p>\r\n",
    "PostedDate": "2012-12-28T12:29:21.78-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "981685",
    "ThreadId": "418349",
    "Html": "\r\n<p>While something like that could work, firstly that implies that the base class have been wrote with in mind the possibility of overriding the properties getter/setter, then redeclaring the private property like it to in fact give the access to our subclass\r\n don't seems very clean in my point of view.</p>\r\n<p>What about translating my first example to something like it :</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">var</span> __extends = <span style=\"color:blue\">this</span>.__extends || <span style=\"color:blue\">function</span> (d, b) {\n    <span style=\"color:blue\">function</span> __() { <span style=\"color:blue\">this</span>.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = <span style=\"color:blue\">new</span> __();\n};\n<span style=\"color:blue\">var</span> __getSuperProperty = <span style=\"color:blue\">this</span>.__getSuperProperty || <span style=\"color:blue\">function</span> (target,_super,property) {\n    <span style=\"color:blue\">var</span> descriptor = Object.getOwnPropertyDescriptor(_super.prototype,property);\n    <span style=\"color:blue\">if</span>(<span style=\"color:blue\">typeof</span> descriptor.get != <span style=\"color:#a31515\">'undefined'</span>)   {\n        <span style=\"color:blue\">return</span> descriptor.get.call(target)\n    }\n    <span style=\"color:blue\">return</span> target[property];\n}\n<span style=\"color:blue\">var</span> __setSuperProperty = <span style=\"color:blue\">this</span>.__setSuperProperty || <span style=\"color:blue\">function</span> (target,_super,property,value) {\n    <span style=\"color:blue\">var</span> descriptor = Object.getOwnPropertyDescriptor(_super.prototype,property);\n    <span style=\"color:blue\">if</span>(<span style=\"color:blue\">typeof</span> descriptor.set != <span style=\"color:#a31515\">'undefined'</span>)   {\n        descriptor.set.call(target,value);\n        <span style=\"color:blue\">return</span>;\n    }\n    target[property] = value;\n}\n<span style=\"color:blue\">var</span> A = (<span style=\"color:blue\">function</span> () {\n    <span style=\"color:blue\">function</span> A() { }\n    Object.defineProperty(A.prototype, <span style=\"color:#a31515\">&quot;property&quot;</span>, {\n        get: <span style=\"color:blue\">function</span> () {\n            <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>._property;\n        },\n        set: <span style=\"color:blue\">function</span> (value) {\n            <span style=\"color:blue\">this</span>._property = value;\n        },\n        enumerable: <span style=\"color:blue\">true</span>,\n        configurable: <span style=\"color:blue\">true</span>\n    });\n    A.prototype.showMyValue = <span style=\"color:blue\">function</span> () {\n        alert(<span style=\"color:blue\">this</span>._property);\n    };\n    <span style=\"color:blue\">return</span> A;\n})();\n<span style=\"color:blue\">var</span> B = (<span style=\"color:blue\">function</span> (_super) {\n    __extends(B, _super);\n    <span style=\"color:blue\">function</span> B() {\n        _super.apply(<span style=\"color:blue\">this</span>, arguments);\n\n    }\n    Object.defineProperty(B.prototype, <span style=\"color:#a31515\">&quot;property&quot;</span>, {\n        get: <span style=\"color:blue\">function</span> () {\n            <span style=\"color:blue\">return</span> __getSuperProperty(<span style=\"color:blue\">this</span>,_super,<span style=\"color:#a31515\">&quot;property&quot;</span>);\n        },\n        set: <span style=\"color:blue\">function</span> (value) {\n            __setSuperProperty(<span style=\"color:blue\">this</span>,_super,<span style=\"color:#a31515\">&quot;property&quot;</span>,value);\n        },\n        enumerable: <span style=\"color:blue\">true</span>,\n        configurable: <span style=\"color:blue\">true</span>\n    });\n    <span style=\"color:blue\">return</span> B;\n})(A);\n<span style=\"color:blue\">var</span> t = <span style=\"color:blue\">new</span> B();\nt.property = <span style=\"color:#a31515\">&quot;value&quot;</span>;\n<span style=\"color:blue\">var</span> t2 = <span style=\"color:blue\">new</span> B();\nt.showMyValue(); <span style=\"color:green\">// value</span>\nt2.showMyValue(); <span style=\"color:green\">// undefined</span>\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>This way we use &nbsp;the getter/setter function described in the base class in the right context if such a method exist.</p>\r\n<p>&nbsp;</p>\r\n&nbsp;",
    "PostedDate": "2012-12-29T16:49:54.157-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "983478",
    "ThreadId": "418349",
    "Html": "\r\n<p>My bad, the solution i proposed does not work when the super class does not define getter/setter.<br>\r\nPerhaps the logic should be implemented at compile time ?<br>\r\nIn any way i really think that this problem is huge drawback to the getter/setter system, firstly because it leads to unexpected results, then it makes a lot's of&nbsp;pattern unusable.</p>\r\n",
    "PostedDate": "2013-01-06T06:12:26.447-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "992630",
    "ThreadId": "418349",
    "Html": "\r\n<p>I am trying to reuse base-class setter/getter and I can't. I hope this part will be improved.</p>\r\n",
    "PostedDate": "2013-01-27T04:51:49.82-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1155215",
    "ThreadId": "418349",
    "Html": "Is there a plan to allow virtualized base class accessors/setters in the future? Seems like an imbalance in the language, as compared to methods.<br />\n",
    "PostedDate": "2014-01-11T14:20:52.347-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]