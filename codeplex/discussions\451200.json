[
  {
    "Id": "1072776",
    "ThreadId": "451200",
    "Html": "Two things are worrying me about TypeScript constructors that seems to make them incompatible with ES6.\r<br />\n<br />\nThe current ES6 says: If a constructor function needs to perform superclass initialization, it must do so by explicitly calling super(/<em>arguments</em>/) at some point within the constructor body. - <a href=\"http://tc39wiki.calculist.org/es6/classes/\" rel=\"nofollow\">http://tc39wiki.calculist.org/es6/classes/</a>\r<br />\n<br />\nSo...\r<br />\n<br />\n<strong>Calling super is currently required</strong>\r<br />\n<br />\nThe proposal is not very clear about this leaving some room for interpretation, but it seems to make calling 'super()' optional, and up to the child class to decide if it needs to perform super class initialization or not. I would be really surprised if browsers enforced that. This is not a big issue, but makes mandatory to execute code that would not be  required to do so, creating possible performance issues for TypeScript code. Some libraries currently allow you to override the constructors at the runtime, and not call the existing constructor at all (<a href=\"http://backbonejs.org/#Model-constructor\" rel=\"nofollow\">http://backbonejs.org/#Model-constructor</a>).\r<br />\n<br />\n<strong>Calling 'super()' is required as the first statement of the constructor</strong>\r<br />\n<br />\nThis is a big issue. The proposal is very clear on this, where <strong>if</strong> super initialization is required, it must be done  <strong>at some point</strong> of the child constructor, not at the beginning.\r<br />\n<br />\nThis is a real issue, because libraries out there use this feature of the language and will continue using them because it creates a nice pattern. You can optionally define properties that will be used by the constructor, and then call the constructor without worring about lots of optional arguments and their positions.\r<br />\n<br />\nThis &quot;feature&quot; makes TypeScript classes incompatible with existing libraries, and require  workarounds to make them work correctly, like running initialization code twice.\r<br />\n<br />\nI have been working with C# for the last 10 years, and have coded in other OO languages as well, and I understand why it would be good to have this added to the language. I don't want to discuss if this works in other platforms, because I know they work there and provide required safeties to the code. Also, I'm not saying Backbone or other common JS libraries have exemplary architecture designs.\r<br />\n<br />\nThe point here is that these checks are enforcing the runtime to execute code that shouldn't run or that should run in a different order, and there is no way to prevent that.\r<br />\n<br />\nSome ideas to solve this:<br />\n<ul>\n<li>TypeScript could enforce this based on a compiler option if the project requires the check, just like &quot;noImplicitAny&quot;</li>\n<li>TypeScript should not enforce this by default, but show warnings if you forget to call super or call it somewhere else</li>\n<li>\nTypeScript could not enforce these checks based on compiler option<br />\n</li>\n</ul>\nI must say that I vote against option 3 (enforcing by default like today) because code that produces different behavior than what you get with JavaScript should be optional, not mandatory.<br />\n",
    "PostedDate": "2013-07-25T06:47:11.707-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1072847",
    "ThreadId": "451200",
    "Html": "This is a good point to consider. However, keeping in mind that not all JavaScript compiles as TypeScript out of the box anyway, I tend to prefer having the safer option be the default, and I'm less concerned with compatibility. Most existing javascript code has to be ported to TypeScript anyway to avoid type errors due to inferred structural types. \r<br />\n<br />\nI'm not sure that skipping super constructors is a safe optimization to make anyway, given the possibility that the super class's constructor could be modified at some point in the future (possibly at runtime even). And, assuming it WAS safe to do, the compiler is the appropriate place to make that optimization. That is, the compiler would check if your base class's constructor did anything, and if so, removed the super constructor call. That would at least eliminate the possibility of your (pre)optimization breaking in the future when the base class changes.<br />\n",
    "PostedDate": "2013-07-25T08:38:50.527-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1073026",
    "ThreadId": "451200",
    "Html": "@nvivo:  Two things to consider:\r<br />\n1) Not calling super() is quite dangerous from a versioning perspective, and I have argued that this requirement should be part of ES6.  However, ECMAScript generally doesn't have these kind of restrictions though, so this has not been added to the ES6 proposal.  The TypeScript position is intentionally being more conservative here, as is done in many places in TypeScript.\r<br />\n2) TypeScript does not require 'super' to be the first statement in the constructor.  This constraint only applies when there are field initializers in the class, which is not part of ES6, so there should be no practical conflict.  We may consider loosening this restriction further in the future, but that needs to be considered in context of the specific rules for what field initializers means (exactly where in the constructor do they get emitted, and can a super constructor depend on this state being initialized).<br />\n",
    "PostedDate": "2013-07-25T12:20:54.843-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]