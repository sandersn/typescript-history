[
  {
    "Id": "1026367",
    "ThreadId": "439314",
    "Html": "The problem is using an external library (ie. jquery) on a TypeScript file while making the dependency explicit for RequireJS. \r<br />\n<br />\nThat is, that the generated code includes something like:<br />\n<pre><code>define(['require', 'jquery'], function() {...})</code></pre>\n\nThis has been asked multiple times, and there are various sort of answers. The cleanest way I found to do it for now is by writing something like:<br />\n<pre><code>/// &lt;reference path=&quot;../definitions/jquery.d.ts&quot;/&gt;\n/// &lt;amd-dependency path=&quot;jquery&quot;/&gt;\n</code></pre>\n\nUsing the undocumented amd-dependency thing (which is quite useful for other scenarios, BTW, like importing css! &amp; text! modules).\r<br />\n<br />\nThe problem with that approach is that:\r<br />\na) You're repeating yourself.\r<br />\nb) The reference tag is 'inherited' while importing a module that already contains it. That is, if you do import utils = module('utils') and utils.ts had a &lt;reference&gt; to jquery, you don't need to add another &lt;reference&gt; at the module. That's a bad thing IMO because you might forget to add the explicit amd-reference. I want to have to explicitly require it and then be included in the require dependencies.\r<br />\n<br />\nAre there any plans to tackle this issue? Or is there a right way to do it with the current specification? \r<br />\n<br />\nMaybe having something like &lt;amd-reference&gt; solves the issue by making the reference available only on the current module and also working as the current &lt;amd-dependency&gt;....<br />\n",
    "PostedDate": "2013-04-05T15:10:34.857-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1027506",
    "ThreadId": "439314",
    "Html": "I think the key is picking a consistent approach and sticking to it. I prefer the syntax of internal modules, but I want the flexibility of loading using AMD, so I am using amd-dependency in the following manner:\r<br />\n<br />\nConsider the following project layout:\r<br />\n<br />\n/BusinessDomain\r<br />\n---/BusinessDomain.d.ts\r<br />\n--/Order.ts\r<br />\n--/Customer.ts\r<br />\n/UserModel\r<br />\n--/UserDomain.d.ts\r<br />\n--/User.ts\r<br />\n--/Account.ts\r<br />\n/Namespaces\r<br />\n--/BusinessDomain.ts\r<br />\n--/UserModel.ts\r<br />\nApp.ts\r<br />\n<br />\nInside the library implementation folders (BusinessDomain and UserModel) I create 1 file per class/interface. The d.ts file for the library contains a reference to each file in the library, and each file is defined as an internal module like this:\r<br />\n<br />\n<strong>Order.ts</strong><br />\n<pre><code>/// &lt;reference path=&quot;BusinessDomain.d.ts&quot; /&gt;\n\nmodule BusinessDomain {\n\n    export class Order {\n    ....\n    }\n    \n}\n</code></pre>\n\n<strong>Customer.ts</strong><br />\n<pre><code>/// &lt;reference path=&quot;BusinessDomain.d.ts&quot; /&gt;\n\nmodule BusinessDomain {\n\n    export class Customer{\n    ....\n    }\n    \n}</code></pre>\n\n<strong>BusinessDomain.d.ts</strong><br />\n<pre><code>/// &lt;reference path=&quot;Customer.ts&quot; /&gt;\n/// &lt;reference path=&quot;Order.ts&quot; /&gt;</code></pre>\n\n<strong>Namespaces/BusinessDomain.ts</strong><br />\n<pre><code>/// &lt;amd-dependency path=&quot;../BusinessDomain/Order&quot;/&gt;\n/// &lt;amd-dependency path=&quot;../BusinessDomain/Customer&quot;/&gt;\n\nexport module BusinessObjects {\n\n}</code></pre>\n\n<strong>App.ts</strong><br />\n<pre><code>/// &lt;reference path=&quot;BusinessObjects/BusinessObjects.d.ts&quot;/&gt;\n/// &lt;amd-dependency path=&quot;Namespaces/BusinessObjects&quot;/&gt;\n\nexport module App {\n    var order = new BusinessObjects.Order();\n}</code></pre>\n\n",
    "PostedDate": "2013-04-08T14:10:37.543-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1027630",
    "ThreadId": "439314",
    "Html": "I like your approach and I have some further questions:<br />\n<ul>\n<li>Which of the files do you really have to write your self and witch are generated or compiled? (for example the d.ts file)</li>\n<li>How the file Namespaces/BusinessDomain.ts looks like?</li>\n<li>\nCould you provide a little sample project which is describing your approach more deeply?<br />\n</li>\n</ul>\nMany thanks in advance.<br />\n",
    "PostedDate": "2013-04-08T20:25:16.113-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1027978",
    "ThreadId": "439314",
    "Html": "Interesting approach! I think that's a good way to support 1 class per file modules, while still being able to use AMD to load the whole module. Though it adds all the definitions as globals, it's a good way to encourage using the same module name everywhere instead of having import foo = module('order') in a place and import bar = module('order') in another.\r<br />\n<br />\nHowever, it also highlights what I was complaining about (though in the context of TS libraries instead of external libraries as in my original post). \r<br />\n<br />\nSuppose that on Order.ts you add a reference to an external library (libA) that you want to use there. So you'll probably write something like:<br />\n<pre><code>/// &lt;reference path=&quot;BusinessDomain.d.ts&quot; /&gt;\n/// &lt;reference path=&quot;libA.d.ts&quot; /&gt;\n/// &lt;amd-reference path=&quot;libA&quot; /&gt;\n\nmodule BusinessDomain {\n    export class Order {\n    ....\n    }    \n}</code></pre>\n\nHere you:\r<br />\na) Are repeating yourself. Nothing too bad, but probably the language could help you here, to make these uses more straightforward and to <em>encourage</em> one way of doing it. We don't want every single team defining their way to handle &amp; structure modules, that's what we had with JS. A clear guideline encouraged by the language design would be a plus, IMO.\r<br />\n<br />\nb) libA is now also available on App, though App didn't include it explicitly (you could go to App and do a new libA.MyClass()). I don't like that. The fact that Order used libA is an implementation detail, if I happen to use libA on App and later no longer use it from Order, my code will break (at compile time, thankfully). I would prefer it to be hidden and be forced to include libA on App if I need to use that library on App. The way to do that while hiding it is by using an import instead, but then we go back to my original post, about how to handle it for non RequireJS third-party libraries like jQuery.\r<br />\n<br />\nBy the way, your approach also highlights than having a class per file, where all the classes belong to the same module, and using <em>only</em> the import syntax, doesn't really work, without manual work, which is a shame. The only way I can think of doing it is by:\r<br />\nmoduleA.ts:<br />\n<pre><code>import classA = module('classA')\nexport var ClassA = classA.ClassA;\n.... (same thing for every other class)</code></pre>\n\nThat would let you have clases internal to the module though ;).<br />\n",
    "PostedDate": "2013-04-09T10:04:26.743-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1028007",
    "ThreadId": "439314",
    "Html": "Re: @idev71<br />\n<br />\n<strong><em>Which of the files do you really have to write your self and witch are generated or compiled? (for example the d.ts file)</em></strong><br />\n<br />\nI am developing a visual studio extension that generates TypeScript classes and interfaces from C# using the Roslyn CTP, so in my example BusinessDomain and UserModel would be projects inside a solution that contain classes or interfaces marked with a custom attribute. The tool then generates the TypeScript and as well as reference files.<br />\n<br />\n<strong><em>How the file Namespaces/BusinessDomain.ts looks like?</em></strong><br />\n<br />\nThe file Namespaces/BusinessDomain.ts is an empty module, the sole purpose of the external module BusinessObjects is to load the components of the internal module into the global namespace.<br />\n<br />\n<strong><em>Could you provide a little sample project which is describing your approach more deeply?</em></strong><br />\n<br />\nI do have a sample solution inside the source tree for my visual studio extension. I am in the process of getting the project approved by my employer to be released as open source under the Apache 2.0 license. I expect to be able to push the current source code and a preview build sometime in the next week or so. <br />\n<br />\nThere is a project page for the Visual Studio extension at <a href=\"http://typesharp.codeplex.com\" rel=\"nofollow\">http://typesharp.codeplex.com</a>, I would suggest following this project if you are interested and I can update this thread when the current source code is available.<br />\n",
    "PostedDate": "2013-04-09T11:11:30.28-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1028014",
    "ThreadId": "439314",
    "Html": "RE: @saguiar<br />\n<br />\n<strong><em>Suppose that on Order.ts you add a reference to an external library (libA) that you want to use there. So you'll probably write something like ...</em></strong><br />\n<br />\nAs I mentioned in my reply to @idev71 my example is based on what I am developing for my code generator tool.<br />\n<br />\nI am currently handling references between libraries using the following methodology:<br />\n<ol>\n<li>Each class/interface implementation file within BusinessDomain only contains a reference to BusinessDomain.d.ts</li>\n<li>BusinessDomain.d.ts contains a reference for each file within BusinessDomain</li>\n<li>\nIf there is a reference to a type in another library then the reference for that library is included in BusinessDomain.d.ts, so for example if we reference User from UserModel inside Order in BusinessDomain then BusinessDomain.d.ts would look like this:<br />\n</li>\n</ol>\n<pre><code>/// &lt;reference path=&quot;Customer.ts&quot; /&gt;\n/// &lt;reference path=&quot;Order.ts&quot; /&gt;\n/// &lt;reference path=&quot;../UserModel/UserModel.d.ts&quot; /&gt;</code></pre>\n\n<ol>\n<li>\nIf a library contains external references, then when the external module reference is generated it will look like this:<br />\n</li>\n</ol>\n<pre><code>/// &lt;amd-dependency path=&quot;UserModel&quot; /&gt;\n/// &lt;amd-dependency path=&quot;../BusinessDomain/Order&quot;/&gt;\n/// &lt;amd-dependency path=&quot;../BusinessDomain/Customer&quot;/&gt;\n\nexport module BusinessObjects {\n\n}\n</code></pre>\n\n<strong><em>By the way, your approach also highlights than having a class per file, where all the classes belong to the same module, and using only the import syntax, doesn't really work, without manual work, which is a shame. The only way I can think of doing it is by...</em></strong><br />\n<br />\nMy issue with the current external module implementation is the clutter when importing modules, I don't want to have to do:<br />\n<pre><code>import foo = module(&quot;ModuleName&quot;)\nvar foobar = new foo.ModuleName.MyType(); // clutter here, I would rather type var foobar = new ModuleName.MyType()</code></pre>\n\nMy understanding is that TypeScript 0.9 is going to change how this works by allowing something like:<br />\n<pre><code>import ModuleName = module(&quot;ModuleName&quot;);\nvar foobar = new ModuleName.MyType()</code></pre>\n\nHowever I'm unsure how this will work with multiple files per module since my understanding of the spec is that it will allow you to export a single class as the top level export.<br />\n<br />\nSo for now I agree that there is some duplication with references and amd-dependencies, however vs the other alternatives I find it to be the best approach for now.<br />\n",
    "PostedDate": "2013-04-09T11:36:37.447-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]