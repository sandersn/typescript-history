{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "Thank you for your suggestion. As I mentioned in the earlier comment, you can add an 'any' overload which allows you to overload on the type of the parameter.\n\nWhile technically possible, we want to keep the generated javascript as close to the TypeScript as possible; so renaming methods the is not something developers expect.",
    "ClosedDate": "2013-01-17T13:57:05.97-08:00",
    "CommentCount": 7,
    "Custom": null,
    "Description": "Hey, overloading is a great feature of TypeScript. But I wonder, why there is only overloading possible with different count of arguments. I mean, I understand it, when considering how overloading is compiled to JavaScript right now.\r\n\r\nBut wouldn't it be possible, to compile two methods with the same name to two methods with different names in JavaScript? Like compiling\r\n\r\n```\r\nclass FooBar\r\n{\r\n    test(name: string) { ... }\r\n    test(int: age) { ... }\r\n}\r\n```\r\n\r\nto\r\n\r\n```\r\nFooBar.prototype.test1 = function (name) { ... };\r\nFooBar.prototype.test2 = function (age) { ... };\r\n```\r\n\r\nSince it can be evaluated at compile time which method to acutally call, the TypeScript compiler could handle the delegation to the right method...\r\n\r\nWhat do you guys think?\r\nGreetz\r\n\r\nChristian",
    "LastUpdatedDate": "2014-01-16T06:35:33.05-08:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Low",
      "Severity": 50,
      "Id": 1
    },
    "ProjectName": "typescript",
    "ReportedDate": "2013-01-17T12:11:51.497-08:00",
    "Status": {
      "Name": "Closed",
      "Id": 4
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Real overloading of methods",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 1,
    "Id": 617
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "Thank you for your suggestion.\n\nYou can have overloads on the type of the parameter, like this:\n\n```\nclass MyClass\n{\n    test(name: string);\n    test(age: number);\n    test(value: any){\n        if( typeof value === 'string'){ /* handle string here */ }\n        if( typeof value === 'number'){ /* handle number here */ }\n    }\n}\n```",
      "PostedDate": "2013-01-17T13:39:43.25-08:00",
      "Id": 86400
    },
    {
      "Message": "okay I get the design choice for overloaded methods in TypeScript but I think it would be better if TypeScript could automate more of the if'ing and generate the dispatch resolution in the implementation of  ```test(value: any) ``` so the user doesn't need to? i.e. ```test1``` and ```test2``` are private implementation methods generated from user's source and implementation of ```test(value: any)``` is also generated by TypeScript. ",
      "PostedDate": "2013-07-20T08:06:20.37-07:00",
      "Id": 106761
    },
    {
      "Message": "Couldn't this:\n```\nclass MyClass\n{\n    test(name: string) {\n        console.log(\"I'm a string!\");\n    }\n    test(age: number)\n        console.log(\"I'm a number!\");\n    }\n}\n```\nbe generated into this:\n```\nMyClass.prototype.test = function(arg1) {\n    if (typeof arg1 === \"string\") {\n        console.log(\"I'm a string!\");\n    } else if (typeof arg1 === \"number\") {\n        console.log(\"I'm a number!\");\n    }\n}\n```\n?",
      "PostedDate": "2013-07-21T00:12:29.323-07:00",
      "Id": 106816
    },
    {
      "Message": "I wish TypeScript could do that!",
      "PostedDate": "2013-07-21T01:25:48.383-07:00",
      "Id": 106817
    },
    {
      "Message": "John Resig has a helper method for overloading methods. This works well with TypeScript as well.\n\nhttp://ejohn.org/blog/javascript-method-overloading/\n",
      "PostedDate": "2013-08-07T13:45:19.767-07:00",
      "Id": 108915
    },
    {
      "Message": "okay - so John's framework doesn't do that much - really - he says it just distinguishes variable number of args and ignores types. Also, found out that TypeScript erases all compile-time information about class-types. And that's why people(including me) are writing their own enums to preserve the class type info at runtime. Got it! I'm not an expert on method overloading/multimethods but does compile-time method dispatch have any  mileage left in it? \n\nCan we reflect Object.constructor instead of writing our own enums?  ",
      "PostedDate": "2014-01-16T06:00:16.42-08:00",
      "Id": 130559
    },
    {
      "Message": "aha - when typeof returns 'object' then we can use instanceof to further test the class type.",
      "PostedDate": "2014-01-16T06:35:33.05-08:00",
      "Id": 130565
    }
  ]
}