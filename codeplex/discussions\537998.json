[
  {
    "Id": "1219325",
    "ThreadId": "537998",
    "Html": "A lot of Javascript library (Facebook React for example) force us to create our objects trough some factory that hey provide: <br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">declare</span> <span style=\"color:Blue;\">module</span> MyLibrary {\n    <span style=\"color:Blue;\">interface</span> Component&lt;A&gt; {\n    }\n    <span style=\"color:Blue;\">function</span> createMyComponent&lt;A&gt;(): (a: A)=&gt; Component&lt;A&gt;;\n}\r\n</pre></div>However using those library make the use of <code>export =</code> syntax nearly impossible :<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> A {\n}\n<span style=\"color:Blue;\">var</span> MyCompFactory = MyLibrary.createMyComponent&lt;A&gt;();<span style=\"color:Green;\">//exported variable MyCompFactory has or is using private type A </span>\n<span style=\"color:Blue;\">export</span> = MyCompFactory; \r\n</pre></div>and if I try to use declaration merging: <br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> MyCompFactory = MyLibrary.createMyComponent&lt;MyCompFactory.A&gt;();\n<span style=\"color:Blue;\">module</span> MyCompFactory { <span style=\"color:Green;\">// error: duplicate identier MyCompFactory</span>\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> A {\n        \n    } \n}\n<span style=\"color:Blue;\">export</span> = MyCompFactory; \r\n</pre></div>If we had something like <em>vardule</em> , this example would be resolvable.<br />\n",
    "PostedDate": "2014-03-04T23:45:44.53-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1220116",
    "ThreadId": "537998",
    "Html": "Does this do what you want?<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">module</span> My {\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> A { }\n\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">var</span> MyCompFactory = MyLibrary.createMyComponent&lt;A&gt;();\n}\n<span style=\"color:Blue;\">export</span> = My; \r\n</pre></div>Fundamentally there's no way to merge a module and a variable like you're proposing. A module is just a variable in JavaScript so all you'd be doing is overwriting the value of the first instance with the second one. <br />\n",
    "PostedDate": "2014-03-06T17:13:50.303-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1220123",
    "ThreadId": "537998",
    "Html": "When I think about it my main problem is the impossibility to reference private type in exported one, and all the restriction that cast on the <code>export =</code> syntax.<br />\n<br />\nFor your example, is it not the same as doing this ? <br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> A { }\n\n<span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">var</span> MyCompFactory = MyLibrary.createMyComponent&lt;A&gt;();\r\n</pre></div><em>Fundamentally there's no way to merge a module and a variable like you're proposing. A module is just a variable in JavaScript so all you'd be doing is overwriting the value of the first instance with the second one.</em> <br />\n<br />\nIf the example I have given in my first post :<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> MyCompFactory = MyLibrary.createMyComponent&lt;MyCompFactory.A&gt;();\n<span style=\"color:Blue;\">module</span> MyCompFactory { <span style=\"color:Green;\">// error: duplicate identier MyCompFactory</span>\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> A {\n        \n    } \n}\n<span style=\"color:Blue;\">export</span> = MyCompFactory; \r\n</pre></div>would translate to :<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> MyCompFactory = MyLibrary.createMyComponent();\n<span style=\"color:Blue;\">var</span> MyCompFactory;\n(<span style=\"color:Blue;\">function</span> (MyCompFactory) {\n    <span style=\"color:Blue;\">var</span> A = (<span style=\"color:Blue;\">function</span> () {\n        <span style=\"color:Blue;\">function</span> A() {\n        }\n        <span style=\"color:Blue;\">return</span> A;\n    })();\n    MyCompFactory.A = A;\n})(MyCompFactory || (MyCompFactory = {}));\r\n</pre></div>Where would be the problem ? except if MyCompFactory was a primitive type but  would not such case be easily caught by the compiler ? <br />\nIn fact especially in this case <code>MyCompFactory</code> is a function so is it not equivalent to function with module merging ?<br />\n",
    "PostedDate": "2014-03-06T17:42:14.57-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1220433",
    "ThreadId": "537998",
    "Html": "I don't think it would be a good idea to allow variables and modules to merge. You'd be modifying whatever object happens to be stored in the variable (which may or may not be ok), but the modifications would disappear if another value is assigned to the variable. Would be a very odd construct.\r<br />\n<br />\nI think you can just use a function/module combination in your scenario:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> MyCompFactory() {\n    <span style=\"color:Blue;\">return</span> MyLibrary.createMyComponent&lt;MyCompFactory.A&gt;();\n}\n<span style=\"color:Blue;\">module</span> MyCompFactory {\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> A {\n        ...\n    }\n}\n<span style=\"color:Blue;\">export</span> = MyCompFactory;\r\n</pre></div>",
    "PostedDate": "2014-03-07T11:58:21.053-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1220571",
    "ThreadId": "537998",
    "Html": "<blockquote>\nI don't think it would be a good idea to allow variables and modules to merge. You'd be modifying whatever object happens to be stored in the variable (which may or may not be ok), but the modifications would disappear if another value is assigned to the variable. Would be a very odd construct. <br />\n</blockquote>\n<h1></h1>\nYes you're right, I did not see those limitations.<br />\n<h1></h1>\nAnyway as I said in my previous post my main problem is more due to the impossibility of referencing private type in exported one and all the restrictions that cast on the <code>export = syntax</code>. I just wanted <em>vardule</em> to paliate to these problems.<br />\n<br />\nFor your solution, unfortunately that still doesn't work.<br />\nFirstly the real <code>createMyComponent</code> has this definition :<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> toReactComponent&lt;A, C <span style=\"color:Blue;\">extends</span> ReactComponent&lt;<span style=\"color:Blue;\">any</span>, <span style=\"color:Blue;\">any</span>&gt;&gt;(\n        definition: { \n            <span style=\"color:Blue;\">new</span>(): C ;\n            <span style=\"color:Green;\">//just a little trick to make typescript infer valid type on generated factory</span>\n            prototype: { props: A } \n        }\n    ): (props: A, ...children: <span style=\"color:Blue;\">any</span>[]) =&gt; C;\n}\r\n</pre></div>and I want to be able to do something like that :<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">interface</span> Props {\n...\n}\n<span style=\"color:Blue;\">class</span> Definition <span style=\"color:Blue;\">extends</span> ReactTypescript.ReactComponentBase&lt;Props, {}&gt; {\n...\n}\n<span style=\"color:Blue;\">var</span> MyComponent = ReactTypescript.toReactComponent(Definition);\n<span style=\"color:Blue;\">export</span> = MyComponent;\r\n</pre></div>secondly <code>toReactComponent</code> does complex computation that I do not want to repeat each time I want to create a new instance of MyComponent<br />\n<br />\nso the only solution that I see would be :<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\n<span style=\"color:Blue;\">var</span> MyComponentFactory = ReactTypescript.toReactComponent(Definition);\n\n<span style=\"color:Blue;\">function</span> MyComponent(props:MyComponent.props, ...children: <span style=\"color:Blue;\">any</span>[]): MyComponent.Definition {\n    <span style=\"color:Blue;\">return</span> MyComponentFactory.apply(undefined, arguments);\n}\n\n<span style=\"color:Blue;\">module</span> MyComponent {\n    <span style=\"color:Blue;\">interface</span> Props {\n    ...\n    }\n    <span style=\"color:Blue;\">class</span> Definition <span style=\"color:Blue;\">extends</span> ReactTypescript.ReactComponentBase&lt;Props, {}&gt; {\n    ...\n    }\n}\n\n\n<span style=\"color:Blue;\">export</span> = MyComponent;\r\n</pre></div>But that makes me lose all benefits of type inference.<br />\n<br />\nThanks for your answer.<br />\n",
    "PostedDate": "2014-03-08T03:37:21.5-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]