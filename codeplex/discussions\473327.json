[
  {
    "Id": "1134980",
    "ThreadId": "473327",
    "Html": "Hello everyone. <br />\n<br />\nAfter updating to 0.9.5 I've found some errors in the defenition for js-library.<br />\nLet me explain the situation through the code. <br />\nIt is my JavaScript code:<br />\n<pre><code>var Sample = lib.ClassImpl({\n    ctor: function(array) {\n        var me = this;\n\n        this._items = array;\n        this._items.forEach(function(name) {\n            me[name] = new ItemWrapper(name); //Implemetation of ItemWrapper is unnecessary\n        });\n    },\n\n    doSomething: function() {\n        //some logic, no return\n    },\n\n    returnSomething: function() {\n        return this._items.length;\n    }\n});</code></pre>\n\nAnd this is the usage:<br />\n<pre><code>var sample = new Sample([&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;]);\nsample.doSomething();\nconsole.log(sample.returnSomething());\nconsole.log(sample.First.method());\nconsole.log(sample.Third.method());</code></pre>\n\nIn typescript defenitions which I've wrote for previous version of TypeScript compiler (0.9.1.1) I was able to do:<br />\n<pre><code>export interface ISampleBase {\n    doSomething(): void;\n    returnSomething(): number;\n}\nexport interface ISample extends ISampleBase {\n    [name: string]: ItemWrapper; //here is the error\n}\nexport class Sample implemets ISampleBase {\n    constructor(array: string[]);\n    doSomething(): void;\n    returnSomething(): number;  \n}</code></pre>\n\nAnd then use it in my ts-file (intellisense work like a charm):<br />\n<pre><code>var sample: ISample = new Sample([&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;]);\nsample.doSomething(); \nsample[&quot;Third&quot;].method();</code></pre>\n\nBut after update to version 0.9.5 I've got an error, that all named properties must by subtypes of string indexer type ItemWrapper on line above that marked by comment. <br />\nIs there any variants for me to resolve the issue? <br />\n<br />\n<strong>upd:</strong> <a href=\"http://www.typescriptlang.org/Playground/#src=interface%20ISampleBase%20%7B%0A%20%20%20%20doSomething()%3A%20void%3B%0A%20%20%20%20returnSomething()%3A%20number%3B%0A%7D%0A%20interface%20ISample%20extends%20ISampleBase%20%7B%0A%20%20%20%20%5Bname%3A%20string%5D%3A%20Date%3B%20%2F%2Fhere%20is%20the%20error%0A%7D%0Adeclare%20class%20Sample%20implements%20ISampleBase%20%7B%0A%20%20%20%20constructor(array%3A%20string%5B%5D)%3B%0A%20%20%20%20doSomething()%3A%20void%3B%0A%20%20%20%20returnSomething()%3A%20number%3B%20%20%0A%7D\" rel=\"nofollow\">Link to example.</a><br />\n",
    "PostedDate": "2013-12-12T04:04:41.77-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1135151",
    "ThreadId": "473327",
    "Html": "With 0.9.5, we've been tightening the type checker to enforce the language spec rules more closely.  One area that's gotten some attention is the indexer.  Looking at what the merged form of ISample looks like:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">interface</span> ISample {\n    doSomething(): <span style=\"color:Blue;\">void</span>;\n    returnSomething(): <span style=\"color:Blue;\">number</span>;\n    [name: <span style=\"color:Blue;\">string</span>]: ItemWrapper; <span style=\"color:Green;\">//here is the error</span>\n}\r\n</pre></div>The indexer here states that for any property access with the indexer, an ItemWrapper is returned.  Any time this isn't the case, the compiler will warn you.  While you might read this as &quot;indexing with any value other than one of the property names&quot;, it turns out this can't be checked.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> s;\n<span style=\"color:Blue;\">if</span> (somerandomnumber()) {\n  s = <span style=\"color:#A31515;\">&quot;returnSomething&quot;</span>;\n}\n<span style=\"color:Blue;\">else</span> {\n  s = <span style=\"color:#A31515;\">&quot;somethingElse&quot;</span>;\n}\n<span style=\"color:Blue;\">var</span> is: ISample;\n<span style=\"color:Blue;\">var</span> y = is[s];\r\n</pre></div>The indexer then covers everything in this case, so that's why we do the subtype check to make sure all the properties match what the indexer says.  It's tempting to wonder why we can't treat explicit property accesses and indexed accesses differently, which would allow this to continue working.  Unfortunately, treating them as separate makes a distinction that JavaScript doesn't make - namely that both accessing via a '.' or through an indexer should be equivalent.\r<br />\n<br />\nThis makes it difficult to model the &quot;everything else&quot; use for the indexer, like your example.  \r<br />\n",
    "PostedDate": "2013-12-12T09:17:12.177-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]