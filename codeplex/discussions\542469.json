[
  {
    "Id": "1234882",
    "ThreadId": "542469",
    "Html": "I'm developing an extension for Brackets (editor) that add TypeScript support.\r<br />\nI'm experiencing painful experience with feeding the compiler with edit. \r<br />\nSometimes the languageService will send errors like if the sourceTree is desynchronized, findToken operation on retrieved syntax tree will throw errors. However when I check the string content stored in my languageService host it is in sync with my editor.\r<br />\nHere is my ScriptSnapshot implementation, it's basicly a modified version from the one in test harness, if anybody could give me at least a hints on what I do wrong it would helps :<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\n\n<span style=\"color:Green;\">/**\n * Manage a script in the language service host\n */</span>\n<span style=\"color:Blue;\">class</span> ScriptInfo {\n    ...\n    editRanges: TypeScript.TextChangeRange[] = [];\n    ...\n    updateContent(newContent: <span style=\"color:Blue;\">string</span>): <span style=\"color:Blue;\">void</span> {\n        <span style=\"color:Blue;\">this</span>.setContent(newContent);\n        <span style=\"color:Blue;\">this</span>.editRanges = []\n        <span style=\"color:Blue;\">this</span>.version++;\n    }\n    ....\n    editContent(minChar: <span style=\"color:Blue;\">number</span>, limChar: <span style=\"color:Blue;\">number</span>, newText: <span style=\"color:Blue;\">string</span>): <span style=\"color:Blue;\">void</span> {\n        <span style=\"color:Green;\">// Apply edits</span>\n        <span style=\"color:Blue;\">var</span> prefix = <span style=\"color:Blue;\">this</span>.content.substring(0, minChar);\n        <span style=\"color:Blue;\">var</span> middle = newText;\n        <span style=\"color:Blue;\">var</span> suffix = <span style=\"color:Blue;\">this</span>.content.substring(limChar);\n        <span style=\"color:Blue;\">this</span>.setContent(prefix + middle + suffix);\n\n        <span style=\"color:Green;\">// Store edit range + new length of script</span>\n        <span style=\"color:Blue;\">this</span>.editRanges.push(\n            <span style=\"color:Blue;\">new</span> TypeScript.TextChangeRange(\n                TypeScript.TextSpan.fromBounds(minChar, limChar),\n                newText.length\n             )\n        );\n\n        <span style=\"color:Green;\">// Update version #</span>\n        <span style=\"color:Blue;\">this</span>.version++;\n    }\n\n    getTextChangeRangeBetweenVersions(startVersion: <span style=\"color:Blue;\">number</span>, endVersion: <span style=\"color:Blue;\">number</span>)  {\n        <span style=\"color:Blue;\">if</span> (startVersion === endVersion) {\n            <span style=\"color:Green;\">// No edits!</span>\n            <span style=\"color:Blue;\">return</span> TypeScript.TextChangeRange.unchanged;\n        }\n\n        <span style=\"color:Blue;\">var</span> initialEditRangeIndex = \n                <span style=\"color:Blue;\">this</span>.editRanges.length - (<span style=\"color:Blue;\">this</span>.version - startVersion);\n        <span style=\"color:Blue;\">var</span> lastEditRangeIndex = \n                <span style=\"color:Blue;\">this</span>.editRanges.length - (<span style=\"color:Blue;\">this</span>.version - endVersion);\n\n        <span style=\"color:Blue;\">var</span> entries = <span style=\"color:Blue;\">this</span>.editRanges.slice(\n            initialEditRangeIndex,\n            lastEditRangeIndex\n         );\n        <span style=\"color:Blue;\">if</span> (entries.length === 0) {\n            <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">null</span>;\n        }\n        <span style=\"color:Blue;\">return</span> TypeScript.TextChangeRange\n            .collapseChangesAcrossMultipleVersions(entries);\n    }\n}\n<span style=\"color:Blue;\">class</span> ScriptSnapshot <span style=\"color:Blue;\">implements</span> TypeScript.IScriptSnapshot {\n    <span style=\"color:Blue;\">private</span> scriptInfo: ScriptInfo;\n    <span style=\"color:Blue;\">private</span> lineMap: TypeScript.LineMap = <span style=\"color:Blue;\">null</span>;\n    <span style=\"color:Blue;\">private</span> textSnapshot: <span style=\"color:Blue;\">string</span>;\n    <span style=\"color:Blue;\">private</span> version: <span style=\"color:Blue;\">number</span>;\n\n    <span style=\"color:Blue;\">constructor</span>(scriptInfo: ScriptInfo) {\n        <span style=\"color:Blue;\">this</span>.scriptInfo = scriptInfo;\n        <span style=\"color:Blue;\">this</span>.textSnapshot = scriptInfo.content;\n        <span style=\"color:Blue;\">this</span>.version = scriptInfo.version;\n    }\n\n    getText(start: <span style=\"color:Blue;\">number</span>, end: <span style=\"color:Blue;\">number</span>): <span style=\"color:Blue;\">string</span> {\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>.textSnapshot.substring(start, end);\n    }\n\n    getLength(): <span style=\"color:Blue;\">number</span> {\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>.textSnapshot.length;\n    }\n\n    getLineStartPositions(): <span style=\"color:Blue;\">number</span>[] {\n        <span style=\"color:Blue;\">if</span> (<span style=\"color:Blue;\">this</span>.lineMap === <span style=\"color:Blue;\">null</span>) {\n            <span style=\"color:Blue;\">this</span>.lineMap = TypeScript.LineMap1.fromString(<span style=\"color:Blue;\">this</span>.textSnapshot);\n        }\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>.lineMap.lineStarts();\n    }\n\n    getTextChangeRangeSinceVersion(scriptVersion: <span style=\"color:Blue;\">number</span>): TypeScript.TextChangeRange {\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>.scriptInfo.getTextChangeRangeBetweenVersions(scriptVersion, <span style=\"color:Blue;\">this</span>.version);\n    }\n}\n \r\n</pre></div>",
    "PostedDate": "2014-04-16T16:17:07.78-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1235123",
    "ThreadId": "542469",
    "Html": "Hey there,\r<br />\n<br />\nI'm not seeing anything jumping out a obviously wrong.  One thing that might be an issue is 'updateContent'.  I've noticed when that is called that you clear our the array of edits.  Now, imagine the following sequence of events:\r<br />\n<br />\na) 3 edits.\r<br />\nb) 1 update.\r<br />\nc) 3 edits.\r<br />\n<br />\nWith your code as is, the array will be cleared out, and then will have 3 entries in it.  Now, let's say the LS asks for the changes between version 2 and version 6.  The slice in getTextRangeBetweenVersions will get the wrong text change and will end up borking things pretty badly.\r<br />\n<br />\nWhat you can do instead is copy the array of changes over whenever you make a new ScriptSnapshot.  That array's last element will correspond to the change that created that version of the script snapshot.   Then, when you ask for the changes between versions, you can verify that the array you have has enough changes in it to satisfy that request.  If it does, you can return the right value.  Otherwise, you can return null to indicate that you don't know the change, and that the LS should reparse the entire file.\r<br />\n<br />\nI hope that that helps!<br />\n<pre><code>      -- Cyrus </code></pre>\n\n",
    "PostedDate": "2014-04-17T10:16:32.477-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1235151",
    "ThreadId": "542469",
    "Html": "Thanks a lot for giving a look, I will try that.<br />\n",
    "PostedDate": "2014-04-17T11:19:21.19-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1235160",
    "ThreadId": "542469",
    "Html": "Great!\r<br />\n<br />\nAlso, i wanted to mention something explicitly (in case it wasn't clear).\r<br />\n<br />\nIf you ever end up doing one of your 'updateContent' operations, you are essentially saying &quot;i can no longer accurately determine the text change range <em>across</em> that version number&quot;.  i.e. if you do the updateContent on version 5, then any request that crosses version 5 will need to return 'null' to say &quot;i don't know what changed&quot;.  The TypeSCript LS will then be very conservative and will simply reparse the file entirely.<br />\n\r<br />\nWe recognize this is a complex part of the existing system, and we're working on a mechanism to make this simpler in the near future.<br />\n\r<br />\nFirst off, instead of passing you a version number to determine changes for, we will instead pass you the two ScriptSnapshot instances themselves.  If your editor can then efficiently determine the changes between these two versions, you can use that mechanism (for example in VisualStudio, we can use the ITextVersion data the editor stores to know <em>precisely</em> what changed between any two versions).\r<br />\n<br />\nSecond, we will possibly make this operation optional for the host (i.e. you).  And, if you don't provide it, we'll do a diff of the snapshots to figure out what we need to reparse.  This won't be as efficient as you just answering the question, but it may be good enough for your use cases.   And, if it turns out to be too slow, you can always swap in a more efficient implementation later.  In general, determining the set of changes between two documents of size A and B is O(AB).  However, we can make a few adjustments to make that much closer to linear while still providing great results on the types of edits that normally happen in a document. <br />\n",
    "PostedDate": "2014-04-17T11:51:46.583-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1235171",
    "ThreadId": "542469",
    "Html": "In fact your solution seems to work perfectly apparently this was the problem. Thanks a lot for your help, this bug gave me a big headache.  I now clone <code>editRanges</code> on the snapshot and return <code>null</code> if I have less ranges than asked by the compiler.<br />\n",
    "PostedDate": "2014-04-17T12:12:12.107-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]