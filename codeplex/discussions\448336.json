[
  {
    "Id": "1061665",
    "ThreadId": "448336",
    "Html": "TypeScript is a great leap forward and, IMHO, the best of breed when compared to other transpiled &quot;altJS&quot; languages like CoffeeScript, Traceur, Six, etc. I would love to see greater adoption, at least until ES6 becomes widely available, but it's still lagging far behind CoffeeScript (currently, 500 vs. 3500 related repos on GitHub).<br />\n<br />\nOne thing that I feel may be holding TypeScript back is general confusion around what the different module scenarios are, what compilation and post-compilation options are available and when they need to be used, and the conflicting module syntax required for each scenario and/or target environment.<br />\n<br />\nI've been working exclusively on large TypeScript libraries and applications since TypeScript was first announced last year. It took me <em>almost</em> that long to fully understand things. Here's what I finally concluded...<br />\n<br />\nI have identified 4 module scenarios below. The first two are directly supported by TypeScript. The second two are indirectly supported, requiring additional tools and/or boilerplate syntax.<br />\n<br />\n<strong>Module scenarios:</strong><br />\n<ol>\n<li>AMD</li>\n<li>CommonJS (e.g. Node)</li>\n<li>CommonJS for the browser</li>\n<li>\nUMD<br />\n</li>\n</ol>\n<strong>AMD</strong> modules must use the <code>--module AMD</code> compiler option, use <code>import module1 = require(&quot;./src/module1&quot;)</code> syntax for loading dependencies, and typically export symbols from an &quot;external&quot; module definition. These modules can only be used in an environment that supports <em>asynchronous</em> module loading via the <code>define</code> function, e.g. in the browser when using a third-party AMD loader such as RequireJS.<br />\n<br />\n<strong>CommonJS</strong> modules must use the <code>--module CommonJS</code> compiler option, also use <code>import module = require(&quot;./src/module1&quot;)</code> syntax for loading dependencies, and also typically export symbols from an &quot;external&quot; module definition. These modules can only be used in an environment that supports <em>synchronous</em> module loading via the <code>require</code> function, e.g. Node.<br />\n<br />\n<strong>CommonJS for the browser</strong> (using <code>require</code>) is only possible if a third-party post-compilation tool, such as <a href=\"http://browserify.org/\" rel=\"nofollow\">Browserify</a>, is used to bundle the main module and all of its dependencies into a single JS file. Alternatively, you can use <code>///&lt;reference/&gt;</code> syntax for dependencies, export global symbols from &quot;internal&quot; modules using <code>module Namespace</code> syntax, and then add the necessary script tag(s) to your HTML page, but that's not really AMD <em>or</em> CommonJS.<br />\n<br />\n<strong>UMD</strong> (Universal Module Definition) modules can use either <code>--module</code> compiler option (since it doesn't matter) plus the <code>--out</code> compiler option  to generate a single output file with  some <a href=\"https://github.com/umdjs/umd\" rel=\"nofollow\">UMD boilerplate</a> appended in order to target the appropriate AMD, CommonJS, or browser environment.<br />\n<br />\nMy point is this is all extremely confusing, not well understood by new or inexperienced TypeScript developers, and is not well explained or demonstrated in the TypeScript documentation.<br />\n<br />\n<strong>What's needed:</strong><br />\n<ol>\n<li>Comprehensive documentation and better code samples</li>\n<li>Eliminate the conflicting development requirements dictated by each scenario, e.g. <code>import</code> vs. <code>///&lt;reference/&gt;</code> syntax and &quot;internal&quot; vs. &quot;external&quot; module definitions</li>\n<li>\nProvide &quot;bundling&quot; capability in the TypeScript compiler, similar to what Browserify does, to allow CommonJS modules to work in the browser out-of-the-box<br />\n</li>\n</ol>\nAs a start for #1, I have created a <a href=\"https://github.com/billyzkid/typescript-modules\" rel=\"nofollow\">typescript-modules</a> repository that contains minimal sample code targeting each of the four module scenarios described above. Perhaps developers will find this useful as a starting point for their own apps/libraries, or to better understand the currently confusing situation.<br />\n<br />\nIf #2 and #3 are addressed, developers should no longer have to worry about how to code modules up front. Only use the <code>import</code> syntax for loading dependencies, and simply let compiler options dictate the correct output for each scenario. I believe this will go a long way toward increasing TypeScript adoption and alleviating the confusion.<br />\n",
    "PostedDate": "2013-06-26T13:55:16.05-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1061815",
    "ThreadId": "448336",
    "Html": "You can also use CommonJS on the browser through use of 3rd party libraries which handle the file loading while the app is running - using XMLHttpRequests or similar.<br />\n",
    "PostedDate": "2013-06-27T00:30:23.583-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1062038",
    "ThreadId": "448336",
    "Html": "@Griffork, that's true. You could implement a <code>require</code> function that uses a synchronous XMLHttpRequest under its hood. However, I understand this has serious drawbacks including load performance and cross-domain requests. Dojo used to do exactly this, and it ended up being the main reason why Dojo 1.7 was such a <em>major</em> refactor and why RequireJS was developed.<br />\n<br />\nBut that's besides the point, which is the current module story in TypeScript is too confusing, and I think it would do well to simplify things. I want to be able to write my modules/libraries/apps in <strong>one</strong> way, and then let the TypeScript compiler build the correct output for my target environment (AMD/browser, CommonJS/node, CommonJS/browser, etc.)<br />\n",
    "PostedDate": "2013-06-27T09:17:01.343-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1062949",
    "ThreadId": "448336",
    "Html": "@billyzkid, yes the module story is confusing.\r<br />\n<br />\nJust to be clear the second method that you mention under &quot;CommonJS for the browser&quot; goes like this:\r<br />\n<br />\n<strong>Foo.ts</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\nmodule foos {\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> Foo {\n    } \n}\r\n</pre></div><strong>Bar.ts</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">/// &lt;reference path=&quot;foo.ts&quot; /&gt;</span>\nmodule bars {\n    \n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> Bar {\n        <span style=\"color:Blue;\">public</span> value = <span style=\"color:Blue;\">new</span> foos.Foo(); \n    }\n}\r\n</pre></div>As you say this is neither AMD or CommonJS. Neither does it use Browserify (which only works on &quot;require&quot; calls). In short this is simply JavaScript code organised in separate files, with no dependencies on anything or any requirement to follow any conventions. This is the way we want it to be.\r<br />\n<br />\nThe files themselves are organised into separate TypeScript projects, so that we have the hierarchy:  Global &gt; Project &gt; File.ts, where there is one global and many projects, each of which contains many files. The Global is the final JavaScript file that is saved to the deployment folder; from there it is served up by the web server, for example: &quot;<a href=\"http://mydomain.com/scripts/global.js\" rel=\"nofollow\">http://mydomain.com/scripts/global.js</a>&quot;\r<br />\n<br />\nSo how is Global.js generated? \r<br />\n<br />\nWe use a bundling mechanism that in debug mode splits Global.js into its constituent files, while in release mode it generates a single minified bundle. The splitting up helps with debugging, while with the released file the browser need only make a single request. (For those familiar with ASP.Net 4.0, this bundling mechanism shouldn't really come as a surprise.)\r<br />\n<br />\nNow, I don't believe that TypeScript can or should get involved in the bundling mechanism, because TypeScript operates at the <strong><em>Project</em></strong> level while the bundling needs to occur at the <strong><em>Global</em></strong> level.\r<br />\n<br />\nWhat we would like to see is better support at the Project level, in particular the ability to reference entire projects, and replacing  the &lt;reference&gt; comment with import, but for namespaces, so that we may write:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\nmodule bars {\n\n    <span style=\"color:Blue;\">import</span> foos; <span style=\"color:Green;\">// Foo.ts is in the same project if not we reference the project in which it exists</span>\n    \n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> Bar {\n        <span style=\"color:Blue;\">public</span> value = <span style=\"color:Blue;\">new</span> Foo(); \n    }\n}\n\r\n</pre></div>I believe this is a common pattern for those developing for the web.\r<br />\n<br />\nNoel<br />\n",
    "PostedDate": "2013-06-30T10:22:11.483-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1062991",
    "ThreadId": "448336",
    "Html": "@nabog\r<br />\nDoesn't that mean that global.js has to be re-bundled for each unit test?\r<br />\nAlso, are you essentially saying that Typescript should cater for none of these, and should instead leave all implementation-specific features to a third party tool? Because I, for one, do not agree :).\r<br />\n<br />\nI do however agree greatly with @billyzkid's suggestions, I would love to see bundling done in the compiler, and the compiler import optimisations brought back, (where  an unused reference was optimised out).\r<br />\n<br />\nAlso I certainly agree that more documentation would be useful surrounding that issue, but I think that the documentation would probably be better done by third party sources (bloggers and such) rather than the Typescript team (since the more people who try to explain how something works, the more likely it is that people will find someone they can understand).<br />\n",
    "PostedDate": "2013-06-30T17:12:49.783-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1063086",
    "ThreadId": "448336",
    "Html": "@griffork, \r<br />\n<br />\nThe code files can be referenced individually for unit tests if necessary. If the unit tests are dependent on the framework within global.js then that is handled by the bundling mechanism. The ASP.Net bundler is not a bad implementation. It keeps track of the files that have changed and updates the bundle accordingly. For instance, we get sub second bundling performance over a code base of some 400 js files, when individual groups of files are rebuilt.\r<br />\n<br />\nJust to rephrase my point above:<br />\n<ul>\n<li>TypeScript should certainly consolidate the import syntax and do away with &lt;reference&gt; includes.</li>\n<li>\nWe also need to cater for the scenario I've sketched out above, which uses neither AMD or CommonJS, but where code is organised in <strong><em>Projects</em></strong> (I'm referring to Visual Studio projects, but one may think of them as folders on a file system). For this case, we need to be able to reference other projects and import namespaces from them.<br />\n</li>\n</ul>\nThis is looking beyond a small code base and at scalability: small website =&gt; A single project with multiple folders underneath. Larger website =&gt; Multiple projects, each with multiple folders underneath.\r<br />\n<br />\nMy point is that for TypeScript to effectively generate the bundle global.js it would need to span Projects - which it cannot do, because (in Visual Studio) each project is compiled individually. At what point can the bundling occur?<br />\n",
    "PostedDate": "2013-07-01T02:27:19.18-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1063699",
    "ThreadId": "448336",
    "Html": "@nabog - &quot;TypeScript should certainly consolidate the import syntax and do away with &lt;reference&gt; includes.&quot;\r<br />\n<br />\nWe (and I) worked through a few design iterations to see if I could consolidate import and &lt;reference&gt; a few months back when the design was still in flux.  Some of the things that came out of that:<br />\n<ul>\n<li>Reference and import are trying to do two different things.  With references you're saying &quot;trust me, I'll make these available at runtime&quot;.  With import, we're actually codegen'ing specific code for a style of module loading.  These two things are dissimilar enough that it'd likely be confusing to try to come up with a hybrid.</li>\n<li>\nGoing along with the first point, consolidation would mean that users would be forced to code in a particular style.  For example, if import was how we chose to consolidate, then users would have to learn module loading from the start and use it in every project.  Having a simpler &lt;reference&gt; gives people an easy way into getting started and the option to only use loadable modules when it makes sense for the project.<br />\n</li>\n</ul>\nI agree that it's extra cognitive load to have similar features.  In the end, it's a trade-off between complexity, compatibility, and an easy way to get started.<br />\n",
    "PostedDate": "2013-07-02T10:12:29.533-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1064024",
    "ThreadId": "448336",
    "Html": "I would say that if imports got tweaked the other way would be unnecessary.<br />\n<br />\nActually right now you can use imports just as &quot;declaration providers&quot; without codegening anything. It just works...<br />\n<br />\nUsers would not have to learn anything new. Actually there is a bonus of not having to understand two different ways of inclusion.<br />\nIn this case that kind of abstraction is already possible and very useful.<br />\n<br />\nThe only problem I see is the amount of code made at DefinititelyTyped which was written with ///&lt;reference syntax in mind. <br />\nThe reason was that imports weren't ready.. just as they still aren't fully ready.<br />\n",
    "PostedDate": "2013-07-03T03:37:50.65-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1065232",
    "ThreadId": "448336",
    "Html": "@jonturner, \r<br />\n<br />\nyes, references and imports are doing two different things.\r<br />\n<br />\nHowever, it shouldn't necessarily follow from that that nothing should be done about the problem.\r<br />\n<br />\nTypeScript has fundamentally altered how we think about JavaScript. In particular, it is now possible to design fairly complex architectures for a JavaScript platform - thanks to the compile-time safety, and language enhancements offered by TypeScript.\r<br />\n<br />\nWe have a new landscape that is different from the old. We no longer think about writing JavaScript per se, but writing TypeScript.\r<br />\n<br />\nSo in this climate the argument that we hear from the people behind TypeScript that &quot;there are certain JavaScript patterns that you can depend on&quot; comes from a rather redundant view of the world. With regard to this discussion, the &lt;reference&gt; include mechanism is a glaring throwback to the JavaScript past.  Conditional compilation directives such as #if(DEBUG) is another example where we need to think differently - we would like to see such constructs supported because the code base now demands it.\r<br />\n<br />\nOne possible solution to the &lt;reference&gt; problem is to permit a project level configuration file, possibly Config.json :<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n{\n    <span style=\"color:#A31515;\">&quot;reference&quot;</span>: <span style=\"color:#A31515;\">&quot;c:\\projects\\foo,  ...&quot;</span>\n}\r\n</pre></div>And since you point out that references and imports are not the same, a new keyword for importing types from the referenced projects:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\nmodule bars {\n\n    using foos; <span style=\"color:Green;\">// Okay if module foos exists in any .ts file under folder c:\\projects\\foo</span>\n    \n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">class</span> Bar {\n        <span style=\"color:Blue;\">public</span> value = <span style=\"color:Blue;\">new</span> Foo(); \n    }\n}\n\r\n</pre></div>With something like this in place, we should be able to scale out the code base with more confidence.\r<br />\n<br />\nTypeScript has enabled new things and we need new structures and tools to deal with them.<br />\n",
    "PostedDate": "2013-07-07T04:13:41.197-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1065272",
    "ThreadId": "448336",
    "Html": "\r\n<p dir=\"ltr\">In this vein, what I'd really like to see is a TypeScript project type, the output of which is a single (minified?) JavaScript file, on which a web project might take a dependency.</p>\r\n",
    "PostedDate": "2013-07-07T08:53:15.55-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1065382",
    "ThreadId": "448336",
    "Html": "Actually, I really like nabog's suggestion for a few reasons:<br />\n<ol>\n<li>\nReferenced files are available project-wide, which is a better representation of their behavior. At the moment the <code>///reference</code> files are only &quot;visible&quot; in any module that includes them either directly or via an include chain.<br />\n</li>\n<li>\nUsing makes it extremely obvious which files are actually using the reference, as it's difficult to tell if a file is using a reference if it's included via an include chain.<br />\n</li>\n<li>\nThe references file can be supplied along with the compiled JavaScript with comments to indicate which files and which versions of those files are used in the project, which would be <strong>invaluable</strong> since you would no longer need to look at the source code to determine what files need to be included.<br />\n</li>\n</ol>\nIt would solve almost all of the problems with using definitelytyped and external libraries or setting up someone else's project to run on your server.<br />\n<br />\nAt compile time (if you're converting to JavaScript with intellisense support) you can convert <code>using</code>s to <code>///reference path</code>s.<br />\n<br />\n<strong>edit:</strong><br />\n@nabog I presume your comment on the line <code>using foos;</code> is meant to refer to <strong>d.ts</strong> files?<br />\n",
    "PostedDate": "2013-07-07T18:53:39.173-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1070516",
    "ThreadId": "448336",
    "Html": "I could not agree more that the module subject is an obstacle for beginners. I introducted typescript in a new project and people almost rejected it because they got completly lost over modules, require, import and reference. So, I solved it by the codeing guideline: &quot;dont use import or the --module flag ever&quot;! This lowered the entrance learningcurve enormously.\r<br />\n<br />\nThe problem of loading, of course, remains. \r<br />\n<br />\nWhat do other languages do?<br />\n<ul>\n<li>c-languages: usually, there is an external tool (linker or dynamic linker) that links the dependencies together at compile time (or prepares them for dynamic linking)</li>\n<li>java: the build-in classloader is conceptually similar to commonjs and require.js  \r</li>\n<li>\nc#: sorry, am not the right guy to answer that ;)<br />\n</li>\n</ul>\nIn javascript, everybody can do what he likes and standardization is hard and tedious. Which is why I dont believe in AMD nor CommonJS. There is already tons of legacy and proprietary stuff out there using their own approaches. Since references are quite similar to c-type includes, why not staying on that track? All that is needed is the following proposed tool:<br />\n<ul>\n<li>For development mode: A tool, that checks at compiletime the dependencies declared as references (or using, I wouldnt care) and produces a loader script. This loader script is able to load all individual js files in an optimzed way (it could use requirejs for that). But the sources stay seperate and therefore are easy to debug.</li>\n<li>\nFor production mode: the v0.9 compiler's ability to pack everything into one file solves that already! However, problems start again if you want to build an application on several libraries. For that, the same approach like in dev-mode could be deployed.<br />\n</li>\n</ul>\n",
    "PostedDate": "2013-07-19T08:17:16.717-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1070649",
    "ThreadId": "448336",
    "Html": "@sapix - it sounds like your team had zero experience with modules (amd, commonjs) outside of typescript anyway, so their experience is entirely understandable. Setting up RequireJS (for example) in a browser is a real PITA and the first time you do it, you think you're doing it right and you're likely not. Without solid in-the-field experience of revealing module patterns with pure javascript, adding this technique to the cognitive load of taking on a new language is too much for most people. Additionally, if you're targeting browsers, it's probably not a good comparison to bring up java/c++ etc.; the browser introduces some pretty unique concepts. <br />\n",
    "PostedDate": "2013-07-19T13:13:51.137-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1071035",
    "ThreadId": "448336",
    "Html": "@oisin:<br />\nMaybe I wasnt clear. I am not interested in using AMD and many people arent't. But they get confused nevertheless in typescript because of it. My point was to make a suggestion that would make &quot;--module&quot;-free typescript development complete.<br />\n<br />\nAnd, btw, the comparisons look maybe a bit farfetchechd, but hey, doesnt java run in the browser and has features to load classes dynamically over the network at runtime? So, where exactly would you see the conceptual difference between the java classloader framework and requirejs again ;) ?<br />\n",
    "PostedDate": "2013-07-21T14:35:42.17-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1077060",
    "ThreadId": "448336",
    "Html": "Just getting into TS, and generally love it. So thanks to everyone who has expended energy to birth it. But this module thing is a sad state of affairs. Things should and can be much simpler. \r<br />\n<br />\nTelling compiler where type information is should be done outside of source files (get rid of &lt;reference&gt;), and should optionally specify module name to deal with namespace clashes. A 'ts.refs' file with something like:\r<br />\n<br />\n&lt;moduleName&gt;=&lt;path/to/.ts&gt; or\r<br />\n&lt;moduleName&gt;=&lt;path/to/.d.ts&gt;=&lt;path/to/.js&gt;\r<br />\n<br />\nexpress=./d.ts/express.d.ts                         <br />\n./lib/logger.ts                                                       // default module name 'logger'\r<br />\nclashLogger=./3rdparty/logger.ts                  // override default module name 'logger' with 'clashLogger'\r<br />\noldJs=./d.ts/oldJs.d.ts=./vendor/oldJs.js\r<br />\n<br />\nthen in .ts's\r<br />\n<br />\nimport express;                                                 // outputs &quot;var express = require( 'express' );&quot;\r<br />\nimport ex = express;                                       // outputs &quot;var ex = require( 'express' );&quot;\r<br />\nimport logger;                                                    // outputs &quot;var logger = require( './lib/logger' );&quot;\r<br />\nimport clashLogger;                                        // outputs &quot;var clashLogger = require( './3rdparty/logger' );&quot;\r<br />\nimport oldJs;                                                     // outputs &quot;var oldJs = require( './vendor/oldJs.js' );&quot; or &quot; define( 'myMod', [ 'oldJs' ], funct... ) &quot;<br />\n",
    "PostedDate": "2013-08-05T21:39:18.957-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]