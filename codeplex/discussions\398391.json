[
  {
    "Id": "923137",
    "ThreadId": "398391",
    "Html": "\r\n<p>There's been a bit of talk on the forums around supporting mixins in TypeScript and with the 0.8 drop you have to use interfaces to achieve this.&nbsp; I wanted to see if I could streamline the process of defining mixins a bit and what I ended up creating\r\n is a base class that add support for not only defining mixins but also c# like attributes.&nbsp; Copy the code below into the playground and run it to see that it works:</p>\r\n<p><strong>update: see&nbsp;the simplified approach to mixins that I posted a few messages down.</strong></p>\r\n<div style=\"background-color:white; color:black\">\r\n<pre><span style=\"color:green\">// Base class &amp; interfaces for supporting attributes &amp; mixins</span>\r\n<span style=\"color:blue\">class</span> ObjectBase {\r\n    constructor () {\r\n        <span style=\"color:green\">// Invoke attributes</span>\r\n        <span style=\"color:blue\">var</span> _constructor = (&lt;any&gt;<span style=\"color:blue\">this</span>).constructor;\r\n        <span style=\"color:blue\">if</span> (_constructor.__attributes__) {\r\n            <span style=\"color:blue\">for</span> (<span style=\"color:blue\">var</span> i = 0, l = _constructor.__attributes__.length; i &lt; l; i&#43;&#43;) {\r\n                <span style=\"color:blue\">var</span> _attribute = _constructor.__attributes__[i];\r\n                <span style=\"color:blue\">if</span> (_attribute.onCreated) {\r\n                    _attribute.onCreated(<span style=\"color:blue\">this</span>);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    <span style=\"color:green\">// Static methods</span>\r\n\r\n    <span style=\"color:blue\">static</span> attribute(type: <span style=\"color:blue\">new</span> () =&gt; ObjectBase, attribute: IAttribute): <span style=\"color:blue\">void</span> {\r\n        <span style=\"color:blue\">if</span> (!(&lt;any&gt;type).__attributes__) {\r\n            (&lt;any&gt;type).__attributes__ = [];\r\n        }\r\n        (&lt;any&gt;type).__attributes__.push(attribute);\r\n    }\r\n\r\n    <span style=\"color:blue\">static</span> hasAttribute(obj: any, attribute: <span style=\"color:blue\">new</span> () =&gt; IAttribute): bool {\r\n        <span style=\"color:blue\">var</span> _constructor = (&lt;any&gt;obj).constructor;\r\n        <span style=\"color:blue\">if</span> (_constructor.__attributes__) {\r\n            <span style=\"color:blue\">for</span> (<span style=\"color:blue\">var</span> i = 0, l = _constructor.__attributes__.length; i &lt; l; i&#43;&#43;) {\r\n                <span style=\"color:blue\">if</span> (_constructor.__attributes__[i] <span style=\"color:blue\">instanceof</span> attribute) {\r\n                    <span style=\"color:blue\">return</span> <span style=\"color:blue\">true</span>;\r\n                }\r\n            }\r\n        }\r\n        <span style=\"color:blue\">return</span> <span style=\"color:blue\">false</span>;\r\n    }\r\n\r\n    <span style=\"color:blue\">static</span> mixin(type: <span style=\"color:blue\">new</span> () =&gt; ObjectBase, mixin: IMixin): <span style=\"color:blue\">void</span> {\r\n        mixin.extend(type.prototype);\r\n        <span style=\"color:blue\">if</span> (mixin.onCreated) {\r\n            attribute(type, mixin);\r\n        }\r\n    }\r\n}\r\n\r\n<span style=\"color:blue\">interface</span> IAttribute {\r\n    onCreated? (obj: any): <span style=\"color:blue\">void</span>;\r\n}\r\n\r\n<span style=\"color:blue\">interface</span> IMixin <span style=\"color:blue\">extends</span> IAttribute {\r\n    extend(prototype: any): <span style=\"color:blue\">void</span>;\r\n}\r\n\r\n<span style=\"color:green\">// Example attribute pre-binds callback methods to objects this pointer</span>\r\n\r\n<span style=\"color:blue\">class</span> CallbacksAttribute <span style=\"color:blue\">implements</span> IAttribute {\r\n    constructor (<span style=\"color:blue\">private</span> prefix: string) {\r\n    }\r\n\r\n    <span style=\"color:blue\">public</span> onCreated(obj: any): <span style=\"color:blue\">void</span> {\r\n        <span style=\"color:blue\">var</span> _constructor = obj.constructor; \r\n        <span style=\"color:blue\">if</span> (!_constructor.__cb__) { \r\n            _constructor.__cb__ = {}; \r\n            <span style=\"color:blue\">for</span> (<span style=\"color:blue\">var</span> m <span style=\"color:blue\">in</span> obj) { \r\n                <span style=\"color:blue\">var</span> fn = obj[m]; \r\n                <span style=\"color:blue\">if</span> (<span style=\"color:blue\">typeof</span> fn === <span style=\"color:#a31515\">'function'</span> &amp;&amp; m.indexOf(<span style=\"color:blue\">this</span>.prefix) == 0) { \r\n                    _constructor.__cb__[m] = fn;                     \r\n                } \r\n            } \r\n        } \r\n        <span style=\"color:blue\">for</span> (<span style=\"color:blue\">var</span> m <span style=\"color:blue\">in</span> _constructor.__cb__) { \r\n            (<span style=\"color:blue\">function</span> (m, fn) { \r\n                obj[m] = <span style=\"color:blue\">function</span> () { \r\n                    <span style=\"color:blue\">return</span> fn.apply(obj, Array.prototype.slice.call(arguments));                       \r\n                }; \r\n            })(m, _constructor.__cb__[m]); \r\n        } \r\n    }\r\n\r\n    <span style=\"color:blue\">static</span> addTo(type: <span style=\"color:blue\">new</span> () =&gt; ObjectBase, prefix = <span style=\"color:#a31515\">'cb_'</span>): <span style=\"color:blue\">void</span> {\r\n        <span style=\"color:blue\">if</span> (!(prefix <span style=\"color:blue\">in</span> cache)) {\r\n            cache[prefix] = <span style=\"color:blue\">new</span> CallbacksAttribute(prefix);\r\n        }\r\n        ObjectBase.attribute(type, cache[prefix]);\r\n    }\r\n\t<span style=\"color:blue\">static</span> cache: { [x: string]: CallbacksAttribute; } = {};\r\n}\r\n\r\n<span style=\"color:green\">// Example mixin makes objects disposable</span>\r\n\r\n<span style=\"color:blue\">interface</span> IDisposable {\r\n\tdispose (): <span style=\"color:blue\">void</span>;\r\n\tisDisposed (): bool;\r\n}\r\n\r\n<span style=\"color:blue\">class</span> DisposableMixin <span style=\"color:blue\">implements</span> IMixin {\r\n    <span style=\"color:blue\">public</span> extend(prototype: IDisposable): <span style=\"color:blue\">void</span> {\r\n        prototype.dispose = <span style=\"color:blue\">function</span> (): <span style=\"color:blue\">void</span> {\r\n            <span style=\"color:blue\">if</span> (!<span style=\"color:blue\">this</span>._isDisposed) {\r\n                <span style=\"color:blue\">this</span>._isDisposed = <span style=\"color:blue\">true</span>;\r\n                <span style=\"color:blue\">if</span> (<span style=\"color:blue\">this</span>.onDispose) {\r\n                    <span style=\"color:blue\">this</span>.onDispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        prototype.isDisposed = <span style=\"color:blue\">function</span> (): bool {\r\n            <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>._isDisposed;\r\n        }\r\n    }\r\n\r\n    <span style=\"color:blue\">public</span> onCreated(obj: any): <span style=\"color:blue\">void</span> {\r\n        obj._isDisposed = <span style=\"color:blue\">false</span>;\r\n    }\r\n\r\n    <span style=\"color:blue\">static</span> addTo(type: <span style=\"color:blue\">new</span> () =&gt; ObjectBase): <span style=\"color:blue\">void</span> {\r\n        <span style=\"color:blue\">if</span> (!mixin) {\r\n            mixin = <span style=\"color:blue\">new</span> DisposableMixin();\r\n        }\r\n        ObjectBase.mixin(type, mixin);\r\n    }\r\n\t<span style=\"color:blue\">static</span> mixin: DisposableMixin = <span style=\"color:blue\">null</span>; \r\n}\r\n\r\n\r\n<span style=\"color:green\">// Example attribute usage</span>\r\n\r\n<span style=\"color:blue\">class</span> Foo <span style=\"color:blue\">extends</span> ObjectBase {\r\n\t<span style=\"color:blue\">private</span> msg = <span style=\"color:#a31515\">'callback invoked'</span>;\r\n\t\r\n\t<span style=\"color:blue\">public</span> cb_test(): <span style=\"color:blue\">void</span> {\r\n\t\talert(<span style=\"color:blue\">this</span>.msg);\r\n\t}\r\n}\r\nCallbacksAttribute.addTo(Foo);\r\n\r\n<span style=\"color:blue\">var</span> foo = <span style=\"color:blue\">new</span> Foo();\r\nfoo.cb_test.call(window);\r\n\r\n<span style=\"color:green\">// Example mixin usage</span>\r\n\r\n<span style=\"color:blue\">class</span> Bar <span style=\"color:blue\">extends</span> ObjectBase {\r\n\t<span style=\"color:blue\">public</span> test() {\r\n\t\t\r\n\t}\r\n\t\r\n\t<span style=\"color:blue\">private</span> onDispose(): <span style=\"color:blue\">void</span> {\r\n\t\talert(<span style=\"color:#a31515\">'object disposed'</span>);\r\n\t}\r\n\t\r\n\t<span style=\"color:blue\">static</span> create(): IBar {\r\n\t\t<span style=\"color:blue\">return</span> &lt;any&gt; <span style=\"color:blue\">new</span> Bar();\r\n\t}\r\n}\r\nDisposableMixin.addTo(Bar);\r\n\r\n<span style=\"color:green\">// With mixins you need to use interfaces to represent your class</span>\r\n<span style=\"color:blue\">interface</span> IBar <span style=\"color:blue\">extends</span> IDisposable {\r\n\ttest();\r\n}\r\n\r\n<span style=\"color:blue\">var</span> bar = Bar.create();\r\nbar.dispose();\r\n\r\n</pre>\r\n</div>\r\n",
    "PostedDate": "2012-10-07T12:44:48.32-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923138",
    "ThreadId": "398391",
    "Html": "\r\n<p>Breaking down how the code above works... Mixins &amp; attributes get hung off your class as a static array of objects that will be walked anytime a new instance of your class is created.&nbsp; If the attribute/mixin implements an onCreated() method it will\r\n be called with the instance of the newly created object.&nbsp; This gives your attribute/mixin an opportunity to do something to the newly created object.&nbsp; In the CallbacksAttribute what I'm doing is walking the objects methods and binding any method\r\n starting with 'cb_' to its 'this' pointer.&nbsp; Basically you can't call that method accidentally in any other context which is ideal for callbacks.&nbsp;</p>\r\n<p>For mixins there's an added extend() method.&nbsp; When you add the mixin to a class the extend() method is called with the classes prototype so that the additional methods can be added to the class.&nbsp; What's nice about this approach over other mixin\r\n system is that we can use TypeScript to strongly type the prototype and we can validate that we're wiring up the right set of extensons.&nbsp;&nbsp;At create time the mixin acts like an attribute and the mixin can optionally register an onCreated() method\r\n that should be called anytime a new instance of the class is created.&nbsp; This essentially lets the mixin hook into the constructor for every class its attached to.&nbsp;</p>\r\n",
    "PostedDate": "2012-10-07T12:55:30.76-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923664",
    "ThreadId": "398391",
    "Html": "<p>All we need is language level support for this and to have this info available in the AST also, not just runtime. I opened a discussion about this here.</p>",
    "PostedDate": "2012-10-08T13:17:07.91-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923761",
    "ThreadId": "398391",
    "Html": "<p>For mixins, I wasn't crazy about the need to redefine your class as a seperate interface that you then had to pass around everywhere, so I've come up with an alternative approach to describing mixins.&nbsp; It's still kind of crappy but now slightly less crappy.</p>\r\n<p>In the example below everything is basically the same as my original code but I've changed the may I describe the interfaces for a mixin.&nbsp; No I'm describing my mixin as all properties, even the methods.&nbsp; This lets you update your class to say it implements the mixin interface and while you need to add the definitions for all of your mixins properties to your class you don't actually need to provide any implementation.&nbsp; From TypeScripts perspective, it's fine with the value of these properties being set externally (which is what happens when you add in the mixin) and if you look at the generated code you see that all of these additional property declerations boil out so they have no added overhead.</p>\r\n<p>It sucks that you have to manually declare all of your mixins methods as properties of your class but all things considered this&nbsp;adds zero added overhead to the generated output and seems to be the simplest approach to supporting mixins in the current drop of TypeScript.</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: green;\">// Base class &amp; interfaces for supporting attributes &amp; mixins</span>\r\n<span style=\"color: blue;\">class</span> ObjectBase {\r\n    constructor () {\r\n        <span style=\"color: green;\">// Invoke attributes</span>\r\n        <span style=\"color: blue;\">var</span> _constructor = (&lt;any&gt;<span style=\"color: blue;\">this</span>).constructor;\r\n        <span style=\"color: blue;\">if</span> (_constructor.__attributes__) {\r\n            <span style=\"color: blue;\">for</span> (<span style=\"color: blue;\">var</span> i = 0, l = _constructor.__attributes__.length; i &lt; l; i++) {\r\n                <span style=\"color: blue;\">var</span> _attribute = _constructor.__attributes__[i];\r\n                <span style=\"color: blue;\">if</span> (_attribute.onCreated) {\r\n                    _attribute.onCreated(<span style=\"color: blue;\">this</span>);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    <span style=\"color: green;\">// Static methods</span>\r\n\r\n    <span style=\"color: blue;\">static</span> attribute(type: <span style=\"color: blue;\">new</span> () =&gt; ObjectBase, attribute: IAttribute): <span style=\"color: blue;\">void</span> {\r\n        <span style=\"color: blue;\">if</span> (!(&lt;any&gt;type).__attributes__) {\r\n            (&lt;any&gt;type).__attributes__ = [];\r\n        }\r\n        (&lt;any&gt;type).__attributes__.push(attribute);\r\n    }\r\n\r\n    <span style=\"color: blue;\">static</span> hasAttribute(obj: any, attribute: <span style=\"color: blue;\">new</span> () =&gt; IAttribute): bool {\r\n        <span style=\"color: blue;\">var</span> _constructor = (&lt;any&gt;obj).constructor;\r\n        <span style=\"color: blue;\">if</span> (_constructor.__attributes__) {\r\n            <span style=\"color: blue;\">for</span> (<span style=\"color: blue;\">var</span> i = 0, l = _constructor.__attributes__.length; i &lt; l; i++) {\r\n                <span style=\"color: blue;\">if</span> (_constructor.__attributes__[i] <span style=\"color: blue;\">instanceof</span> attribute) {\r\n                    <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">true</span>;\r\n                }\r\n            }\r\n        }\r\n        <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">false</span>;\r\n    }\r\n\r\n    <span style=\"color: blue;\">static</span> mixin(type: <span style=\"color: blue;\">new</span> () =&gt; ObjectBase, mixin: IMixin): <span style=\"color: blue;\">void</span> {\r\n        mixin.extend(type.prototype);\r\n        <span style=\"color: blue;\">if</span> (mixin.onCreated) {\r\n            attribute(type, mixin);\r\n        }\r\n    }\r\n}\r\n\r\n<span style=\"color: blue;\">interface</span> IAttribute {\r\n    onCreated? (obj: any): <span style=\"color: blue;\">void</span>;\r\n}\r\n\r\n<span style=\"color: blue;\">interface</span> IMixin <span style=\"color: blue;\">extends</span> IAttribute {\r\n    extend(prototype: any): <span style=\"color: blue;\">void</span>;\r\n}\r\n\r\n<span style=\"color: green;\">// Example attribute pre-binds callback methods to objects this pointer</span>\r\n\r\n<span style=\"color: blue;\">class</span> CallbacksAttribute <span style=\"color: blue;\">implements</span> IAttribute {\r\n    constructor (<span style=\"color: blue;\">private</span> prefix: string) {\r\n    }\r\n\r\n    <span style=\"color: blue;\">public</span> onCreated(obj: any): <span style=\"color: blue;\">void</span> {\r\n        <span style=\"color: blue;\">var</span> _constructor = obj.constructor; \r\n        <span style=\"color: blue;\">if</span> (!_constructor.__cb__) { \r\n            _constructor.__cb__ = {}; \r\n            <span style=\"color: blue;\">for</span> (<span style=\"color: blue;\">var</span> m <span style=\"color: blue;\">in</span> obj) { \r\n                <span style=\"color: blue;\">var</span> fn = obj[m]; \r\n                <span style=\"color: blue;\">if</span> (<span style=\"color: blue;\">typeof</span> fn === <span style=\"color: #a31515;\">'function'</span> &amp;&amp; m.indexOf(<span style=\"color: blue;\">this</span>.prefix) == 0) { \r\n                    _constructor.__cb__[m] = fn;                     \r\n                } \r\n            } \r\n        } \r\n        <span style=\"color: blue;\">for</span> (<span style=\"color: blue;\">var</span> m <span style=\"color: blue;\">in</span> _constructor.__cb__) { \r\n            (<span style=\"color: blue;\">function</span> (m, fn) { \r\n                obj[m] = <span style=\"color: blue;\">function</span> () { \r\n                    <span style=\"color: blue;\">return</span> fn.apply(obj, Array.prototype.slice.call(arguments));                       \r\n                }; \r\n            })(m, _constructor.__cb__[m]); \r\n        } \r\n    }\r\n\r\n    <span style=\"color: blue;\">static</span> addTo(type: <span style=\"color: blue;\">new</span> () =&gt; ObjectBase, prefix = <span style=\"color: #a31515;\">'cb_'</span>): <span style=\"color: blue;\">void</span> {\r\n        <span style=\"color: blue;\">if</span> (!(prefix <span style=\"color: blue;\">in</span> cache)) {\r\n            cache[prefix] = <span style=\"color: blue;\">new</span> CallbacksAttribute(prefix);\r\n        }\r\n        ObjectBase.attribute(type, cache[prefix]);\r\n    }\r\n\t<span style=\"color: blue;\">static</span> cache: { [x: string]: CallbacksAttribute; } = {};\r\n}\r\n\r\n<span style=\"color: green;\">// Example mixin makes objects disposable</span>\r\n\r\n<span style=\"color: blue;\">interface</span> IDisposable {\r\n\tdispose: ()=&gt; <span style=\"color: blue;\">void</span>;\r\n\tisDisposed: () =&gt; bool;\r\n}\r\n\r\n<span style=\"color: blue;\">class</span> DisposableMixin <span style=\"color: blue;\">implements</span> IMixin {\r\n    <span style=\"color: blue;\">public</span> extend(prototype: IDisposable): <span style=\"color: blue;\">void</span> {\r\n        prototype.dispose = <span style=\"color: blue;\">function</span> (): <span style=\"color: blue;\">void</span> {\r\n            <span style=\"color: blue;\">if</span> (!<span style=\"color: blue;\">this</span>._isDisposed) {\r\n                <span style=\"color: blue;\">this</span>._isDisposed = <span style=\"color: blue;\">true</span>;\r\n                <span style=\"color: blue;\">if</span> (<span style=\"color: blue;\">this</span>.onDispose) {\r\n                    <span style=\"color: blue;\">this</span>.onDispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        prototype.isDisposed = <span style=\"color: blue;\">function</span> (): bool {\r\n            <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span>._isDisposed;\r\n        }\r\n    }\r\n\r\n    <span style=\"color: blue;\">public</span> onCreated(obj: any): <span style=\"color: blue;\">void</span> {\r\n        obj._isDisposed = <span style=\"color: blue;\">false</span>;\r\n    }\r\n\r\n    <span style=\"color: blue;\">static</span> addTo(type: <span style=\"color: blue;\">new</span> () =&gt; ObjectBase): <span style=\"color: blue;\">void</span> {\r\n        <span style=\"color: blue;\">if</span> (!mixin) {\r\n            mixin = <span style=\"color: blue;\">new</span> DisposableMixin();\r\n        }\r\n        ObjectBase.mixin(type, mixin);\r\n    }\r\n\t<span style=\"color: blue;\">static</span> mixin: DisposableMixin = <span style=\"color: blue;\">null</span>; \r\n}\r\n\r\n\r\n<span style=\"color: green;\">// Example attribute usage</span>\r\n\r\n<span style=\"color: blue;\">class</span> Foo <span style=\"color: blue;\">extends</span> ObjectBase {\r\n\t<span style=\"color: blue;\">private</span> msg = <span style=\"color: #a31515;\">'callback invoked'</span>;\r\n\t\r\n\t<span style=\"color: blue;\">public</span> cb_test(): <span style=\"color: blue;\">void</span> {\r\n\t\talert(<span style=\"color: blue;\">this</span>.msg);\r\n\t}\r\n}\r\nCallbacksAttribute.addTo(Foo);\r\n\r\n<span style=\"color: blue;\">var</span> foo = <span style=\"color: blue;\">new</span> Foo();\r\nfoo.cb_test.call(window);\r\n\r\n<span style=\"color: green;\">// Example mixin usage</span>\r\n\r\n<span style=\"color: blue;\">class</span> Bar <span style=\"color: blue;\">extends</span> ObjectBase <span style=\"color: blue;\">implements</span> IDisposable {\r\n\t<span style=\"color: green;\">// IDisposable mixin</span>\r\n\t<span style=\"color: blue;\">public</span> dispose: () =&gt; <span style=\"color: blue;\">void</span>;\r\n\t<span style=\"color: blue;\">public</span> isDisposed: () =&gt; bool;\r\n\r\n\t<span style=\"color: blue;\">public</span> test() {\r\n\t\t\r\n\t}\r\n\t\r\n\t<span style=\"color: blue;\">private</span> onDispose(): <span style=\"color: blue;\">void</span> {\r\n\t\talert(<span style=\"color: #a31515;\">'object disposed'</span>);\r\n\t}\r\n}\r\nDisposableMixin.addTo(Bar);\r\n\r\n<span style=\"color: blue;\">var</span> bar = <span style=\"color: blue;\">new</span> Bar();\r\nbar.dispose();\r\n\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-10-08T19:01:01.48-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923790",
    "ThreadId": "398391",
    "Html": "<p>Method syntax and property syntax are equivalent in TypeScript. You can replace methods as easily as you can properties. The advantage of property syntax is that you don't need to fake up an implementation and it's obvious that you haven't supplied one when you look at the code, but you don't have to use property syntax if you don't want to.</p>\r\n<p><span></span></p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">class</span> methodsCanBeReplaced {\r\n&nbsp; &nbsp; method() { }\r\n}\r\n\r\nmethodsCanBeReplaced.prototype.method = () =&gt; alert(<span style=\"color: #a31515;\">'blah'</span>);\r\n\r\n<span style=\"color: blue;\">var</span> proof = <span style=\"color: blue;\">new</span> methodsCanBeReplaced();\r\n\r\nproof.method();\r\n\r\n\r\n</pre>\r\n</div>\r\n<div><span><br /></span></div>",
    "PostedDate": "2012-10-08T21:25:53.257-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "924164",
    "ThreadId": "398391",
    "Html": "\r\n<p>Yes, either one can be overriden but I was recommending the use of properties because they don't result in any additional JavaScript being generated.&nbsp; If you use methods you'll have to stub them out with default implementations which will bloat your\r\n output code.</p>\r\n",
    "PostedDate": "2012-10-09T10:54:18.53-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "924721",
    "ThreadId": "398391",
    "Html": "<p>By slightly modifying the addTo methods to return the attribute, we could have the attributes actually specified within the class, which feels cleaner. This does expose the __attributes__ field, though.</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">class</span> Foo extends ObjectBase {\r\n\t<span style=\"color: blue;\">static</span> __attributes__ = [ CallbacksAttribute.addTo(Foo) ];\r\n\t<span style=\"color: blue;\">private</span> msg = <span style=\"color: #a31515;\">'callback invoked'</span>;\r\n\t\r\n\t<span style=\"color: blue;\">public</span> cb_test(): <span style=\"color: blue;\">void</span> {\r\n\t\talert(<span style=\"color: blue;\">this</span>.msg);\r\n\t}\r\n}\r\n</pre>\r\n</div>",
    "PostedDate": "2012-10-10T08:20:42.38-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "924851",
    "ThreadId": "398391",
    "Html": "<p>If you're going to do that I'd probably do some other simplifications.&nbsp; I'd call the field 'attributes' instead of '__attributes__', then I'd&nbsp;apply the attribute as a function call, and then&nbsp;eliminate the helper routines from ObjectBase. Here's the revised example:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: green;\">// Base class &amp; interfaces for supporting attributes &amp; mixins</span>\r\n<span style=\"color: blue;\">class</span> ObjectBase {\r\n    constructor () {\r\n        <span style=\"color: green;\">// Invoke attributes</span>\r\n        <span style=\"color: blue;\">var</span> _constructor = (&lt;any&gt;<span style=\"color: blue;\">this</span>).constructor;\r\n        <span style=\"color: blue;\">if</span> (_constructor.attributes) {\r\n            <span style=\"color: blue;\">for</span> (<span style=\"color: blue;\">var</span> i = 0, l = _constructor.attributes.length; i &lt; l; i++) {\r\n                <span style=\"color: blue;\">var</span> _attribute = _constructor.attributes[i];\r\n                <span style=\"color: blue;\">if</span> (_attribute.onCreated) {\r\n                    _attribute.onCreated(<span style=\"color: blue;\">this</span>);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n<span style=\"color: blue;\">interface</span> IAttribute {\r\n    onCreated? (obj: any): <span style=\"color: blue;\">void</span>;\r\n}\r\n\r\n<span style=\"color: green;\">// Example attribute pre-binds callback methods to objects this pointer</span>\r\n\r\n<span style=\"color: blue;\">class</span> CallbacksAttribute <span style=\"color: blue;\">implements</span> IAttribute {\r\n    constructor (<span style=\"color: blue;\">private</span> prefix: string) {\r\n    }\r\n\r\n    <span style=\"color: blue;\">public</span> onCreated(obj: any): <span style=\"color: blue;\">void</span> {\r\n        <span style=\"color: blue;\">var</span> _constructor = obj.constructor; \r\n        <span style=\"color: blue;\">if</span> (!_constructor.__cb__) { \r\n            _constructor.__cb__ = {}; \r\n            <span style=\"color: blue;\">for</span> (<span style=\"color: blue;\">var</span> m <span style=\"color: blue;\">in</span> obj) { \r\n                <span style=\"color: blue;\">var</span> fn = obj[m]; \r\n                <span style=\"color: blue;\">if</span> (<span style=\"color: blue;\">typeof</span> fn === <span style=\"color: #a31515;\">'function'</span> &amp;&amp; m.indexOf(<span style=\"color: blue;\">this</span>.prefix) == 0) { \r\n                    _constructor.__cb__[m] = fn;                     \r\n                } \r\n            } \r\n        } \r\n        <span style=\"color: blue;\">for</span> (<span style=\"color: blue;\">var</span> m <span style=\"color: blue;\">in</span> _constructor.__cb__) { \r\n            (<span style=\"color: blue;\">function</span> (m, fn) { \r\n                obj[m] = <span style=\"color: blue;\">function</span> () { \r\n                    <span style=\"color: blue;\">return</span> fn.apply(obj, Array.prototype.slice.call(arguments));                       \r\n                }; \r\n            })(m, _constructor.__cb__[m]); \r\n        } \r\n    }\r\n\t<span style=\"color: blue;\">static</span> cache: { [x: string]: CallbacksAttribute; } = {};\r\n}\r\n\r\n<span style=\"color: blue;\">function</span> callbacksAttribute(type: <span style=\"color: blue;\">new</span> () =&gt; ObjectBase, prefix = <span style=\"color: #a31515;\">'cb_'</span>): IAttribute {\r\n\t<span style=\"color: blue;\">var</span> cache = CallbacksAttribute.cache;\r\n    <span style=\"color: blue;\">if</span> (!(prefix <span style=\"color: blue;\">in</span> cache)) {\r\n        cache[prefix] = <span style=\"color: blue;\">new</span> CallbacksAttribute(prefix);\r\n    }\r\n\t<span style=\"color: blue;\">return</span> cache[prefix];\r\n}\r\n\r\n<span style=\"color: green;\">// Example mixin makes objects disposable</span>\r\n\r\n<span style=\"color: blue;\">interface</span> IDisposable {\r\n\tdispose: ()=&gt; <span style=\"color: blue;\">void</span>;\r\n\tisDisposed: () =&gt; bool;\r\n}\r\n\r\n<span style=\"color: blue;\">class</span> DisposableMixin <span style=\"color: blue;\">implements</span> IAttribute {\r\n    <span style=\"color: blue;\">public</span> extend(prototype: IDisposable): <span style=\"color: blue;\">void</span> {\r\n        prototype.dispose = <span style=\"color: blue;\">function</span> (): <span style=\"color: blue;\">void</span> {\r\n            <span style=\"color: blue;\">if</span> (!<span style=\"color: blue;\">this</span>._isDisposed) {\r\n                <span style=\"color: blue;\">this</span>._isDisposed = <span style=\"color: blue;\">true</span>;\r\n                <span style=\"color: blue;\">if</span> (<span style=\"color: blue;\">this</span>.onDispose) {\r\n                    <span style=\"color: blue;\">this</span>.onDispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        prototype.isDisposed = <span style=\"color: blue;\">function</span> (): bool {\r\n            <span style=\"color: blue;\">return</span> <span style=\"color: blue;\">this</span>._isDisposed;\r\n        }\r\n    }\r\n\r\n    <span style=\"color: blue;\">public</span> onCreated(obj: any): <span style=\"color: blue;\">void</span> {\r\n        obj._isDisposed = <span style=\"color: blue;\">false</span>;\r\n    }\r\n\r\n\t<span style=\"color: blue;\">static</span> cache: DisposableMixin = <span style=\"color: blue;\">null</span>; \r\n}\r\n\r\n<span style=\"color: blue;\">function</span> disposableMixin(type: <span style=\"color: blue;\">new</span> () =&gt; ObjectBase): IAttribute {\r\n\t<span style=\"color: blue;\">var</span> mixin = DisposableMixin.cache;\r\n    <span style=\"color: blue;\">if</span> (!mixin) {\r\n        mixin = DisposableMixin.cache = <span style=\"color: blue;\">new</span> DisposableMixin();\r\n    }\r\n\tmixin.extend(type.prototype);\r\n\t<span style=\"color: blue;\">return</span> mixin;\r\n}\r\n\r\n<span style=\"color: green;\">// Example attribute usage</span>\r\n\r\n<span style=\"color: blue;\">class</span> Foo <span style=\"color: blue;\">extends</span> ObjectBase {\r\n\t<span style=\"color: blue;\">static</span> attributes = [callbacksAttribute(Foo)];\r\n\r\n\t<span style=\"color: blue;\">private</span> msg = <span style=\"color: #a31515;\">'callback invoked'</span>;\r\n\t\r\n\t<span style=\"color: blue;\">public</span> cb_test(): <span style=\"color: blue;\">void</span> {\r\n\t\talert(<span style=\"color: blue;\">this</span>.msg);\r\n\t}\r\n}\r\n\r\n<span style=\"color: blue;\">var</span> foo = <span style=\"color: blue;\">new</span> Foo();\r\nfoo.cb_test.call(window);\r\n\r\n<span style=\"color: green;\">// Example mixin usage</span>\r\n\r\n<span style=\"color: blue;\">class</span> Bar <span style=\"color: blue;\">extends</span> ObjectBase <span style=\"color: blue;\">implements</span> IDisposable {\r\n\t<span style=\"color: blue;\">static</span> attributes = [disposableMixin(Bar)];\r\n\t\r\n\t<span style=\"color: green;\">// IDisposable mixin</span>\r\n\t<span style=\"color: blue;\">public</span> dispose: () =&gt; <span style=\"color: blue;\">void</span>;\r\n\t<span style=\"color: blue;\">public</span> isDisposed: () =&gt; bool;\r\n\r\n\t<span style=\"color: blue;\">public</span> test() {\r\n\t\t\r\n\t}\r\n\t\r\n\t<span style=\"color: blue;\">private</span> onDispose(): <span style=\"color: blue;\">void</span> {\r\n\t\talert(<span style=\"color: #a31515;\">'object disposed'</span>);\r\n\t}\r\n}\r\n\r\n<span style=\"color: blue;\">var</span> bar = <span style=\"color: blue;\">new</span> Bar();\r\nbar.dispose();\r\n</pre>\r\n</div>\r\n<p>I like the idea of the attributes being defined at the top of the class but it does come at a cost.&nbsp; If you look at the generated code for Bar you'll see that your attributes are executed before Bar's methods are added to its prototypes.&nbsp; That's probably ok but it means the attribute can't reason over the class definition at parse time and instead would have to defer any of that logic to runtime on first create.&nbsp; Again, that's probably ok.</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">var</span> Bar = (<span style=\"color: blue;\">function</span> (_super) {\r\n    __extends(Bar, _super);\r\n    <span style=\"color: blue;\">function</span> Bar() {\r\n        _super.apply(<span style=\"color: blue;\">this</span>, arguments);\r\n\r\n    }\r\n    Bar.attributes = [\r\n        disposableMixin(Bar)\r\n    ];\r\n    Bar.prototype.test = <span style=\"color: blue;\">function</span> () {\r\n    };\r\n    Bar.prototype.onDispose = <span style=\"color: blue;\">function</span> () {\r\n        alert(<span style=\"color: #a31515;\">'object disposed'</span>);\r\n    };\r\n    <span style=\"color: blue;\">return</span> Bar;\r\n})(ObjectBase);\r\n</pre>\r\n</div>",
    "PostedDate": "2012-10-10T11:44:35.637-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "953553",
    "ThreadId": "398391",
    "Html": "\r\n<p>Isn't it a problem that the solution requires a specific base class?</p>\r\n<p>I mean, in practice you could just define the mixins on the base class and be done with it. Am I missing something?</p>\r\n",
    "PostedDate": "2012-12-09T08:44:10.28-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1003481",
    "ThreadId": "398391",
    "Html": "@mertner Not exactly. If you have many distinct mixins, each doing a completely different thing, by SRP, they should not be re-written as members of the same class. However, they may actually be components useful to one specific class. Mixins allows you to use a form of multiple inheritance to grab many little pieces of functionality, without having to declare them all in one big class that wouldn't make sense. They're very useful for repeated concerns that don't really belong on any one class; things like Authentication, timing, logging, caching, etc...\r<br />\n<br />\n@ickman This appears to only work when the class including the mixins has a no-parameter constructor - otherwise the compiler blows up. Is this by design? Perhaps I should raise a bug about it?<br />\n",
    "PostedDate": "2013-02-19T07:55:51.01-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1067791",
    "ThreadId": "398391",
    "Html": "I'd like to revive this thread in order to point out a particularly elegant solution to mixin composition in a statically typed language - Scala traits.<br />\nIf you aren't familiar with scala traits, here is the start of a series of blog articles covering them, and how they are implemented on the JVM:<br />\n<br />\n<a href=\"http://nurkiewicz.blogspot.com/2013/04/scala-traits-implementation-and.html\" rel=\"nofollow\">http://nurkiewicz.blogspot.com/2013/04/scala-traits-implementation-and.html</a><br />\n<a href=\"http://nurkiewicz.blogspot.no/2013/04/scala-traits-implementation-and_3.html\" rel=\"nofollow\">http://nurkiewicz.blogspot.no/2013/04/scala-traits-implementation-and_3.html</a><br />\n<br />\nThere are some unique characteristics of scala traits I would like to see brought to TypeScript if Mixins are to be supported.<br />\n<ul>\n<li>Scala traits are both interfaces and implementation. </li>\n<li>The code in a trait function is only defined once, not copied into the classes they are mixed into. Classes and instances that mix the trait in forward the calls to the shared implementation.</li>\n<li>Traits are &quot;stacked&quot; using a process called linearization. This means &quot;super&quot; is predictable and stable at all parts of the stack. It also means that traits are only mixed in once, even if there are multiple references to that trait in the stack.</li>\n<li>\nYou can mix in traits either when you are declaring a class, or when you are instantiating the class. <br />\n</li>\n</ul>\nWhile I wouldn't hazard to guess at how traits would be implemented in JavaScript, I think the syntax would look something similar to this, with as few changes to TypeScript syntax as possible:<br />\n<pre><code>// TraitProposal.ts\ninterface IFoo {\n  foo: string = &quot;foo&quot;;\n}\nclass Base {}\nclass Sub extends Base implements IFoo {}\n\nvar x = new Sub();\n\n // new 'mix' keyword allows on-the-spot mixin composition\nvar y = new Base() mix IFoo; // it is REALLY too bad that 'with' is already a JS keyword, or it would be perfect here instead of 'mix'\n\ninterface IFoo2 {\n  foo2: string = &quot;foo2&quot;;\n  bar: () =&gt; number;\n}\n\nvar z = new Base() mix IFoo mix IFoo2; // Type error, because bar is not implemented.</code></pre>\n\n",
    "PostedDate": "2013-07-12T21:03:33.653-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1068028",
    "ThreadId": "398391",
    "Html": "So what happens here<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\n<span style=\"color:Blue;\">var</span> x = <span style=\"color:Blue;\">new</span> Sub();\nx.foo = <span style=\"color:#A31515;\">&quot;bar&quot;</span>;\n\n<span style=\"color:Blue;\">var</span> y = <span style=\"color:Blue;\">new</span> Sub();\n\nconsole.log(y.foo); <span style=\"color:Green;\">// presumably this is going to be &quot;bar&quot; because the trait is shared </span>\n\r\n</pre></div>Not really seeing how useful a mixin can be if<br />\n<blockquote>\nThe code in a trait function is only defined once, not copied into the classes they are mixed into. Classes and instances that mix the trait in forward the calls to the shared implementation.<br />\n</blockquote>\nThis sort of behaviour can be better achieved via dependency injection.\r<br />\n<br />\nA mixin IMO <strong>must</strong> be copied into the class requiring the mix.\r<br />\n<br />\nSee also: <a href=\"https://typescript.codeplex.com/discussions/406449\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/406449</a><br />\n",
    "PostedDate": "2013-07-14T03:27:06.757-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1068179",
    "ThreadId": "398391",
    "Html": "I think I need to clarify. You are correct that a mixin must be copied into the class requiring the mix. That is what happens in scala too. So, in your example, y.foo will be &quot;foo&quot;, not &quot;bar&quot;. What I meant by &quot;share the same implementation&quot; is that there would be one shared function definition for each class that mixes in the interface. A reference to that function is copied into the class prototype. Obviously this is easier to do in JavaScript than on the JVM, but you get the picture. \r<br />\n<br />\nHowever, that's not the whole story. As I said before, Scala uses a linearization algorithm to &quot;stack&quot; mixins together. This is the important part. The linearization algorithm is simple, but it has important qualities: <br />\n<ol>\n<li>From any class where you can access &quot;super&quot;, the type of &quot;super&quot; never changes. This is critically important and can be broken by naive mixin systems.</li>\n<li>\nFor any type, references to an interface's implementated methods only appear once in the entire prototype chain. Part of Scala's linearization process removes duplicates from the stack.<br />\n</li>\n</ol>\nThese are hard to visualize, so here's a contrived example:<br />\n<pre><code>interface IFoo {\n   foo() { return &quot;foo&quot;; }\n}\n\ninterface IFooExtended extends IFoo {\n foo() { return super.foo() + &quot; from IFooExtended&quot;; }\n} \n\n// methods from IFoo copied to A's prototype\n// A's mixin stack: IFoo -&gt; A\nclass A implements IFoo {\n  foo() { return &quot;foo A&quot;; }\n}\n\n// methods from IFooExtended copied to B's prototype,\n// but NOT methods from IFoo (those were already copied to A).\n// B's mixin stack: IFoo -&gt; A -&gt; IFooExtended -&gt; B\nclass B extends A implements IFooExtended  {}\n\n// methods from IFoo AND IFooExtended are copied into C's prototype\n// however, super within IFooExtended.foo refers to the IFoo implementation.\n// C's mixin stack: IFoo -&gt; IFooExtended -&gt; C\nclass C implements IFooExtended() {}\n\nvar a = new A();\nvar b = new B();\nvar c = new C();\n\nalert(a.foo()); // outputs &quot;foo A&quot;\nalert(b.foo()); // outputs &quot;foo A from IFooExtended&quot;\nalert(c.foo()); // outputs &quot;foo from IFooExtended&quot;</code></pre>\n\nOh, and the instantiation time mixin composition is just syntax sugar - it just creates an anonymous class:<br />\n<pre><code>interface IFoo {...}\nclass A {...}\nvar x = new A() mixin IFoo; // compiler creates an anonymous class: class __anon_A_IFoo extends A implements IFoo {}</code></pre>\n\n",
    "PostedDate": "2013-07-14T19:21:51.927-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]