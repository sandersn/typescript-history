[
  {
    "Id": "1047799",
    "ThreadId": "444777",
    "Html": "In order to reduce memory usage and maybe improve initialization time of objects, has there been any discussion about putting simple values (of string/boolean/number) on the prototype of the class?<br />\n<br />\n<br />\n<strong>TS Input</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Foo {\n    a:bool = <span style=\"color:Blue;\">true</span>;\n    c:string = <span style=\"color:#A31515;\">&quot;hello world&quot;</span>;\n    d:number = 321;\n}\n\n<span style=\"color:Blue;\">class</span> Bar <span style=\"color:Blue;\">extends</span> Foo {}\n\n<span style=\"color:Blue;\">var</span> a = <span style=\"color:Blue;\">new</span> Bar();\r\n</pre></div><strong>TSC Output</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> __extends = <span style=\"color:Blue;\">this</span>.__extends || <span style=\"color:Blue;\">function</span> (d, b) {\n    <span style=\"color:Blue;\">function</span> __() { <span style=\"color:Blue;\">this</span>.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = <span style=\"color:Blue;\">new</span> __();\n};\n<span style=\"color:Blue;\">var</span> Foo = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Foo() {\n        <span style=\"color:Blue;\">this</span>.a = <span style=\"color:Blue;\">true</span>;\n        <span style=\"color:Blue;\">this</span>.c = <span style=\"color:#A31515;\">&quot;hello world&quot;</span>;\n        <span style=\"color:Blue;\">this</span>.d = 321;\n    }\n    <span style=\"color:Blue;\">return</span> Foo;\n})();\n<span style=\"color:Blue;\">var</span> Bar = (<span style=\"color:Blue;\">function</span> (_super) {\n    __extends(Bar, _super);\n    <span style=\"color:Blue;\">function</span> Bar() {\n        _super.apply(<span style=\"color:Blue;\">this</span>, arguments);\n    }\n    <span style=\"color:Blue;\">return</span> Bar;\n})(Foo);\n<span style=\"color:Blue;\">var</span> a = <span style=\"color:Blue;\">new</span> Bar();\r\n</pre></div><strong>Expected Output</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> __extends = <span style=\"color:Blue;\">this</span>.__extends || <span style=\"color:Blue;\">function</span> (d, b) {\n    <span style=\"color:Blue;\">function</span> __() { <span style=\"color:Blue;\">this</span>.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = <span style=\"color:Blue;\">new</span> __();\n};\n<span style=\"color:Blue;\">var</span> Foo = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Foo() {}\n    <span style=\"color:Green;\">// simple JS types like strings, numbers and booleans on the prototype</span>\n    Foo.prototype.a = <span style=\"color:Blue;\">true</span>;\n    Foo.prototype.c = <span style=\"color:#A31515;\">&quot;hello world&quot;</span>;\n    Foo.prototype.d = 321;\n    <span style=\"color:Blue;\">return</span> Foo;\n})();\n<span style=\"color:Blue;\">var</span> Bar = (<span style=\"color:Blue;\">function</span> (_super) {\n    __extends(Bar, _super);\n    <span style=\"color:Blue;\">function</span> Bar() {}\n    <span style=\"color:Blue;\">return</span> Bar;\n})(Foo);\n<span style=\"color:Blue;\">var</span> a = <span style=\"color:Blue;\">new</span> Bar();\r\n</pre></div>If the output from TSC is by design/spec then maybe this can be added via a variable declaration attribute.<br />\n<br />\nI've been implementing this hack but I'm sure I shouldn't be doing this..<br />\n<br />\n<strong>Hack</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\n<span style=\"color:Blue;\">class</span> Foo {\n\n    a:bool;\n    c:string;\n    d:number;\n\n    <span style=\"color:Blue;\">static</span> STATIC_CONSTRUCTOR = <span style=\"color:Blue;\">function</span>(obj) {\n        obj.a = <span style=\"color:Blue;\">true</span>;\n        obj.c = <span style=\"color:#A31515;\">&quot;hello world&quot;</span>;\n        obj.d = 321;\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">true</span>;\n    };\n\n    <span style=\"color:Blue;\">static</span> STATIC_CONSTRUCTOR_INIT = Foo.STATIC_CONSTRUCTOR(Foo.prototype);\n\n}\r\n</pre></div>Thank you.<br />\n",
    "PostedDate": "2013-05-23T08:40:36.3-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1047928",
    "ThreadId": "444777",
    "Html": "Putting variable declarations on the prototype vs the instance variable is completely different semantically. As you've noticed, if you want to optimize for memory usage you can do so explicitly if the semantics match what you desire. Consider if your string property c was instead called name. Do you really want the same 'name' property for every instance of Foo? Maybe you do, if so, you need to make that explicit. How would the compiler automatically know which one you meant? The variable declaration attribute you're asking for is essentially what static already is, it defines things shared between all instances of a class rather than those that exist per instance.<br />\n",
    "PostedDate": "2013-05-23T12:57:31.29-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1047944",
    "ThreadId": "444777",
    "Html": "Dan,<br />\n<br />\nI've read your response multiple times, but it's not making much sense to me. <br />\n<br />\nSharing between objects is exactly what prototypal inheritance provides.   When I have a function on a prototype, say that function is named <code>name()</code>,that function is shared between all instances and instances of derived classes.  That's the default for methods/functions,  why not the default for initialization of simple variables (string/numbers/booleans)?  We don't make all our methods static do we.<br />\n<br />\nSo yes, I do want <code>name</code> shared between all my instances.  It achieves the same thing as initializing variables in the constructor chain.  I'm not looking for <code>static</code> functionality since I want the instances to be able to update those values.  If you believe that instances updating those values will update those values for all  instances, then you need to read up again on  prototypal inheritance.<br />\n<br />\nTo be clear, I'm not requesting a declaration attribute, but it may provide a pathway to a compromise. And I'm not recommending that objects and arrays be initialized in the same manner.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\n<span style=\"color:Green;\">// TS</span>\n<span style=\"color:Blue;\">class</span> Foo {\n    <span style=\"color:Green;\">// initializing variables, all instances for Foo will start in this state</span>\n    a:bool = <span style=\"color:Blue;\">true</span>;\n    c:string = <span style=\"color:#A31515;\">&quot;hello world&quot;</span>;\n    d:number = 321;\n    name:string = <span style=\"color:#A31515;\">&quot;bob&quot;</span>;\n}\n\n<span style=\"color:Green;\">// TSC Output</span>\n<span style=\"color:Blue;\">var</span> Foo = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Foo() {\n        <span style=\"color:Green;\">// initializing variables at instance construct time</span>\n        <span style=\"color:Green;\">// this code is run for every instance created</span>\n        <span style=\"color:Blue;\">this</span>.a = <span style=\"color:Blue;\">true</span>;\n        <span style=\"color:Blue;\">this</span>.c = <span style=\"color:#A31515;\">&quot;hello world&quot;</span>;\n        <span style=\"color:Blue;\">this</span>.d = 321;\n        <span style=\"color:Blue;\">this</span>.name = <span style=\"color:#A31515;\">&quot;bob&quot;</span>;\n    }\n    <span style=\"color:Blue;\">return</span> Foo;\n})();\n\n<span style=\"color:Green;\">// Desired TSC Output</span>\n<span style=\"color:Blue;\">var</span> Foo = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Foo() {}\n    <span style=\"color:Green;\">// initializing variables on the prototype</span>\n    <span style=\"color:Green;\">// this code is run once</span>\n    Foo.prototype.a = <span style=\"color:Blue;\">true</span>;\n    Foo.prototype.c = <span style=\"color:#A31515;\">&quot;hello world&quot;</span>;\n    Foo.prototype.d = 321;\n    Foo.prototype.name = <span style=\"color:#A31515;\">&quot;bob&quot;</span>;\n    <span style=\"color:Blue;\">return</span> Foo;\n})();\r\n</pre></div>",
    "PostedDate": "2013-05-23T13:38:55.893-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1048266",
    "ThreadId": "444777",
    "Html": "@pixel4, in your simple example things work rather well. <br />\n<br />\nHowever, consider what happens here<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Foo {\n   name = <span style=\"color:#A31515;\">&quot;Foo&quot;</span>;\n}\n\n<span style=\"color:Blue;\">class</span> Bar {\n    foo = <span style=\"color:Blue;\">new</span> Foo();\n}\n\n<span style=\"color:Blue;\">var</span> barOne = <span style=\"color:Blue;\">new</span> Bar();\n<span style=\"color:Blue;\">var</span> barTwo = <span style=\"color:Blue;\">new</span> Bar();\n\nbarOne.foo.name = <span style=\"color:#A31515;\">&quot;Baz&quot;</span>;\n\nconsole.log(barTwo.foo.name); <span style=\"color:Green;\">// Do we really want this to be &quot;Baz&quot;?</span>\r\n</pre></div>I believe the radical move by TypeScript to drop properties on prototypes is a good one. It's a pretty confusing aspect of JavaScript.<br />\n<br />\nYes, the memory footprint is greater on account of this, but with careful design that can be minimised.<br />\n",
    "PostedDate": "2013-05-24T07:49:54.977-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1048303",
    "ThreadId": "444777",
    "Html": "@nabog<br />\n<br />\nDid you even try running that code?   I did ..<br />\n<br />\n<strong>Modified TSC output to put name on the prototype</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\n<span style=\"color:Blue;\">var</span> Foo = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Foo() {}\n    Foo.prototype.name = <span style=\"color:#A31515;\">&quot;Foo&quot;</span>;\n    <span style=\"color:Blue;\">return</span> Foo;\n})();\n<span style=\"color:Blue;\">var</span> Bar = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Bar() {\n        <span style=\"color:Blue;\">this</span>.foo = <span style=\"color:Blue;\">new</span> Foo();\n    }\n    <span style=\"color:Blue;\">return</span> Bar;\n})();\n<span style=\"color:Blue;\">var</span> barOne = <span style=\"color:Blue;\">new</span> Bar();\n<span style=\"color:Blue;\">var</span> barTwo = <span style=\"color:Blue;\">new</span> Bar();\nbarOne.foo.name = <span style=\"color:#A31515;\">&quot;Baz&quot;</span>;\nconsole.log(barTwo.foo.name);\r\n</pre></div>I get <code>&quot;Foo&quot;</code> from console.log not <code>&quot;Baz&quot;</code>.    You're understanding of prototypal inheritance is not complete.  If you put a value on a prototype, it becomes the default until you set it on the derived object. <br />\n<br />\nMaybe this will clear it up ...<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\n<span style=\"color:Blue;\">var</span> barTwo = <span style=\"color:Blue;\">new</span> Bar();\n\n<span style=\"color:Green;\">/*\n[inspect  barTwo]\n    &gt;barTwo:BarInstance\n        &gt;foo:FooInstance\n            &gt; __proto__\n                &gt; name:&quot;Foo&quot;  &lt;---` barTwo.foo.name` shall resolve to this value\n*/</span>\n\nbarOne.foo.name = <span style=\"color:#A31515;\">&quot;Baz&quot;</span>;\n\n<span style=\"color:Green;\">/*\n[inspect  barTwo]\n    &gt; barTwo:BarInstance\n        &gt; foo:FooInstance\n            &gt; name:&quot;Baz&quot;  &lt;--- `barTwo.foo.name` shall resolve to this value\n            &gt; __proto__\n                &gt; name:&quot;Foo&quot;  \n*/</span>\n\r\n</pre></div>",
    "PostedDate": "2013-05-24T08:53:45.537-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1048317",
    "ThreadId": "444777",
    "Html": "Thank you for your kind enquiry regarding my understanding of prototypal inheritance.<br />\n<br />\nYour JavaScript for Bar is faulty. <br />\n<br />\nIt should be this:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> Bar = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Bar() {\n    }\n    Bar.prototype.foo = <span style=\"color:Blue;\">new</span> Foo();\n    <span style=\"color:Blue;\">return</span> Bar;\n})();\n\r\n</pre></div>",
    "PostedDate": "2013-05-24T09:29:03.947-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1048320",
    "ThreadId": "444777",
    "Html": "@nabog  Huh?   If you read back in this thread, I suggested that only simple types (string/numbers/boolean) should be placed on the prototype.  Objects and Arrays should not be placed on the prototype.   Please read the thread.<br />\n",
    "PostedDate": "2013-05-24T09:37:06.273-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1048328",
    "ThreadId": "444777",
    "Html": "Yes, I see that you did mention that. So my mistake.\r<br />\n<br />\nBear in mind this will only be beneficial if the properties are never assigned to in an instance constructor, because that will create a new property on the instance and the benefit is lost.\r<br />\n<br />\nWe personally do not have a use-case for classes with properties that are initialised with literals such as true, &quot;hello world&quot;, 321 and &quot;bob&quot; and never changed thereafter.<br />\n",
    "PostedDate": "2013-05-24T10:00:12.873-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1048352",
    "ThreadId": "444777",
    "Html": "Here's a use-case ..\r<br />\n<br />\n<strong>TS Input</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Vec4 {\n    x:number = 0;\n    y:number = 0;\n    z:number = 0;\n    w:number = 0;\n}\r\n</pre></div><strong>TSC Output</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> Vec4 = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Vec4() {\n        <span style=\"color:Blue;\">this</span>.x = 0;\n        <span style=\"color:Blue;\">this</span>.y = 0;\n        <span style=\"color:Blue;\">this</span>.z = 0;\n        <span style=\"color:Blue;\">this</span>.w = 0;\n    }\n    <span style=\"color:Blue;\">return</span> Vec4;\n})();\r\n</pre></div>This is a common type of data object when working in high performance environments such as WebGL.   If I create an instance, the constructor  will create and assign 4 number values each time. \r<br />\n<br />\nWhat you're saying is that if we change the constructor to something like this ...<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Vec4 {\n    constructor(<span style=\"color:Blue;\">public</span> x=0, <span style=\"color:Blue;\">public</span> y=0, <span style=\"color:Blue;\">public</span> z=0, <span style=\"color:Blue;\">public</span> w=0) {}\n}\r\n</pre></div>... then the constructor has to be involved with the assignment; the prototype value becomes useless and the output from TSC becomes ...<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> Vec4 = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Vec4(x, y, z, w) {\n        <span style=\"color:Blue;\">if</span> (<span style=\"color:Blue;\">typeof</span> x === <span style=\"color:#A31515;\">&quot;undefined&quot;</span>) { x = 0; }\n        <span style=\"color:Blue;\">if</span> (<span style=\"color:Blue;\">typeof</span> y === <span style=\"color:#A31515;\">&quot;undefined&quot;</span>) { y = 0; }\n        <span style=\"color:Blue;\">if</span> (<span style=\"color:Blue;\">typeof</span> z === <span style=\"color:#A31515;\">&quot;undefined&quot;</span>) { z = 0; }\n        <span style=\"color:Blue;\">if</span> (<span style=\"color:Blue;\">typeof</span> w === <span style=\"color:#A31515;\">&quot;undefined&quot;</span>) { w = 0; }\n        <span style=\"color:Blue;\">this</span>.x = x;\n        <span style=\"color:Blue;\">this</span>.y = y;\n        <span style=\"color:Blue;\">this</span>.z = z;\n        <span style=\"color:Blue;\">this</span>.w = w;\n    }\n    <span style=\"color:Blue;\">return</span> Vec4;\n})();\r\n</pre></div>.. but if we used the prototype to capture the default values, then TSC could produce code like this ..<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> Vec4 = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Vec4(x, y, z, w) {\n        <span style=\"color:Blue;\">if</span> (x!=<span style=\"color:Blue;\">null</span>) <span style=\"color:Blue;\">this</span>.x = x;\n        <span style=\"color:Blue;\">if</span> (y!=<span style=\"color:Blue;\">null</span>) <span style=\"color:Blue;\">this</span>.y = y;\n        <span style=\"color:Blue;\">if</span> (z!=<span style=\"color:Blue;\">null</span>) <span style=\"color:Blue;\">this</span>.z = z;\n        <span style=\"color:Blue;\">if</span> (w!=<span style=\"color:Blue;\">null</span>) <span style=\"color:Blue;\">this</span>.w = w;\n    }\n    Vec4.prototype.x = 0;\n    Vec4.prototype.y = 0;\n    Vec4.prototype.z = 0;\n    Vec4.prototype.w = 0;\n    <span style=\"color:Blue;\">return</span> Vec4;\n})();\r\n</pre></div>Something that I've been thinking about is how values are initialized in the constructor chain.   This might be the only side-effect of having simple values on this prototype...\r<br />\n<br />\n<strong>TS Source</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Foo {\n    <span style=\"color:Blue;\">public</span> x = 123;\n    constructor() {\n        console.log(<span style=\"color:#A31515;\">&quot;Foo&quot;</span>,<span style=\"color:Blue;\">this</span>.x);\n    } \n}\n\n<span style=\"color:Blue;\">class</span> Bar <span style=\"color:Blue;\">extends</span> Foo {\n    <span style=\"color:Blue;\">public</span> x = 321;\n    constructor() {\n        <span style=\"color:Blue;\">super</span>();\n        console.log(<span style=\"color:#A31515;\">&quot;Bar&quot;</span>, <span style=\"color:Blue;\">this</span>.x);\n    } \n}\n\n<span style=\"color:Blue;\">var</span> a = <span style=\"color:Blue;\">new</span> Bar();\r\n</pre></div><strong>TSC Ouput</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> __extends = <span style=\"color:Blue;\">this</span>.__extends || <span style=\"color:Blue;\">function</span> (d, b) {\n    <span style=\"color:Blue;\">function</span> __() { <span style=\"color:Blue;\">this</span>.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = <span style=\"color:Blue;\">new</span> __();\n};\n<span style=\"color:Blue;\">var</span> Foo = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Foo() {\n        <span style=\"color:Blue;\">this</span>.x = 123;\n        console.log(<span style=\"color:#A31515;\">&quot;Foo&quot;</span>, <span style=\"color:Blue;\">this</span>.x);\n    }\n    <span style=\"color:Blue;\">return</span> Foo;\n})();\n<span style=\"color:Blue;\">var</span> Bar = (<span style=\"color:Blue;\">function</span> (_super) {\n    __extends(Bar, _super);\n    <span style=\"color:Blue;\">function</span> Bar() {\n        _super.call(<span style=\"color:Blue;\">this</span>);\n        <span style=\"color:Blue;\">this</span>.x = 321;\n        console.log(<span style=\"color:#A31515;\">&quot;Bar&quot;</span>, <span style=\"color:Blue;\">this</span>.x);\n    }\n    <span style=\"color:Blue;\">return</span> Bar;\n})(Foo);\n<span style=\"color:Blue;\">var</span> a = <span style=\"color:Blue;\">new</span> Bar();\r\n</pre></div>This output of console.log is<br />\n<pre><code>Foo 123\nBar 321</code></pre>\n\nIf we moved TSC to put simple values on the prototype, then this behavior changes \r<br />\n<br />\n<br />\n<strong>Modified TSC Ouput</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> __extends = <span style=\"color:Blue;\">this</span>.__extends || <span style=\"color:Blue;\">function</span> (d, b) {\n    <span style=\"color:Blue;\">function</span> __() { <span style=\"color:Blue;\">this</span>.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = <span style=\"color:Blue;\">new</span> __();\n};\n<span style=\"color:Blue;\">var</span> Foo = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Foo() {\n        console.log(<span style=\"color:#A31515;\">&quot;Foo&quot;</span>, <span style=\"color:Blue;\">this</span>.x);\n    }\n    Foo.prototype.x = 123;\n    <span style=\"color:Blue;\">return</span> Foo;\n})();\n<span style=\"color:Blue;\">var</span> Bar = (<span style=\"color:Blue;\">function</span> (_super) {\n    __extends(Bar, _super);\n    <span style=\"color:Blue;\">function</span> Bar() {\n        _super.call(<span style=\"color:Blue;\">this</span>);\n        console.log(<span style=\"color:#A31515;\">&quot;Bar&quot;</span>, <span style=\"color:Blue;\">this</span>.x);\n    }\n    Bar.prototype.x = 321;\n    <span style=\"color:Blue;\">return</span> Bar;\n})(Foo);\n<span style=\"color:Blue;\">var</span> a = <span style=\"color:Blue;\">new</span> Bar();\r\n</pre></div>The output is now<br />\n<pre><code>Foo 321\nBar 321</code></pre>\n\nI'm not sure if this is a good thing or a bad thing.  It will cause differences between simple values and Objects/Arrays that can't be initialize on the prototype.\r<br />\n<br />\n<br />\nI still think there is merit in discussing optimizing the output from TSC.<br />\n",
    "PostedDate": "2013-05-24T10:49:27.233-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1048375",
    "ThreadId": "444777",
    "Html": "We've had a lot of discussions about this topic in the TypeScript design group. It is obviously desirable to share as much as possible through prototypes, but it is an area that is steeped in subtleties to say the least. For example, because it is really only safe to share immutable values, we could only do this for primitives, as you propose. But it would cause seemingly similar declarations of properties with initial values to generate different code and have different observed behavior in several common scenarios. For example, it is very common to enumerate the properties of an object in conjunction with an obj.hasOwnProperty(...) check, and this behaves differently for instance vs. prototype properties.\r<br />\n<br />\nSo far our conclusion has been that it's better to have a single predictable behavior here.\r<br />\n<br />\nBTW, a convenient way to initialize properties on the prototype is to simply do it with assignment statements following a class declaration. Referring to your initial example, you could simply write:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Foo {\n    a: <span style=\"color:Blue;\">bool</span>;\n    c: <span style=\"color:Blue;\">string</span>;\n    d: <span style=\"color:Blue;\">number</span>;\n}\nFoo.prototype.a = <span style=\"color:Blue;\">true</span>;\nFoo.prototype.c = <span style=\"color:#A31515;\">&quot;hello world&quot;</span>;\nFoo.prototype.d = 321;\r\n</pre></div>This is still fully typed checked (because the prototype member is strongly typed) and makes it pretty clear what's going on.<br />\n",
    "PostedDate": "2013-05-24T11:41:47.98-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1048400",
    "ThreadId": "444777",
    "Html": "Hi <a href=\"mailto:@ahejlsberg\" rel=\"nofollow\">@ahejlsberg</a>.  It's good to know that this has been discussed. And think you for the prototype tip, it does make my hack look a little silly now lol.\r<br />\n<br />\nI guess my hope for TypeScript is that I wouldn't have to worry/know about the prototype object at all.  And issues with hasOwnProperty enumeration would be taken care of via TypeScript constructs. <em>shrug</em>\r<br />\n<br />\nI would counter the <code>obj.hasOwnProperty(...)</code> example by suggesting that maybe it's useful to know if a value has been set on an object or is it the prototype value I'm getting.\r<br />\n<br />\n<br />\nI know it's not the most brilliant idea but you could keep a list of enumerable properties on the class prototype.  \r<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Foo {\n    b=123;\n}\n<span style=\"color:Blue;\">class</span> Bar <span style=\"color:Blue;\">extends</span> Foo {\n    a=<span style=\"color:#A31515;\">&quot;hello world&quot;</span>\n}\r\n</pre></div><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> __extends = <span style=\"color:Blue;\">this</span>.__extends || <span style=\"color:Blue;\">function</span> (d, b) {\n    <span style=\"color:Blue;\">function</span> __() { <span style=\"color:Blue;\">this</span>.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = <span style=\"color:Blue;\">new</span> __();\n};\n<span style=\"color:Blue;\">var</span> Foo = (<span style=\"color:Blue;\">function</span> () {\n    <span style=\"color:Blue;\">function</span> Foo() {\n        <span style=\"color:Blue;\">this</span>.b = 123;\n    }\n    Foo.prototype.__enums = [<span style=\"color:#A31515;\">&quot;b&quot;</span>];\n    <span style=\"color:Blue;\">return</span> Foo;\n})();\n<span style=\"color:Blue;\">var</span> Bar = (<span style=\"color:Blue;\">function</span> (_super) {\n    __extends(Bar, _super);\n    <span style=\"color:Blue;\">function</span> Bar() {\n        _super.apply(<span style=\"color:Blue;\">this</span>, arguments);\n        <span style=\"color:Blue;\">this</span>.a = <span style=\"color:#A31515;\">&quot;hello world&quot;</span>;\n    }\n    Foo.prototype.__enums = [<span style=\"color:#A31515;\">&quot;a&quot;</span>].concat(_super.prototype.__enums);\n    <span style=\"color:Blue;\">return</span> Bar;\n})(Foo);\r\n</pre></div>Then somehow enable a forIn on TypeScript class instances or just let people access the __enums object directly.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\n<span style=\"color:Blue;\">var</span> a = <span style=\"color:Blue;\">new</span> Bar();\na.forIn(<span style=\"color:Blue;\">function</span>(propName) {});\n\r\n</pre></div>Meh.\r<br />\n<br />\n<br />\nAnyhow,  thanks for the feedback.  I'm a big TS fan, been working with it everyday for many weeks now.  When's 0.9 out of alpha/beta :P   ?\r<br />\n<br />\n<br />\nThanks again.<br />\n",
    "PostedDate": "2013-05-24T12:27:05.667-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1048439",
    "ThreadId": "444777",
    "Html": "Here's another inconsistency with this suggestion:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Bar {\n}\n\n<span style=\"color:Blue;\">class</span> Foo {\n    x:number = 50;\n    bar = <span style=\"color:Blue;\">new</span> Bar();\n}\n\n<span style=\"color:Blue;\">var</span> foo = <span style=\"color:Blue;\">new</span> Foo();\n\n<span style=\"color:Blue;\">delete</span> foo.x;\nfoo.x.toString(); <span style=\"color:Green;\">// okay</span>\n\n<span style=\"color:Blue;\">delete</span> foo.bar;\nfoo.bar.toString(); <span style=\"color:Green;\">// Ag!</span>\n\r\n</pre></div>",
    "PostedDate": "2013-05-24T13:43:06.717-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1050390",
    "ThreadId": "444777",
    "Html": "<strong>pixel4 wrote:</strong><br />\n<blockquote>\nI guess my hope for TypeScript is that I wouldn't have to worry/know about the prototype object at all.  And issues with hasOwnProperty enumeration would be taken care of via TypeScript constructs. <em>shrug</em><br />\n</blockquote>\nAs one of our goals is to be able to use Typescript to model as many of the common, existing JavaScript patterns as possible this would very much be at odds with that. Your Typescript code also needs to be able to interop with JavaScript as you'd expect, which may use the prototype in all sorts of different ways. As you've noted, there're very real differences between putting things on the prototype or not, both from a semantic and performance perspective. I'm not sure how you envision the language hiding this abstraction while also exposing the types of tricks you want to have the ability to express. Using Ander's example, how would you see this being interpreted by the compiler?<br />\n<pre><code>class Foo {\n    a = true;\n    c = 'hello world';\n    d = 321;\n}</code></pre>\n\nHow would the compiler know whether to emit <br />\n<pre><code>var Foo = (function () {\n    function Foo() {\n        this.a = true;\n        this.b = 'hello world';\n        this.c = 321;\n    }\n    return Foo;\n})();</code></pre>\n\nor<br />\n<pre><code>var Foo3 = (function () {\n    function Foo() {\n    }\n    return Foo;\n})();\nFoo3.prototype.a = true;\nFoo3.prototype.c = &quot;hello world&quot;;\nFoo3.prototype.d = 321;</code></pre>\n\nThe two JavaScript options have completely different characteristics. You would surely need some syntax to support the distinction, which is basically the case day, albeit perhaps not as concise as you'd like. That's what I was trying to get at with my initial reply. <br />\n",
    "PostedDate": "2013-05-29T17:15:16.91-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1096906",
    "ThreadId": "444777",
    "Html": "It is really disappointing that this discussion has come to an end. After taking a closer look at TypeScript over the last weeks, this seems to be a serious flaw in TypeScript.\r<br />\n<br />\n<strong>tl;dr: TypeScript is really missing the ability to set properties on the prototype not only as this is a common pattern in JavaScript but also as it would introduce useful new features. I would suggest to introduce a new keyword to make this possible.</strong><br />\n<h1>Prototype properties in JavaScript</h1>\nThere are a lot of JavaScript libraries out there that rely on properties set on the prototype and also for TypeScript developers this would be a great feature. For example lets look how the popular Bootstrap.js library handles views. If you want to create your own view, you simply write:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> MyButton = Backbone.View.extend({\n    caption: <span style=\"color:#A31515;\">&#39;Submit&#39;</span>,\n    tagName: <span style=\"color:#A31515;\">&#39;button&#39;</span>,\n    className: <span style=\"color:#A31515;\">&#39;btn&#39;</span>,\n    events: { <span style=\"color:#A31515;\">&#39;click&#39;</span>:<span style=\"color:#A31515;\">&#39;onClick&#39;</span> },\n    onClick: <span style=\"color:Blue;\">function</span>(event) { console.log(<span style=\"color:Blue;\">this</span>.caption + <span style=\"color:#A31515;\">&#39; clicked!&#39;</span>); }\n});\n<span style=\"color:Blue;\">var</span> button = <span style=\"color:Blue;\">new</span> MyButton();\r\n</pre></div>The properties ´tagName´, ´className´ and ´events´ are set on the prototype, which makes sense as:<br />\n<ul>\n<li>They will not change in different instances of the class.</li>\n<li>They consume less memory than instance properties, especially when a lot of instances are created.</li>\n<li>\nThe underlying constructor will access them to create the desired element and therefore needs the values right after instantiation.<br />\n</li>\n</ul>\nGenerally spoken, properties on prototypes behave like a mix of instance (set on a instance through ´this´) and static (set on a constructor, e.g. ´MyButton´) properties:<br />\n<ul>\n<li>They can be accesses like instance properties but are shared among all instances. Static properties can only be accessed through the constructor instance.</li>\n<li>They are immediately available after instantiation, they don't need to be initialized like instance properties.</li>\n<li>\nThey respect class inheritance. Both instance and static properties are only available on the objects they are set on. Prototype properties always return the closest value from the inheritance chain.<br />\n</li>\n</ul>\n<h1>Prototype properties in TypeScript</h1>\nThe only way to set prototype properties with TypeScript is to apply them to the prototype of a constructor after the class has been declared, as ahejlsberg describes in his post above.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> MyButton <span style=\"color:Blue;\">extends</span> Backbone.View{\n    caption:<span style=\"color:Blue;\">string</span> = <span style=\"color:#A31515;\">&#39;Submit&#39;</span>;\n    tagName:<span style=\"color:Blue;\">string</span>;\n    className:<span style=\"color:Blue;\">string</span>;\n    events:Object;\n    onClick(event) { console.log(<span style=\"color:Blue;\">this</span>.caption + <span style=\"color:#A31515;\">&#39; clicked!&#39;</span>); }\n}\nMyButton.prototype.tagName = <span style=\"color:#A31515;\">&#39;button&#39;</span>;\nMyButton.prototype.className = <span style=\"color:#A31515;\">&#39;btn&#39;</span>;\nMyButton.prototype.events = { <span style=\"color:#A31515;\">&#39;click&#39;</span>:<span style=\"color:#A31515;\">&#39;onClick&#39;</span> };\n<span style=\"color:Blue;\">var</span> button = <span style=\"color:Blue;\">new</span> MyButton();\r\n</pre></div>However this leads to unreadable code, especially on large classes, and undermines the class syntax of TypeScript. And after all the complaints of the possible inconsistencies introduced by this approach in this discussion, it does not document the developers intention as it does not clearly mark the property as being a property on the prototype.<br />\n<h1>Proposal</h1>\nTo solve this problems I would recommend to introduce a new keyword for marking properties in classes that should be set on the prototype and not on the instance. The keyword should express that the defined property is used by all instances of the class and clearly express the developers intention, therefore I would recommend ´shared´ or ´mutual´.\r<br />\n<br />\nThe above example would look like this:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> MyButton <span style=\"color:Blue;\">extends</span> Backbone.View{\n    caption:<span style=\"color:Blue;\">string</span> = <span style=\"color:#A31515;\">&#39;Submit&#39;</span>;\n    mutual tagName = <span style=\"color:#A31515;\">&#39;button&#39;</span>;\n    mutual className = <span style=\"color:#A31515;\">&#39;btn&#39;</span>;\n    mutual events = { <span style=\"color:#A31515;\">&#39;click&#39;</span>:<span style=\"color:#A31515;\">&#39;onClick&#39;</span> };\n    onClick(event) { console.log(<span style=\"color:Blue;\">this</span>.caption + <span style=\"color:#A31515;\">&#39; clicked!&#39;</span>); }\n}\r\n</pre></div>And should yield the following JavaScript code:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> MyButton = (<span style=\"color:Blue;\">function</span> (_super) {\n    __extends(MyButton, _super);\n    <span style=\"color:Blue;\">function</span> MyButton() {\n        _super.apply(<span style=\"color:Blue;\">this</span>, arguments);\n        <span style=\"color:Blue;\">this</span>.caption = <span style=\"color:#A31515;\">&#39;Submit&#39;</span>;\n    }\n    MyButton.prototype.tagName = <span style=\"color:#A31515;\">&#39;button&#39;</span>;\n    MyButton.prototype.className = <span style=\"color:#A31515;\">&#39;btn&#39;</span>;\n    MyButton.prototype.events = { <span style=\"color:#A31515;\">&#39;click&#39;</span>: <span style=\"color:#A31515;\">&#39;onClick&#39;</span> };\n    MyButton.prototype.onClick = <span style=\"color:Blue;\">function</span> (event) {\n        console.log(<span style=\"color:Blue;\">this</span>.caption + <span style=\"color:#A31515;\">&#39; clicked!&#39;</span>);\n    };\n    <span style=\"color:Blue;\">return</span> MyButton;\n})(Backbone.View);\r\n</pre></div>TypeScript should not try to solve inconsistencies introduced by JavaScript nor should it hide available features from the developer.<br />\n<h1>Antipattern shown in the examples</h1>\nEven more dangerous is the approach taken by the TodoMVC example (<a href=\"https://typescript.codeplex.com/sourcecontrol/latest#samples/todomvc/js/todos.ts\" rel=\"nofollow\">https://typescript.codeplex.com/sourcecontrol/latest#samples/todomvc/js/todos.ts</a>). As the developers must have stumbled upon the point of missing prototype properties, they simply set them as instance properties:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> TodoView <span style=\"color:Blue;\">extends</span> Backbone.View {\n    <span style=\"color:Green;\">// [...]</span>\n    <span style=\"color:Blue;\">constructor</span>(options?) {\n        <span style=\"color:Blue;\">this</span>.tagName = <span style=\"color:#A31515;\">&quot;li&quot;</span>;\n        <span style=\"color:Blue;\">this</span>.events = {\n            <span style=\"color:#A31515;\">&quot;click .check&quot;</span>: <span style=\"color:#A31515;\">&quot;toggleDone&quot;</span>,\n            <span style=\"color:#A31515;\">&quot;dblclick label.todo-content&quot;</span>: <span style=\"color:#A31515;\">&quot;edit&quot;</span>,\n            <span style=\"color:#A31515;\">&quot;click span.todo-destroy&quot;</span>: <span style=\"color:#A31515;\">&quot;clear&quot;</span>,\n            <span style=\"color:#A31515;\">&quot;keypress .todo-input&quot;</span>: <span style=\"color:#A31515;\">&quot;updateOnEnter&quot;</span>,\n            <span style=\"color:#A31515;\">&quot;blur .todo-input&quot;</span>: <span style=\"color:#A31515;\">&quot;close&quot;</span>\n        };\n        <span style=\"color:Blue;\">super</span>(options);\n        <span style=\"color:Green;\">// [...]</span>\n    }\n    <span style=\"color:Green;\">// [...]</span>\n}\r\n</pre></div>On the first glimpse this looks okay, but it introduces a series of problems:<br />\n<ul>\n<li>It might be tempting to set these values as default values on the class properties (actually in the same example the class ´TodoList´ does this with the prototype ´model´ property) but this does not work as TypeScript sets default values <em>after</em> ´super()´ has been called. However, Bootrsap.js relies on the values being set on the prototype and therefore accesses them right within the constructor, leading to the unexpected behavior of the default values being ignored.</li>\n<li>As you must set the values before the call to ´super()´ in the constructor, you actually cannot use TypeScript's default values in this class anymore.</li>\n<li>\nInheritance is completely ignored and classes written like this cannot be extended. Imagine you want to create a subclass of ´TodoView´, you normally would like to write something like this:\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> StaticTodoView <span style=\"color:Blue;\">extends</span>  TodoView {\n    <span style=\"color:Blue;\">constructor</span>(options?) {\n        <span style=\"color:Blue;\">this</span>.events = { <span style=\"color:#A31515;\">&quot;click&quot;</span>:<span style=\"color:#A31515;\">&quot;showDetails&quot;</span> };\n        <span style=\"color:Blue;\">super</span>(options)\n    }\n}\r\n</pre></div>As the constructor of ´TodoView´ will always overwrite ´this.events´, you have no chance to change the behavior of the view in sublasses. To get past this problem one would had to implement additional checks for whether the property is already set or not.\n</li>\n<li>\nEach time you create an instance of ´TodoView´ unnecessary objects will be created for setting the ´events´ property, all containing the exact same data. At least you should declare a static value and reuse that.<br />\n</li>\n</ul>\n<strong>Don't set properties on instances when prototype properties are required. Use the approach given by ahejlsberg</strong><br />\n",
    "PostedDate": "2013-09-20T05:18:14.317-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1096937",
    "ThreadId": "444777",
    "Html": "Hi,\r<br />\nI completely agree with current implantation as described by ahejlsberg, but syntactical sugar as proposed by DerCapac is also welcome. But rather than introducing new keyword &quot;mutual&quot; I would prefer 'prototype constructor', so the code will look like this:<br />\n<pre><code>class Foo {\n    prototype() {\n        a = true;\n        c = &quot;hello world&quot;;\n        d = 321;\n    }\n    a: boolean ;\n    c: string;\n    d: number = 4;\n}</code></pre>\n\ntcs can then generate correct code and ts source is much more readable. The prototype constructor is someway similar to static constructor, it is called once per class, but it can only contains properties assignments.\r<br />\n<br />\nThe other solution (not excluding first one) is to use static constructor, but then the syntax for properties setting should use prototype. Something like this.<br />\n<pre><code>class Foo {\n    static constructor() {\n        Foo.prototype.a = true;\n        Foo.prototype.c = &quot;hello world&quot;;\n        Foo.prototype.d = 321;\n    }\n    a: boolean ;\n    c: string;\n    d: number = 4;\n}\n</code></pre>\n\n",
    "PostedDate": "2013-09-20T06:35:35.253-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1488707",
    "ThreadId": "444777",
    "Html": "Here's a method that uses class decorators and generics to ensure that you don't assign a wrong type or to a property that doesn't exist on the class:<br />\n<pre><code>const mixin = &lt;B&gt;(behaviour: B) =&gt; &lt;M extends B, TFunction extends Function&gt;(Class: TFunction &amp; {new(...args: Array&lt;any&gt;): M}) =&gt; {\n    Reflect.ownKeys(behaviour).forEach(key =&gt; {\n        if(key !== 'constructor') {\n            if(Class.prototype.hasOwnProperty(key))\n                console.warn(`Warning: mixin property overrides ${Class.name}.${key}`);\n            Object.defineProperty(Class.prototype, key, Object.getOwnPropertyDescriptor(behaviour, key))\n        }\n    });\n    return Class;\n};\n\n@mixin({\n    bar: 'baz'\n})\nclass Foo {\n    bar: string;\n}\n\nconst foo = new Foo;\nconsole.log(Foo.prototype.bar, foo.bar, foo.hasOwnProperty('bar'));\n// prints baz baz false</code></pre>\n\nInheritance works fine and modifies only the sub-class prototype:<br />\n<pre><code>@mixin({\n    zip: 7,\n    bar: 'zaz'\n})\nclass Zoo extends Foo {\n    zip: number;\n}\n\nconst zoo = new Zoo;\nconsole.log(zoo.zip, zoo.bar, foo.bar);\n// prints 7 zaz baz</code></pre>\n\n",
    "PostedDate": "2016-11-24T00:21:56.12-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]