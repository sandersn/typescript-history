{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "As part of our move to GitHub, we're closing our CodePlex suggestions and asking that people move them to the GitHub issue tracker for further discussion.  Some feature requests may already be active on GitHub, so please make sure to look for an existing issue before filing a new one.\n\nYou can find our GitHub issue tracker here:\nhttps://github.com/microsoft/typeScript/issues\n",
    "ClosedDate": "2014-07-28T15:17:22.017-07:00",
    "CommentCount": 20,
    "Custom": null,
    "Description": "Hi. First of all, I'd like to thank all of you for the excellent work on TypeScript. I'm really excited about it.\r\n\r\nToday, while doing some experiments, I encountered a problem with the output generated by `tsc` for this fragment of source code:\r\n    \r\n    class A extends B {\r\n      // ...\r\n    }\r\n\r\n    class B {\r\n      // ...\r\n    }\r\n\r\nAs expected, the compiler finished execution normally, and produced the following output:\r\n\r\n```\r\n01  var __extends = this.__extends || function (d, b) {\r\n02      function __() { this.constructor = d; }\r\n03      __.prototype = b.prototype;\r\n04      d.prototype = new __();\r\n05  };\r\n06  var A = (function (_super) {\r\n07      __extends(A, _super);\r\n08      function A() {\r\n09          _super.apply(this, arguments);\r\n10  \r\n11      }\r\n12      return A;\r\n13  })(B);\r\n14  var B = (function () {\r\n15      function B() { }\r\n16      return B;\r\n17  })();\r\n```\r\n\r\nWhen I executed the code, I got the following error, on line 3:\r\n\r\n```\r\nUncaught TypeError: Cannot read property 'prototype' of undefined\r\n```\r\n\r\nIt seems that the current `__extends` implementation only works when the parent class is already initialized by the time the child class is initialized. This is of course a very minor issue for two classes in the same source file (as you can switch them around) and doesn't happen at all when using external modules (since `require(...)` will ensure dependencies are initialized on the right order) however, for internal modules defined with the `module` keyword across multiple files this can be a real issue, as in some circunstances you can't / don't want to specify the order the files are loaded/concatenated.\r\n\r\nI originally found out this bug when compiling multiple `.ts` files with the `tsc *.ts --out build.js` command.\r\n\r\n**Edit:** After fiddling a bit with the generated JS code, I believe I have a possible solution for this issue. It uses a similar approach to the one internal modules are currently using. The following code allows for inheritance regardless of the order the classes are declared in the file:\r\n\r\n```\r\nvar A = (function (_placeholder, _super) {\r\n    __init(_placeholder, A, _super, function (__super) {\r\n        __extends(A, _super = __super);\r\n    })\r\n    function A() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    return A;\r\n})(A, B || (B = { __pending: [] }));\r\n```\r\nIt works by allowing the initialization of the child class to occur on a later time, after the parent class has been initialized. It requires, however the presence of the following helper function in the generated code:\r\n\r\n```\r\nvar __init = this.__init || function(_placeholder, _class, _super, _callback) {\r\n    function __() {\r\n        for (var i = 0; i < _class.__pending.length; i++) {\r\n            _class.__pending[i](_class);\r\n        }\r\n        delete _class.__pending;\r\n    }\r\n    _class.__pending = _placeholder ? _placeholder.__pending : [];\r\n    if (_super && _super.__pending) {\r\n        _super.__pending.push(function(s) {\r\n            _callback(s);\r\n            __();\r\n        });\r\n    } else {\r\n        _callback(_super);\r\n        __();\r\n    }\r\n}\r\n```\r\n\r\nI'm not sure what is the policy for adding helper functions like this, but since we already have `__extends` in place, it might be OK to add another one.\r\n\r\n**PS: I'm new to CodePlex and was not aware comments would appear in reverse chronological order. I edited the original issue now, so it reads in the natural order. Sorry about that.**",
    "LastUpdatedDate": "2017-11-27T11:51:33.707-08:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Low",
      "Severity": 50,
      "Id": 1
    },
    "ProjectName": "typescript",
    "ReportedDate": "2013-01-20T18:31:21.067-08:00",
    "Status": {
      "Name": "Closed",
      "Id": 4
    },
    "ReasonClosed": {
      "Name": "External"
    },
    "Summary": "Inheritance only works if parent class is declared before child class.",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 32,
    "Id": 627
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "After fiddling a bit with the generated JS code, I believe I have a possible solution for this issue. It uses a similar approach to the one internal modules are currently using. The following code allows for inheritance regardless of the order the classes are declared in the file:\n\n```\nvar A = (function (_placeholder, _super) {\n    __init(_placeholder, A, _super, function (__super) {\n        __extends(A, _super = __super);\n    })\n    function A() {\n        _super.apply(this, arguments);\n    }\n    return A;\n})(A, B || (B = { __pending: [] }));\n```",
      "PostedDate": "2013-01-20T20:32:05.49-08:00",
      "Id": 86703
    },
    {
      "Message": "It works by allowing the initialization of the child class to occur on a later time, after the parent class has been initialized. It requires, however the presence of the following helper function in the generated code:\n\n```\nvar __init = this.__init || function(_placeholder, _class, _super, _callback) {\n    function __() {\n        for (var i = 0; i < _class.__pending.length; i++) {\n            _class.__pending[i](_class);\n        }\n        delete _class.__pending;\n    }\n    _class.__pending = _placeholder ? _placeholder.__pending : [];\n    if (_super && _super.__pending) {\n        _super.__pending.push(function(s) {\n            _callback(s);\n            __();\n        });\n    } else {\n        _callback(_super);\n        __();\n    }\n}\n```\n\nI'm not sure what is the policy for adding helper functions like this, but since we already have `__extends` in place, it might be OK to add this one.",
      "PostedDate": "2013-01-20T20:36:42.08-08:00",
      "Id": 86705
    },
    {
      "Message": "Assigning to Luke to weigh in on this one.",
      "PostedDate": "2013-01-21T14:03:15.537-08:00",
      "Id": 86807
    },
    {
      "Message": "I think I'd rather have the compiler reorder dependent classes rather than complicate the generated output script. Or, at the very least emit a warning saying that the class dependencies are defined in an order that may cause problems at runtime (depending on the JS engine - browser, node, cscript etc.)\n\nTypescript already reorders fields to the top of the class.",
      "PostedDate": "2013-01-25T10:16:44.363-08:00",
      "Id": 87334
    },
    {
      "Message": "Hmm, when concatenating multiple `.ts` files in a single `.js` output this approach is a very good fit.\n\nWhen multiple `.js` files are being generated by the compiler, perhaps it could also generate an additional loader file that automatically loaded the files in the right order? Like an `index.js` file that dynamically added `<script>` tags.",
      "PostedDate": "2013-01-25T13:26:05.447-08:00",
      "Id": 87388
    },
    {
      "Message": "I definitely agree that having to think about order feels less declarative (and exposes the JavaScript side).  In some sense, this is intentional because of how lightweight TypeScript is intended to be.  That said, if we assume your solution, can we work with a slightly different example:\n\n```TypeScript\nclass A extends B {\n  // ...\n}\nvar a = new A();  // need to see B's constructor here when doing super() call\nclass B {\n  // ...\n}\n```\n\nUnless we reorder the code for you, I think you still can come up with situations where a value hasn't been fully initialized.  In the example above, we need to know the full knowledge of B before it's known because we're call into its constructor.  At this time, we're explicitly not reordering code (or even adding code except in a couple of exceptions) that you've written.",
      "PostedDate": "2013-03-08T13:03:32.857-08:00",
      "Id": 92751
    },
    {
      "Message": "Can the compiler verify the order at least, and throw an error if it's not existing in the right area of the file?  That would be a sufficient enough syntactical sugar to meet the needs of the C# guys that are looking for a bit more structure, as well as the ECMAScript guys that are used to this sort of thing, I'd think... that is... if doing this wouldn't be too much trouble.\n\nThanks guys!  This is a wonderful product so far.",
      "PostedDate": "2013-03-28T18:29:01.127-07:00",
      "Id": 95216
    },
    {
      "Message": "sorry Oisin.. didn't really read through all the comments.. just wanted to put my $0.02 on the subject.",
      "PostedDate": "2013-03-28T18:30:15.067-07:00",
      "Id": 95217
    },
    {
      "Message": "Perhaps the significance of this feature/bug is underestimated. \n\nIn my app, which uses inheritance, the release html uses a single js and the debug uses a finely ordered set of script tags. Because of this reordering problem I'm unable to create a single application.js for the release build, directly from the individual modules I use in my debug build, without some post processing tool to extract the *.js from from the debug build and concatenate appropriately.\n\nIt's difficult for developers to track these kind of file by file orderings in 30+ ts files, not including the 'merge fun' it creates with a GIT/svn repository (\"Oh that's just a script tag, it not my concern\"). And it gets worst: different JIT compilers do things in awkward and often unpredictable ways. Recently I ran into a problem with the ordering of a debug build's script tags: on the desktop (IE, Firefox and Chrome), plus UIWebView on iOS, everything launched correctly. When I used the iOS version of Adobe's Folio Content Viewer, things were broken - out of order - until I placed a script defining an object ahead of a function using it. I'd like to think that was a difficult bug I could have been avoided with a single script release build, automatically ordered. \n\nI guess what I'm trying to get at is that is that it's difficult for developers to continually reorder things, and in my case, wait until I find a bug in what I'd already consider a tested order. It's more reliable, from my developers' point of view, for the compiler to give me the correct order via --out or otherwise.\n\nHope this helps.",
      "PostedDate": "2013-04-23T01:48:28.687-07:00",
      "Id": 97798
    },
    {
      "Message": "Same problem domain as [item #599](https://typescript.codeplex.com/workitem/599)",
      "PostedDate": "2013-04-25T23:50:06.413-07:00",
      "Id": 98561
    },
    {
      "Message": "@mattmelton - we're definitely thinking about how to handle ordering issues like this, but really it comes down to how lightweight TypeScript is intended to be.  In JavaScript, you still have to think about the ordering of how you initialize your classes and modules and statics (or their equivalent encoding in JavaScript).  It doesn't handle that for you.\n\nI agree that this is a bit frustrating to be so manual, but that a bit of the trade-off by trying to keep the output code very close to what you originally wrote.\n\nThat said, I think it'd definitely make sense, as much as possible, to warn the user when we can detect that the ordering will be incorrect.  This would work for single files, but becomes more complex (and even impossible) in other cases of multiple files and multiples build stages.",
      "PostedDate": "2013-10-24T10:32:21.247-07:00",
      "Id": 119546
    },
    {
      "Message": "Erm give just a \"warning\"? This is a serious error of the compiler. I think that the TypeScript compiler should compile into one file properly, or don't do that at all. Why just go half-way? And how can a correct ordering feature make TypeScript heavy weight? On the contrary, TypeScript is supposed to help facilitate large software projects. Indeed that is the sole reason for the existence of TypeScript! Otherwise we could all still be struggling with spaghetti JavaScript. Making compiled \"executable files\" actually \"execute\" should be a top priority.\n\nAnyways, super big thank you for all your work! You make the developer's everyday life so much easier. Hopefully, TypeScript shall not halt on his glorious way but should continue to deliver.",
      "PostedDate": "2014-01-06T07:41:44.977-08:00",
      "Id": 129214
    },
    {
      "Message": "I've ran into this a few times as well.  I always have to keep definition order in mind.  Note, however, that inline functions such as \"(function (){ ... })()\" are supported in modules, and reordering classes can break this support if an expected class suddenly ends up farther down.  Just something to keep in mind.",
      "PostedDate": "2014-04-04T08:37:35.353-07:00",
      "Id": 140551
    },
    {
      "Message": "I find this is a very serious issue, because the single file output feature is basically unusable for larger projects. But isn't it one of the core claims of typescript that it eases the pain of working in larger projects?\n\nIs there any workaround for this issue until the compiler helps?",
      "PostedDate": "2014-04-19T07:42:17.953-07:00",
      "Id": 142409
    },
    {
      "Message": "I don't understand why this isn't considered a more serious issue..\n\nI have a base class and sub classes in the same namespace (module) but in different ts-files and this error occurred.\n\nThe only way I managed to not get this error was to put the base class and sub-classes in the same file, which I don't really like. We can manage right now because there will not be that many sub-classes, but still.\n\nAm I doing something wrong?",
      "PostedDate": "2014-04-24T04:34:48.177-07:00",
      "Id": 142876
    },
    {
      "Message": "It isn't a great solution, but in the past I've worked around it by having a \"reference\" comment at the top of the file. This gives the compiler enough of a hint to order the output correctly\n\n```\n///<reference path=\"A.ts\"/>\nexport class B extends A {\n\n}\n```\n\nPlease fix this guys, it's probably the biggest source of headaches for me as a user of TypeScript.",
      "PostedDate": "2014-05-13T18:59:12.28-07:00",
      "Id": 146513
    },
    {
      "Message": "If you use Grunt, there's a grunt-ts task that will automatically produce a reference.ts file with the references in the correct order for you as part of the build.\n\nhttps://github.com/grunt-ts/grunt-ts#javascript-generation-and-ordering",
      "PostedDate": "2014-05-13T20:07:47.513-07:00",
      "Id": 146519
    },
    {
      "Message": "Awesome, no way to edit comments. Turns out grunt-ts only produces a listing of all the TS files, it's up to you to order them yourself. ",
      "PostedDate": "2014-05-13T20:28:03.32-07:00",
      "Id": 146520
    },
    {
      "Message": "Hi, welcome to CodePlex, where anything you say shall forever be immortalized. ;)",
      "PostedDate": "2014-05-13T21:53:01.18-07:00",
      "Id": 146525
    },
    {
      "Message": "This issue still exists and I'd like to see any error message rather than a broken code, if we need more time to fix this fundamentally.",
      "PostedDate": "2014-06-24T00:17:20.68-07:00",
      "Id": 150572
    }
  ]
}