[
  {
    "Id": "1151534",
    "ThreadId": "484232",
    "Html": "I'm trying to write a CommonJS declaration file for Bluebird, a promise library that directly exports a generic Promise class. However, the library also exports several other generic classes as static members (PromiseInspection), and it seems like its impossible to model this with typescript.<br />\n<br />\nEdit: Usage example, to illustrate how the module's exported class works:<br />\n<pre><code>import Promise = require('bluebird');\nvar promise:Promise&lt;number&gt; = Promise.cast(5);\nvar x:Promise.PromiseInspection&lt;number&gt; = promise.inspect();\n</code></pre>\n\nI tried several strategies - simplified examples follow:<br />\n<h3>1. The obvious way</h3>\n<pre><code>declare module &quot;bluebird&quot; {\n    class PromiseInspection&lt;T&gt; {\n        // ...\n    }\n    class Promise&lt;T&gt; {\n        PromiseInspection: typeof PromiseInspection; // error\n        constructor&lt;T&gt;();\n        inspect():PromiseInspection&lt;T&gt;; // error\n        static cast&lt;U&gt;(value:U):Promise&lt;U&gt;; \n        // ...\n    }\n    export = Promise;\n}\n</code></pre>\n\nFails with the error unable to use private type <code>PromiseInspection</code> as a public property<br />\n<h3>2. Using a static interface</h3>\n<pre><code>declare module &quot;bluebird2&quot; {\n    interface PromiseInspection&lt;T&gt; {\n        // ...  \n    }\n    interface Promise&lt;T&gt; {\n        constructor&lt;T&gt;();\n        inspect():PromiseInspection&lt;T&gt;;\n    }\n    interface PromiseStatic {\n        new&lt;T&gt;();\n        PromiseInspection:typeof PromiseInspection;\n        cast&lt;U&gt;(value:U):Promise&lt;U&gt;; // error\n    }\n    export = PromiseStatic;\n}\n</code></pre>\n\nAlso fails similarly, but this time the private type is Promise&lt;T&gt;<br />\n<h3>3. Trying to directly export a constructor function from the module</h3>\n<pre><code>declare module &quot;bluebird3&quot; {\n    export interface PromiseInspection&lt;T&gt; {\n        // ...\n    }\n    export interface Promise&lt;T&gt; {\n        constructor&lt;T&gt;();\n        inspect():PromiseInspection&lt;T&gt;;\n    }\n\n    export new&lt;T&gt;(); // syntax error\n    export function cast&lt;U&gt;(value:U):Promise&lt;U&gt;; \n}\n</code></pre>\n\nThis almost works, except of course its impossible to a constructor function that way.<br />\n<h3>4. The namespace polluting way (Works, with downsides)</h3>\n<pre><code>interface PromiseInspection&lt;T&gt; {\n    // ...\n}\ninterface Promise&lt;T&gt; {\n    constructor&lt;T&gt;();\n    inspect():PromiseInspection&lt;T&gt;;\n}\n\ndeclare module &quot;bluebird4&quot; {    \n    interface PromiseStatic {\n        new&lt;T&gt;():Promise&lt;T&gt;;\n        PromiseInspection: typeof PromiseInspection;\n        cast&lt;U&gt;(value:U):Promise&lt;U&gt;;\n    }\n    export = PromiseStatic;\n}\n</code></pre>\n\nWorks, but it pollutes the global namespace with both Promise and PromiseInspection. This <em>might</em> be okay but I'd rather avoid it as in CommonJS its usually considered unacceptable.<br />\n<h3>5. With declaration merging (gets me 90% of the way...)</h3>\n<pre><code>declare module &quot;bluebird5&quot; {\n    module Promise {\n        export interface PromiseInspection&lt;T&gt; {\n            value(): T;\n            // ...\n        }\n        export\n        function cast&lt;U&gt;(value: U): Promise&lt;U&gt; ;\n    }\n\n    class Promise&lt;T&gt; {\n        new &lt;T&gt; (): Promise &lt;T&gt; ;\n        inspect(): Promise.PromiseInspection &lt;T&gt; ;\n    }\n\n    export = Promise;\n}\n</code></pre>\n\nAlmost there - except that now I'm not allowed to replace <code>class Promise&lt;T&gt;</code> with <code>interface Promise&lt;T&gt;</code>, making <code>Promise&lt;T&gt;</code> unextendable. If I try to do it, the following code:<br />\n<pre><code>import Promise = require('bluebird');\nvar x = new Promise&lt;number&gt;();\nx.inspect().value().toExponential();\n</code></pre>\n\nfails with the error &quot;Invalid 'new' expression&quot;.<br />\n<br />\nAnother note: it was <strong>completely</strong> unintuitive to me that I had to use the <code>Promise.</code> prefix from inside the promise class declaration. I was expecting that the compiler will recognize that the declarations gets merged and allow me to simply use <code>PromiseInspection</code><br />\n<br />\n<a href=\"https://gist.github.com/spion/8327702\" rel=\"nofollow\">Link to the actual, work-in-progress bluebird.d.ts</a> - this one currently pollutes the global namespace (uses solution 4)<br />\n<br />\nIs there a better way to do this, or did I hit a language limitation?<br />\n",
    "PostedDate": "2014-01-09T14:16:23.727-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1151543",
    "ThreadId": "484232",
    "Html": "<ul>\n<li>merged into question -</li>\n</ul>\n",
    "PostedDate": "2014-01-09T14:40:57.68-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1151609",
    "ThreadId": "484232",
    "Html": "Writing your 'bluebird.d.ts' like this should do it:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">declare</span> <span style=\"color:Blue;\">module</span> Promise {\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">interface</span> PromiseInspection&lt;T&gt; {\n        value(): T;\n        <span style=\"color:Green;\">// ...</span>\n    }\n}\n\n<span style=\"color:Blue;\">interface</span> Promise&lt;T&gt; {\n    inspect(): Promise.PromiseInspection&lt;T&gt;;\n}\n\n<span style=\"color:Blue;\">declare</span> <span style=\"color:Blue;\">var</span> Promise: {\n    <span style=\"color:Blue;\">new</span> &lt;T&gt;(): Promise&lt;T&gt;;\n    cast&lt;U&gt;(value: U): Promise&lt;U&gt;;\n}\n\n<span style=\"color:Blue;\">export</span> = Promise;\r\n</pre></div>Writing it this way you have a separate declaration for each of the three meanings of the identifier Promise: As a namespace (a module containing only types), as a type (that happens to be generic), and as a value. There is no need to have a 'declare module &quot;bluebird&quot; { }' around the whole thing. The fact that you have an export assignment automatically causes the compiler to treat the file as an external module.<br />\n",
    "PostedDate": "2014-01-09T20:32:11.387-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1151725",
    "ThreadId": "484232",
    "Html": "Thanks, the compiler accepted that! Still, isn't it reasonable to expect that <code>PromiseInspection</code> wont need a namespace prefix if the declarations get merged? Prefixing everything inside <code>interface Promise&lt;T&gt; { ... }</code> is going to get very tedious, very fast!<br />\n<br />\nAlso as far as I can see, this means that I will have to export all class constructors from the var declaration, i.e.<br />\n<pre><code>RejectionError: new() =&gt; Promise.RejectionError;\n</code></pre>\n\nWouldn't everything be much simpler if the language allowed exporting a constructor function from the module? i.e.<br />\n<pre><code>declare module Promise {\n    export new&lt;T&gt;():Promise&lt;T&gt;\n}\n</code></pre>\n\nNow about the wrapper - I added <code>declare module &quot;bluebird&quot;</code> to be able to use the module in node.js by simply typing <code>import Promise = require('bluebird')</code>. <br />\n<br />\nThen I'd pass _references.d.ts to the compiler containing <br />\n<br />\n<code>///&lt;reference path=&quot;typedefs/bluebird/bluebird.d.ts&quot;&gt;</code><br />\n<br />\nThe compiler will now happily translate the import statement to <code>var Promise = require('bluebird')</code>, and node.js will happily use that to load the correct js file using its <a href=\"http://nodejs.org/api/modules.html#modules_all_together\" rel=\"nofollow\">module lookup algorithm</a> (will look up the <code>main</code> field in <code>node_modules/bluebird/package.json</code>, then load that file).<br />\n<br />\nThis is the only way I know of to make both happy, since tsc and node don't share the same lookup algorithm for module names that aren't prefixed with a dot. Or is there a better way?<br />\n",
    "PostedDate": "2014-01-10T04:19:54.87-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]