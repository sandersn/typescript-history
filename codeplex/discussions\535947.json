[
  {
    "Id": "1216279",
    "ThreadId": "535947",
    "Html": "You can read the brief description and discussion here: <a href=\"https://typescript.codeplex.com/workitem/2208\" rel=\"nofollow\">https://typescript.codeplex.com/workitem/2208</a><br />\n<br />\nAt stake is the brevity of lambdas in TypeScript. As Ryan demonstrates, a general solution for type inference is prohibitively time expensive to include in the compiler due to overloading and subtyping. However, I posit a weaker algorithm that is low cost and still applicable to a majority of practical cases.<br />\n<br />\nRyan requested that the discussion continue on the forum so that others could weigh in. If you have insight on this problem please provide what additional information you can to progress resolution of this issue.<br />\n<br />\nI will start with an addition to the original algorithm I posited that addresses an inconsistency. The following code sample demonstrates the problem.<br />\n<pre><code>function overload(x:number, y:number) {};\nfunction overload(x:string, y:string) {};\n\nfunction f(x, y) {\n  overload(x, y);\n  var z: number = y;\n}</code></pre>\n\nThe original algorithm visits the implicitly typed parameters in some pre-determined order. For sake of this example, let us assume that order is from left to right. If this order is taken, <em>x</em> is not inferred, because the candidate overloads for <code>overload</code> is <code>[[number, number], [string, string]]</code> and therefore the independent candidate type set (I will abbreciate to ICTS) for <em>x</em> is <code>{number, string}</code>.<br />\n<br />\nHowever, if we choose a right-to-left order, the type of <em>x</em> is inferred as <em>number</em>. This is because the ICTS for <em>y</em> is determined as <code>{number}</code>, and therefore the candidate overloads for <code>overload</code> is reduced to <code>[[number, number]]</code>, and thus the ICTS for <em>x</em> is reduced to <code>{number}</code>.<br />\n<br />\nTherefore, to solve the accident of ordering which parameter is inferred first, the inference algorithm can be changed slightly.<br />\n<pre><code>inferParams(scope, params):\n  return Foreach param (x) in params:\n    Let us = [u | u &lt;- foreach usage of x in scope:\n                         the independent set of candidate types for x]\n    Let ts = intersect us\n    return Case ts:\n      {t}: (x, TypeIs t)\n      {} : (x, NoType)\n      otherwise: (x, AmbigType)\n\ninferParamsFixpoint(scope, params):\n  Let r = inferParams(scope, params)\n  Let (typeIs, noType, ambigType) = (extractTypeIs(r), extractNoType(r),\n                                                      extractAmbigType(r))\n  Let scope' = applyToScope(typeIs, scope)\n  return Case typeIs:\n    []: (scope', r)\n    otherwise: typeIs ++ noType ++ inferParamsFixPoint(scope', ambigType)\n</code></pre>\n\nThe new addition is <em>inferParamsFixpoint</em> which repeatedly retries to infer parameters thought to be ambiguous (non-empty, non-singleton ICTS) as long as some parameters are being inferred. Applied to the example scenario, <em>x</em> is first ambiguous and so ends up in the <em>ambigType</em> list, whereas <em>y</em> is inferred as ends up in the <em>typeIs</em> list. Because <em>typeIs</em> is non-empty, <em>inferParamsFixPoint</em> recurses on the <em>ambigType</em> list with the new scope information resulting from the inference of <em>y</em>. Therefore on the second call to <em>inferParams</em>, <em>x</em> is successfully inferred. <em>inferParamsFixpoint</em> will recurse once more on the empty <em>ambigType</em> list, find that no new parameters were inferred (<em>typeIs</em> is empty), and terminate.<br />\n<br />\nThe pseudo-code that I have used is a made-up syntax but assumes a functional style. If this code is unclear I can instead mock an implementation in some real language like TypeScript or Haskell.<br />\n<br />\nThanks for your time and help.<br />\n",
    "PostedDate": "2014-02-28T11:55:22.77-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]