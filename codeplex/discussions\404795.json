[
  {
    "Id": "947978",
    "ThreadId": "404795",
    "Html": "\r\n<p>Case in point, using knockout.d.ts with --module AMD and the popular AMD loader RequireJS. The definition file (from\r\n<a href=\"https://github.com/borisyankov/DefinitelyTyped\">https://github.com/borisyankov/DefinitelyTyped</a>&nbsp;)&nbsp;as is won't work as it lacks an ambient external module declaration, so we have to add one. Unfortunately this leads to a duplication of\r\n members in the interfaces and the module declaration. This is a code smell. We need some way to declare external modules in a similar way to classes:</p>\r\n<p>declare module &quot;foo&quot; : KnockoutStatic;</p>\r\n<p>...or something else semantically obvious.</p>\r\n<p>Etc, etc etc.&nbsp;This is what my current knockout.d.ts file looks like in case you want to know (below). The two definitions are needed so that the imported module is typed correctly, and also if I need to type a parameter in a function.</p>\r\n<pre>// ...\r\ninterface KnockoutStatic {\r\n    utils: KnockoutUtils;\r\n    memoization: KnockoutMemoization;\r\n    bindingHandlers: KnockoutBindingHandlers;\r\n    virtualElements: KnockoutVirtualElements;\r\n    extenders: KnockoutExtenders;\r\n\r\n    applyBindings(viewModel: any, rootNode?: any): void;\r\n    applyBindingsToDescendants(viewModel: any, rootNode: any): void;\r\n\r\n    subscribable: KnockoutSubscribableStatic;\r\n    observable: KnockoutObservableStatic;\r\n    computed: KnockoutComputedStatic;\r\n    observableArray: KnockoutObservableArrayStatic;\r\n\r\n    contextFor(node: any): any;\r\n    isSubscribable(instance: any): bool;\r\n    toJSON(viewModel: any, replacer?: Function, space?: any): string;\r\n    toJS(viewModel: any): any;\r\n    isObservable(instance: any): bool;\r\n    dataFor(node: any): any;\r\n    removeNode(node: Element);\r\n}\r\n\r\ndeclare module &quot;knockout&quot; {\r\n    export var utils: KnockoutUtils;\r\n    export var memoization: KnockoutMemoization;\r\n    export var bindingHandlers: KnockoutBindingHandlers;\r\n    export var virtualElements: KnockoutVirtualElements;\r\n    export var extenders: KnockoutExtenders;\r\n\r\n    export function applyBindings(viewModel: any, rootNode?: any): void;\r\n    export function applyBindingsToDescendants(viewModel: any, rootNode: any): void;\r\n\r\n    export var subscribable: KnockoutSubscribableStatic;\r\n    export var observable: KnockoutObservableStatic;\r\n    export var computed: KnockoutComputedStatic;\r\n    export var observableArray: KnockoutObservableArrayStatic;\r\n\r\n    export function contextFor(node: any): any;\r\n    export function isSubscribable(instance: any): bool;\r\n    export function toJSON(viewModel: any, replacer?: Function, space?: any): string;\r\n    export function toJS(viewModel: any): any;\r\n    export function isObservable(instance: any): bool;\r\n    export function dataFor(node: any): any;\r\n    export function removeNode(node: Element);\r\n}</pre>\r\n<p>If you're not following me, the above definition is what permits RequireJS to be able to pass in an instance of the knockout module correctly to a typescript defined AMD module. This is my boot.js file being used by the require loader:</p>\r\n<pre>require.config({\r\n    paths: {\r\n        'myapp' : 'myapp-1.0',\r\n        'knockout': 'knockout-2.2'\r\n    }\r\n);\r\n\r\nrequire(['myapp'],\r\n    function (app) {\r\n        var foo = new app.MyClass();\r\n        foo.run();\r\n    }\r\n);\r\n</pre>\r\n<p>Here is the typescript app:</p>\r\n<pre>import ko = module(&quot;knockout&quot;);\r\n\r\nexport class MyClass {\r\n    constructor() {\r\n        // set up models etc\r\n        ko.applyBindings( ... );\r\n    }\r\n}\r\n</pre>\r\n<p>The corresponding generated javascript looks like this:</p>\r\n<pre>define([&quot;require&quot;, &quot;exports&quot;, &quot;knockout&quot;], function(require, exports, __ko__) {\r\n\r\n    var ko = __ko__;\r\n\r\n    var MyClass = (function () { \r\n    // ... etc\r\n</pre>\r\n",
    "PostedDate": "2012-11-27T14:26:27.97-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "948698",
    "ThreadId": "404795",
    "Html": "\r\n<p>@oisin:&nbsp; This is a good suggestion.&nbsp; It is closely related to&nbsp;the set of suggestions asking to allow&nbsp;something like &quot;export = &quot; inside modules to&nbsp;provide a specific value as the exported value of the module, instead of as a property on the module - similar\r\n to the &quot;module.exports = &quot; use cases in CommonJS.</p>\r\n<p>Doing something like &quot;export = &quot; would require a way of describing the 'type' of the module declaration.&nbsp; This would naturally lead to needing a syntax like 'declare module &quot;foo&quot; : KnockoutStatic;'.&nbsp; As you note, this is important to address for consuming\r\n existing libraries via AMD/CommonJS.</p>\r\n",
    "PostedDate": "2012-11-28T17:04:31.043-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]