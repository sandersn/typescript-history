[
  {
    "Id": "921946",
    "ThreadId": "398062",
    "Html": "\r\n<p>As I started to write this post on how I don't like class &quot;brands&quot; as described in the language spec, I discovered that the implementation in the Visual Studio 2012 plugin does not appear to follow the language spec. Here's the problematic code:<br>\r\n</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>\r\n<span style=\"color:blue\">class</span>&nbsp;Duck&nbsp;{\r\n&nbsp; &nbsp;&nbsp;constructor&nbsp;(<span style=\"color:blue\">public</span>&nbsp;name&nbsp;:&nbsp;string)&nbsp;{&nbsp;};\r\n}\r\n<span style=\"color:blue\">class</span>&nbsp;Dog&nbsp;{\r\n&nbsp; &nbsp;&nbsp;<span style=\"color:green\">// age: number; // Uncomment this line to see an error</span>\r\n&nbsp; &nbsp;&nbsp;constructor&nbsp;(<span style=\"color:blue\">public</span>&nbsp;name&nbsp;:&nbsp;string)&nbsp;{&nbsp;};\r\n}\r\n<span style=\"color:blue\">function</span>&nbsp;quack(duck:&nbsp;Duck)&nbsp;{\r\n&nbsp; &nbsp;&nbsp;alert(duck.name);\r\n}\r\n<span style=\"color:blue\">var</span>&nbsp;fido&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;Dog(<span style=\"color:#a31515\">'fido'</span>);\r\n<span style=\"color:blue\">var</span>&nbsp;rufus&nbsp;=&nbsp;{\r\n&nbsp; &nbsp;&nbsp;name:&nbsp;<span style=\"color:#a31515\">'rufus'</span>\r\n&nbsp;&nbsp;&nbsp;<span style=\"color:green\">// , age: 7 // Uncomment this line to see an error&nbsp;</span>\r\n};&nbsp;\r\nquack(<span style=\"color:blue\">new</span>&nbsp;Duck(<span style=\"color:#a31515\">'penelope'</span>));\r\nquack(fido);\r\nquack(rufus);\r\n\r\n</pre>\r\n</div>\r\n<p></p>\r\n<p><br>\r\nOn my machine the code above compiles without error.</p>\r\n<p><br>\r\nThis would seem to be in violation of the language spec (p21 and p29), although I'm happy that this compiles without error.Unfortunately uncommenting either of the marked lines triggers a compile error. I would expect (based on desire, not the language spec)\r\n that the code would compile regardless of whether the commented lines remain commented or are uncommented.</p>\r\n<p><br>\r\nIgnoring the implementation for now, a couple of the problematic areas of the language spec are this comment on p21</p>\r\n<p>&quot;For example, two classes with exactly the same member declarations are still not compatible because each class has a distinct brand&quot;</p>\r\n<p>and this part of the assignment compatibility section on p29</p>\r\n<p>&quot;M is a brand and S contains the same brand&quot;</p>\r\n<p><br>\r\nBriefly stated, I don't see enough value in checking the class brand on assignment using the current syntax. In strongly typed languages like C#, we see a lot of value by preferring abstract types (interfaces) over concrete types (classes). And in weakly typed\r\n languages like Javascript, we see a lot of value in duck typing for code reuse. These features are important for application-scale coding and branding classes in TypeScript is a move in the wrong direction - it's promoting overuse of concrete types and it\r\n makes class syntax much less useful because it will force users to define a separate interface that they can use in function signatures so they can avoid the brand check. This means that users will have to repeat themselves (same properties on the interface\r\n and on the class) early in development in order to avoid painting themselves in to a corner later. This also leads to complexity in teaching the language.</p>\r\n<p><br>\r\nI would prefer 'class Duck' syntax to be entirely equivalent to defining two interfaces ('interface Duck' for the instance members and 'interface Duck$class' for the statics and constructors) and one variable (to which the function object is assigned). Class\r\n syntax is nice - constructor functions with public parameters are great - so it would be good to be able to use 'class' to define and implement these interfaces in one go. I can't do that as long as brand checks happen on assignment by default.</p>\r\n<p><br>\r\nRelated to these discussions, can you provide us some kind of guidance in terms of what work you have planned and what contributions you are likely to accept from the community. Thanks.<br>\r\n<br>\r\n</p>\r\n",
    "PostedDate": "2012-10-04T09:11:10.05-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "922218",
    "ThreadId": "398062",
    "Html": "\r\n<p><a href=\"http://typescript.codeplex.com/discussions/397759\">If I'm not mistaken, this looks very similar to what I proposed</a>&nbsp;</p>\r\n<p>and unfortunately there are no answers so far.</p>\r\n<p>I fully support this idea - while unconventional (its not &quot;strict enough&quot; compared to other strongly typed languages), its by far a lot more useful and practical. Make mock objects, create completely new implementations that replace old implementations -\r\n without inheriting, without dependency injection, and without writing (&quot;extracting&quot;) boilerplate interface code.</p>\r\n<p>And if you really absolutely must have strict class checking you can use a more verbose syntax: class SpecificClass { SpecificClass: bool; }. or even have first-class language-level support, something like &quot;branded class SpecificClass&quot;.</p>\r\n<p>But non-strictness should be the default. Because sadly us developers often fail to foresee&nbsp;the need to use an interface instead of a class.</p>\r\n",
    "PostedDate": "2012-10-04T17:15:10.9-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "922279",
    "ThreadId": "398062",
    "Html": "<p>Yes, that's right- we both want the same thing. In fact, this section on page 8 of the spec's introduction strongly implies that at least one of the authors of the spec was thinking along the same lines:</p>\r\n<p>\"</p>\r\n<div class=\"page\" title=\"Page 14\">\r\n<div class=\"layoutArea\">\r\n<div class=\"column\">\r\n<p><span>This TypeScript </span><span>class declaration creates a variable named &lsquo;BankAccount&rsquo; whose value is the constructor function for &lsquo;BankAccount&rsquo; instances. This declaration also creates an </span><span>instance type of the same name. If we were to write this type as an interface it would look like the following. </span></p>\r\n<pre><span>       interface </span><span>BankAccount {\r\n           balance: </span><span>number</span><span>;\r\n</span></pre>\r\n<pre><span>           deposit(credit: </span><span>number</span><span>): </span><span>number</span><span>;\r\n       }\r\n</span></pre>\r\n<p><span>If we were to write out the function type declaration for t</span><span>he &lsquo;BankAccount&rsquo; constructor variable, it would </span><span>have the following form. </span></p>\r\n<p><span>var </span><span>BankAccount: </span><span>new</span><span>() =&gt; BankAccount;&nbsp;</span></p>\r\n</div>\r\n</div>\r\n</div>\r\n<p>\"</p>\r\n<p>If this were how it worked, we'd be happy.</p>",
    "PostedDate": "2012-10-04T21:39:55.927-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "922519",
    "ThreadId": "398062",
    "Html": "<p>This appears to be a bug in the compiler. According to the spec, only Duck and subclasses of Duck are assignable to Duck because other types would lack Duck's unique brand.</p>\r\n<p>Bug aside, the reasoning for this behavior is that classes represent more that just their public interface. Classes also contain internal state and implementation and something that happens to have the same public interface very likely won't have the&nbsp;appropriate internal state and implementation. In a sense the brand&nbsp;represents that state and implementation and ensures something incompatible isn't accidentally substituted.</p>\r\n<p>That said, I actually quite sympathize with your views. We've gone back and forth on brands in the design group and landed on the more conservative view, but there is definitely something to be said for having class instance types just be equivalent to interfaces.</p>",
    "PostedDate": "2012-10-05T09:24:57.293-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "922607",
    "ThreadId": "398062",
    "Html": "\r\n<p>Thanks for the response. Did you consider having additional syntax to trigger the brand check?</p>\r\n<p>How about an implementation where defining 'class Duck' corresponds to:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">interface</span> Duck {} <span style=\"color:green\">// Contains instance properties</span>\n\n<span style=\"color:blue\">interface</span> Duck$ <span style=\"color:blue\">extends</span> Duck {&nbsp;$Duck$brand: string; } <span style=\"color:green\">// Branded version of instance interface</span>\n</pre>\r\n</div>\r\n<p><span></span></p>\r\n<p><span>(plus an interface for the statics and constructors)</span></p>\r\n<p>That way when people define a function using 'Duck', the assignment check is non-branded:</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">function</span> myFunction(x : Duck) <span style=\"color:green\">// Non-branded - x just has to look like a duck</span>\n</pre>\r\n</div>\r\n<p></p>\r\n<p>And when people define a function using 'Duck$', the assignment check is branded:</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">function</span> myFunction(x : Duck$) <span style=\"color:green\">// Branded - x has to _be_ a Duck</span>\n</pre>\r\n</div>\r\n<p></p>\r\n<p>This would be easy to explain and nice to use.</p>\r\n<p>&nbsp;</p>\r\n<p>It would also allow the following code to compile:</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">interface</span> Dog { age: number; }\n\n<span style=\"color:blue\">interface</span> Dog { name: string; }\n\n\n\n<span style=\"color:blue\">var</span> dog: Dog = <span style=\"color:blue\">null</span>;\n\ndog.age = 7;\n\ndog.name = <span style=\"color:#a31515\">'Rufus'</span>;\n\n\n\n<span style=\"color:blue\">class</span> Duck { age: number; }\n\n<span style=\"color:blue\">interface</span> Duck { name: string; }\n\n\n\n<span style=\"color:blue\">var</span> duck : Duck = <span style=\"color:blue\">null</span>;\n\nduck.age = 7;\n\nduck.name = <span style=\"color:#a31515\">'Penelope'</span>;\n\n</pre>\r\n</div>\r\n<p>Currently interfaces are extensible while classes are not, so the code above involving ducks does not compile. Since my proposal is that 'class Duck' is shorthand for 'interface Duck' and 'interface Duck$', the code above which extends 'Duck' would compile\r\n under my proposal. I leave it unspecified whether the Duck$ interface would be extensible or not. Personally I would treat it like any other interface, so it would be extensible. But if you think the lack of extensibility of classes is an important feature,\r\n you could make the branded interface non-extensible and I'd still be happy as long as the non-branded interface is extensible.</p>\r\n",
    "PostedDate": "2012-10-05T12:17:20.123-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "922763",
    "ThreadId": "398062",
    "Html": "<p>Or, if the defaults are already set-in-stone, at least have it as an option:</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">function</span> f(a: Duck.like) {\r\n<span style=\"color: green;\">    // f accepts Duck-like classes now Duck.like is Duck's public interface.</span>\r\n}\r\n</pre>\r\n<p style=\"padding-left: 30px;\"><em>Classes also contain internal state and implementation and something that happens to have the same public interface very likely won't have the appropriate internal state and implementation. In a sense the brand represents that state and implementation and ensures something incompatible isn't accidentally substituted</em></p>\r\n<p>This is not very convincing, as its trivial to override all public methods using inheritance to make a completely different behavior (at least at the moment). But I do see how this can happen:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">class</span> Line {\r\n    x1: number, y1: number, x2: number, y2: number;\r\n    intersects: <span style=\"color: blue;\">function</span>(l: Line):bool {\r\n        <span style=\"color: green;\">// code that calculates intersection between lines</span>\r\n    }\r\n}\r\n\r\n<span style=\"color: blue;\">class</span> Rect {\r\n    x1: number, y1: number, x2: number, y2: number;\r\n    intersects: <span style=\"color: blue;\">function</span>(r: Rect):bool {\r\n        <span style=\"color: green;\">// code that calculates intersection between rects</span>\r\n    }\r\n}\r\n\r\n<span style=\"color: blue;\">var</span> l = <span style=\"color: blue;\">new</span> Line(); r = <span style=\"color: blue;\">new</span> Rect();\r\n\r\nl.intersect(r) != r.intersect(l) <span style=\"color: green;\">// both calls make no sense yet they're still allowed.</span>\r\n</pre>\r\n</div>\r\n</p>\r\n</div>",
    "PostedDate": "2012-10-06T03:20:31.57-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923617",
    "ThreadId": "398062",
    "Html": "<p>I appreciate your willingness to compromise, but I'd strongly prefer the non-branded interface to be the default. This decision is pretty central to defining how TypeScript feels and how it relates to Javascript. The positioning so far is that TypeScript extends Javascript, not that it's a strongly-typed language that happens to compile down to Javascript. This is an area where that messaging will see some friction.</p>\r\n<p>Having spent many years working in strongly typed languages where people constantly get bitten by overuse of concrete types, I firmly believe that it will benefit code quality and testability to have 'class X' produce a non-branded 'interface X'. There should be (minimal) extra typing if you want to use the branding. We've had interfaces in C++ and C# since forever, but people don't use them everywhere they should because they're not the 'default'. It'd be nice if TypeScript's default concept was 'interface' instead of 'class'. I recognize that TypeScript classes are less constraining than classes in other languages but there are still requirements on constructor calls and on the types of overriding members.</p>",
    "PostedDate": "2012-10-08T11:50:20.63-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923697",
    "ThreadId": "398062",
    "Html": "<p>I'm coming around to the point of view that a class should just define and implement a non-branded&nbsp;interface, and that we should simply get rid of brands. A strong argument is that writing a separate implementation of the interface really is equivalent to overriding all of the public methods on the class. Classes with private members will still appear to be branded because it is not possible to separately implement the private members. Effectively, you'd be able to substitute entirely separate implementations of the interface only if there are no private members in the class.</p>",
    "PostedDate": "2012-10-08T14:41:05.03-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "923729",
    "ThreadId": "398062",
    "Html": "\r\n<p>That's certainly promising news. I regret not fully describing public/private in my original proposal. I'll clarify my proposal so that 'class X' corresponds to these 3 interfaces:</p>\r\n<div>\r\n<ol>\r\n<li>interface X contains _public_ instance members </li><li>interface X$ extends X and adds _private_ instance members (and the brand if it continues to exist)\r\n</li><li>interface X$class contains _public_ statics/constructor </li></ol>\r\n<div>I assert that private members should not be present on the main interface. The aim of the proposal is to allow assignment from anything that implements the _public_ interface of 'class X' to&nbsp;a parameter typed as 'X'.</div>\r\n<div></div>\r\n<div>In the case where private members are present on the main interface, consider particularly the undesirable consequence of adding the first private member to a class in an existing code base. Private members are 'implementation details', but adding a single\r\n private member could cause unrelated code to fail to compile if 'X' means 'public and private members of X'. The majority of uses of 'X' will be in functions outside of class X. Private members are inaccessible in that context; yet the addition of a private\r\n member would cause that code to fail the assignment compatibility check. A function with parameter of type X defined outside class X doesn't and can't use private members of X, yet the compiler would complain if the argument couldn't supply those private members.\r\n For that reason and others I think it's important to separate the public interface from the rest.</div>\r\n<div></div>\r\n<div>It's true that within class X a developer might want to be sure that they are accessing instances of class X so that they can access private members. In that case, under my proposal, they would use 'X$' as their parameter type (or in a cast) to get access\r\n to the private members.</div>\r\n<div></div>\r\n<div>BTW under my proposal I believe the type of 'new X()' should be X (public only), not X$ (public and private). But I also believe that decision can be made separately from the decision about whether 'X' represents the public interface only or both public\r\n and private. (Although the more experience I get with TypeScript's type inference, the more convinced I am that the type of 'new X()' should be the public interface of X).</div>\r\n</div>\r\n",
    "PostedDate": "2012-10-08T15:55:30.537-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]