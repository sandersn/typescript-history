[
  {
    "Id": "1066778",
    "ThreadId": "449628",
    "Html": "Some frameworks, such as Ext JS or Sencha Touch, have their own class system. Trying to work with these in TS is proving difficult, because TS generates it's own wrapper logic for things like extends, super(), module, etc. These all affect the way the object is actually defined/structured in the JS, which won't work with the framework's class system.<br />\n<br />\nCould compiler flags be added to prevent TS from generating these things? Basically, in this case I'd want it to just compile the TS that is there to JS, but not add anything extra to the compiled output.<br />\n<br />\nIn other words, if I say &quot;class Foo extends Bar { ... }&quot;, don't create the extends wrapper and prototype merging. I want my IDE to know I'm extending the class, but I don't need the actual extends logic in the JS. There are other things going on that will actually handle the inheritance at runtime.<br />\n<br />\nIt seems like this wouldn't be difficult to do, and in addition to the large pool of developers using Sencha's platforms, I'm sure there are other cases (even just generating example code that doesn't need the wrapper logic) where this could be useful. Obviously by default it would keep working the way it does now. The new flag(s) would just be there for cases where someone actually needs to omit the extraneous code.<br />\n",
    "PostedDate": "2013-07-10T14:24:25.443-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1066847",
    "ThreadId": "449628",
    "Html": "+10\r<br />\n<br />\nI would really love to have this feature. Without it, I can't mix Ext/Sencha and Typescript.\r<br />\n<br />\nPersonally, I'd prefer something I can put in my Typescript source files rather than a compiler flag - because there are some classes in my solution where I want to use Ext's patterns, and others where Typescript's is fine. It would also make it easier to share source files and know they will compile correctly on other's computers.\r<br />\n<br />\nSomething like the following would be ideal:<br />\n<pre><code>class Snake extends(Ext.extend) Animal {</code></pre>\n\nwhere the &quot;parameter&quot; to the <code>extends</code> keyword is the existing function to call (expect the same signature as <code>__extends</code>). It would default to Typescript's own <code>__extends</code> if not provided. <br />\n",
    "PostedDate": "2013-07-10T18:42:46.913-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1066971",
    "ThreadId": "449628",
    "Html": "You can override the __extends function... Once you start working with typescript class system + modules loaders maybe you will not need Extjs class system....\r<br />\n<br />\nI figured out how integrate Ext 3.4 with typescript just overrinding __extends + Ext.create functions<br />\n",
    "PostedDate": "2013-07-11T03:45:21.74-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1067047",
    "ThreadId": "449628",
    "Html": "First, I'm curious how you overrode __extends and what you did, because I tried everything, including just making my version of __extends do NOTHING, and it still wouldn't work.\r<br />\n<br />\nSecond, we really shouldn't have to manually override __extends and try to outfox TS in the generated JS. Just letting us omit this extra logic would seem to be a lot easier and more transparent.\r<br />\n<br />\nFor example, consider this TS:<br />\n<pre><code>declare module MyApp.foo {\n    export class MyBaseClass {\n        doSomething(): void\n    }\n}\n\nmodule MyApp.foo.bar {\n    class MyClass extends MyApp.foo.MyBaseClass {\n        constructor() {\n            super();\n        }\n    } \n}</code></pre>\n\nThe resulting JS is:<br />\n<pre><code>var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar MyApp;\n(function (MyApp) {\n    (function (foo) {\n        (function (bar) {\n            var MyClass = (function (_super) {\n                __extends(MyClass, _super);\n                function MyClass() {\n                    _super.call(this);\n                }\n                return MyClass;\n            })(MyApp.foo.MyBaseClass);\n        })(foo.bar || (foo.bar = {}));\n        var bar = foo.bar;\n    })(MyApp.foo || (MyApp.foo = {}));\n    var foo = MyApp.foo;\n})(MyApp || (MyApp = {}));</code></pre>\n\nI'd like to be able to tell the compiler to remove everything that it can from all this, and just give me something like:<br />\n<pre><code>var MyClass;\n\nMyClass = (function() {\n\n  function MyClass() {}\n\n  return MyClass;\n\n})();</code></pre>\n\nBasically don't spit out anything for the module wrappers, extends, super, etc. I'm telling the compiler that something else is dealing with all of this. Since it doesn't really affect the core of the generated code, only the outer wrappers and the way the JS &quot;class&quot; is defined, I would think this should be pretty easy do it.<br />\n",
    "PostedDate": "2013-07-11T07:12:10.93-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1067088",
    "ThreadId": "449628",
    "Html": "Here is the code to intercept __extends function. I didn test with Ext4.<br />\n<pre><code>module Ext {\n    export class TypeScript {\n\n        private static _extCreate = Ext.create;\n\n        static extExtend(base: Function, config: any) {\n            var cls = Ext.extend(base, {\n                constructor: function (config) {\n                    //alguns componentes (ex:splitRegion) utilizam a propriedade initialConfig\n                    this.initialConfig = config;\n                    //nao chamar super class agora porque as classes\n                    //que derivam irao setar propriedades \n                    //sera necessario utilizar tsInit\n                },\n                tsInit: function () {\n                    TypeScript.initConstructor(this, cls);\n\n                }\n            }, config);\n\n            return cls;\n        }\n        static initConstructor(cmp : any, cls : Function) : void {\n            Ext.apply(cmp, cmp.initialConfig);\n            \n            //as classes deverao chamar initialize apos o construtor\n            (&lt;any&gt;cls).superclass.constructor.call(cmp, cmp.initialConfig);\n        }\n       static createComponent(config, defaultType) {\n           var cmp = TypeScript._extCreate.call(Ext, config, defaultType);\n            if (cmp.tsInit) {\n                //chamar apenas uma vez o construtor \n                cmp.tsInit();\n            }\n            return cmp \n        }\n        static tsExtend(derived : Function, base : Function){\n             function __() { \n                //hack necessario para Ext4\n                this.constructor = base.prototype.constructor; \n            }\n\n            __.prototype = base.prototype;\n            derived.prototype = new __();\n        }\n\n    }\n}\n\n//intercepta metodo de extensao do TypeScript\nvar __extends = this.__extends = Ext.TypeScript.tsExtend;\n\n//interceptar funcoes do Ext\n(&lt;any&gt;Ext).create = (&lt;any&gt;Ext).ComponentMgr.create = Ext.TypeScript.createComponent;\n//criar classes interceptadas\n(&lt;any&gt;Ext).TsContainer = Ext.TypeScript.extExtend(Ext.Container, {});\n(&lt;any&gt;Ext).TsBoxComponent = Ext.TypeScript.extExtend(Ext.BoxComponent, {});\n(&lt;any&gt;Ext).TsPanel = Ext.TypeScript.extExtend(Ext.Panel, {});\n(&lt;any&gt;Ext).TsTabPanel = Ext.TypeScript.extExtend(Ext.TabPanel, {});\n(&lt;any&gt;Ext).TsToolbar = Ext.TypeScript.extExtend(Ext.Toolbar, {});\n(&lt;any&gt;Ext).TsWindow = Ext.TypeScript.extExtend(Ext.Window, {});\n(&lt;any&gt;Ext).tree.TsTreePanel = Ext.TypeScript.extExtend(Ext.tree.TreePanel, {});\n(&lt;any&gt;Ext).menu.TsMenu = Ext.TypeScript.extExtend(Ext.menu.Menu, {});\n//necessario para classes que derivam de Observable e desejam adicionar construtor padrao\n(&lt;any&gt;Ext).util.TsObservable = Ext.TypeScript.extExtend(Ext.util.Observable, {} );\n(&lt;any&gt;Ext).form.TsFieldSet = Ext.TypeScript.extExtend(Ext.form.FieldSet, {});\n(&lt;any&gt;Ext).form.TsTwinTriggerField = Ext.TypeScript.extExtend(Ext.form.TwinTriggerField, {});\n(&lt;any&gt;Ext).grid.TsGridPanel = Ext.TypeScript.extExtend(Ext.grid.GridPanel, {});\n(&lt;any&gt;Ext).grid.TsEditorGridPanel = Ext.TypeScript.extExtend(Ext.grid.EditorGridPanel, {});</code></pre>\n\n",
    "PostedDate": "2013-07-11T08:33:34.807-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]