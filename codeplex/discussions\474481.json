[
  {
    "Id": "1137462",
    "ThreadId": "474481",
    "Html": "In some scenarios we need to transform function (make new one) with some modifications of its signature. For example, in curry we transform <code>(a, b) =&gt; c</code> into <code>a =&gt; b =&gt; c</code>. I've got an issue with such scenario when tried to define signatures for <a href=\"https://github.com/borisyankov/DefinitelyTyped/blob/switch-0.9.5/rx.js/rx.async.d.ts#L13-L37\" rel=\"nofollow\"><code>RxJS's Rx.Observable.toAsync</code></a> in DefinitelyTyped.\r<br />\n<br />\nSo the problem <a href=\"https://typescript.codeplex.com/discussions/472172\" rel=\"nofollow\">is again</a> with new call overload resolution rules defined in 0.9.5.\r<br />\n<br />\nI'll try to describe with simple example.\r<br />\nWe need to describe signature of function that take a function as parameter and return a new function with replaced return type but with same parameter list. To simplify, let's say, the parameter function can be without parameter or with one optional parameter (in my code I provide overloads for any combination up to 4 parameters):<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">// function that removes return parameter</span>\n<span style=\"color:Blue;\">interface</span> F {\n    &lt;T&gt;(func: () =&gt; T): () =&gt; <span style=\"color:Blue;\">void</span>;\n    &lt;T1, T&gt;(func: (a?: T1) =&gt; T): (a?: T1) =&gt; <span style=\"color:Blue;\">void</span>; \n}\n<span style=\"color:Blue;\">var</span> f: F;\n\nf(() =&gt; 1)();   <span style=\"color:Green;\">// ok, infered T is number</span>\nf((a?: <span style=\"color:Blue;\">string</span>) =&gt; 1)(<span style=\"color:#A31515;\">&quot;&quot;</span>);   <span style=\"color:Green;\">// fail, used first overload</span>\r\n</pre></div>In second usage example, the first overload is chosen by TS, because <code>(a?: string)=&gt;number</code> convertible to <code>() =&gt; number</code>.\r<br />\nOk, let's switch order of the overloads:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">interface</span> G {\n    &lt;T1, T&gt;(func: (a?: T1) =&gt; T): (a?: T1) =&gt; <span style=\"color:Blue;\">void</span>;\n    &lt;T&gt;(func: () =&gt; T): () =&gt; <span style=\"color:Blue;\">void</span>; \n}\n<span style=\"color:Blue;\">var</span> g: G;\n\ng(() =&gt; 1)();   <span style=\"color:Green;\">// used first overload, but expected that will be used second</span>\ng(() =&gt; 1)(1);  <span style=\"color:Green;\">// ok, but expected error</span>\ng((a?: <span style=\"color:Blue;\">string</span>) =&gt; 1)(<span style=\"color:#A31515;\">&quot;&quot;</span>);   <span style=\"color:Green;\">// ok, used first overload</span>\r\n</pre></div>In this case, for first call with <code>() =&gt; number</code> function as argument used first overload that accepts <code>(a?: {}) =&gt; number</code> (actually via <a href=\"https://typescript.codeplex.com/workitem/2031\" rel=\"nofollow\">bug #2031</a> it infers <code>(a?: number) =&gt; {}</code>).\r<br />\n<br />\nSo here is the problem:<br />\n<ul>\n<li>when we have two functions with signatures <code>A</code>, <code>B</code></li>\n<li><code>A</code> convertible to <code>B</code> and <code>B</code> convertible to <code>A</code> (like <code>()=&gt;number</code> and <code>(a?:any)=&gt;number</code>)</li>\n<li>\nwhen we need different overloads for parameters of type <code>A</code> and <code>B</code>\r<br />\nthen <strong>any ordering of overloads won't solve the task</strong>.<br />\n</li>\n</ul>\nTo solve it we need overload resolution that tries to choose the best of overloads.\r<br />\nPleeease, revert previous resolution mechanism. It was much much better. =)<br />\n",
    "PostedDate": "2013-12-18T04:16:44.747-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1137701",
    "ThreadId": "474481",
    "Html": "I believe a similar problem also affects definition files for libraries like BreezeJS. Their use of overloads to describe their <code>using</code> function no longer compiles in 0.9.5 as it did in 0.9.1.1. I suspect this is because the types <code>MergeStrategySymbol</code> and <code>FetchStrategySymbol</code> are convertible.<br />\n<pre><code>class EnumSymbol {\n  parentEnum: IEnum;\n  getName(): string;\n  toString(): string;\n}\n\nclass MergeStrategySymbol extends breezeCore.EnumSymbol {\n}\n\nclass FetchStrategySymbol extends breezeCore.EnumSymbol {\n}\n\n...\n\nclass QueryOptions {\n  static defaultInstance: QueryOptions;\n  fetchStrategy: FetchStrategySymbol;\n  mergeStrategy: MergeStrategySymbol;\n\n  constructor (config?: QueryOptionsConfiguration);\n\n  setAsDefault(): void;\n  using(config: QueryOptionsConfiguration): QueryOptions;\n  using(config: MergeStrategySymbol): QueryOptions; // **** Compiler Error in TS 0.9.5. ****\n  using(config: FetchStrategySymbol): QueryOptions;  // **** Convertible to MergeStrategySymbol ****\n}\n\n...\n</code></pre>\n\nFor situations like this, what is the recommended fix?<br />\n",
    "PostedDate": "2013-12-18T11:00:09.387-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1137719",
    "ThreadId": "474481",
    "Html": "Yes, it have the same reasons.\r<br />\nMore then that, by new specification impossible (compiler error) to define overloads with exactly same signatures.\r<br />\nIn your example <code>MergeStrategySymbol</code> and <code>FetchStrategySymbol</code> have exactly same structure, so its same type.\r<br />\nI agree, that it may fix some problems, but I think compiler should only generate warning and allow to define overloads when it use different type reference (names of type). In your code, I think, no errors/warning should be, but warning if you define overload with same names more then once.\r<br />\n<br />\nLet me show example. Consider we have <code>base.d.ts</code> library:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">interface</span> Smth {\n  f(): <span style=\"color:Blue;\">void</span>;\n}\n<span style=\"color:Blue;\">interface</span> Other {\n  g(): <span style=\"color:Blue;\">void</span>;\n}\n\n<span style=\"color:Blue;\">var</span> SuperLib: {\n  (smth: Smth): Smth;\n  (other; Other): Other;\n};\r\n</pre></div>This code compiles with no errors.\r<br />\nAnd we have children libraries, that provide additional definitions to our interfaces <code>Smth</code> and <code>Other</code> (like most of jQuery extensions). <code>base.smth.d.ts</code>:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">///&lt;reference path=&quot;base.d.ts&quot;/&gt;</span>\n<span style=\"color:Blue;\">interface</span> Smth {\n  g(): <span style=\"color:Blue;\">void</span>;\n}\r\n</pre></div>and <code>base.other.d.ts</code>:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">///&lt;reference path=&quot;base.d.ts&quot;/&gt;</span>\n<span style=\"color:Blue;\">interface</span> Other {\n  f(): <span style=\"color:Blue;\">void</span>;\n}\r\n</pre></div>If we'll use just one of the children libraries it will be compiled with no errors.\r<br />\nBut if we will use both of them, interfaces <code>Smth</code> and <code>Other</code> become identical by structure and overload in <code>base.d.ts</code> will fail with compiler error.\r<br />\nIt's so unexpected!<br />\n",
    "PostedDate": "2013-12-18T11:24:48.753-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1137796",
    "ThreadId": "474481",
    "Html": "Agreed. It certainly unexpected and doesn't seem ideal. \r<br />\n<br />\nFurthermore, if you are relying on TypeScript to help provide tooling like VS with IntelliSense it's also problematic. In this case when you are trying to define different overloads with varying behaviors (that have different type references, but are structurally the same) it makes it impossible. <br />\n",
    "PostedDate": "2013-12-18T13:00:34.103-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]