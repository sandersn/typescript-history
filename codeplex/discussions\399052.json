[
  {
    "Id": "925578",
    "ThreadId": "399052",
    "Html": "\r\n<p>The `this` is sometimes supplied to a callback function and is expected to be of a certain type.</p>\r\n<p>For example, the functions passed to the JQueryUI Widget factory will be provided a `this` which meets an interface, say JQueryUIWidget.</p>\r\n<p>How can we model the `_create()` function of the custom Widget prototype so that the implicit `this` parameter is known to the type inferencer to implement&nbsp;JQueryUIWidget?</p>\r\n<p>Thanks!</p>\r\n",
    "PostedDate": "2012-10-11T17:18:56.567-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "925591",
    "ThreadId": "399052",
    "Html": "\r\n<p>I just kind of mocked this up to run in the playground and I've never tried to implement a JQueryUI Widget so this may or may not help.&nbsp; It does show how you can get a strongly typed 'this' pointer for something that isn't a class.</p>\r\n<p>Scanning the docs for creating a widget it looks like they want you to call $.widget() with the name of your widget and the widgets definition.&nbsp; So I extended JQuery to support the $.widget() method and then implemented a base JQueryUIWidget interface\r\n (not complete) defining the members common to all widgets.&nbsp; This is essentially a base class and it looks like your widget is free to add any other members it wants so I modeled that by defining a DemoWidget interface that extends JQueryUIWidget.&nbsp;\r\n In the call to $.widget() I then cast the JSON object passed in to be an instance of DemoWidget which works because it extends JQueryUIWidget.&nbsp; Within each function definition you now have a strongly typed 'this' pointer which is what you want.&nbsp;</p>\r\n<div style=\"background-color:white; color:black\">\r\n<pre>declare <span style=\"color:blue\">var</span> jQuery: JQuery;\r\n\r\n(<span style=\"color:blue\">function</span>( $: JQuery ) {  \r\n\t$.widget( <span style=\"color:#a31515\">&quot;demo.multi&quot;</span>, &lt;DemoWidget&gt;{\r\n     \t<span style=\"color:green\">// These options will be used as defaults    </span>\r\n\t\toptions: { \r\n      \t\tclear: <span style=\"color:blue\">null</span>\r\n\t\t},\r\n     \t<span style=\"color:green\">// Set up the widget</span>\r\n    \t_create: <span style=\"color:blue\">function</span>() {    \r\n\t\t\t<span style=\"color:blue\">this</span>.foo = <span style=\"color:#a31515\">'test'</span>;\r\n\t\t},\r\n \r\n    \t<span style=\"color:green\">// Use the _setOption method to respond to changes to options    </span>\r\n\t\t_setOption: <span style=\"color:blue\">function</span>( key, value ) {      \r\n\t\t\t<span style=\"color:blue\">switch</span>( key ) {\r\n        \t\t<span style=\"color:blue\">case</span> <span style=\"color:#a31515\">&quot;clear&quot;</span>:\r\n          \t\t<span style=\"color:green\">// handle changes to clear option          </span>\r\n\t\t  \t\t<span style=\"color:blue\">break</span>;      \r\n\t\t\t}\r\n \r\n      \t\t<span style=\"color:green\">// In jQuery UI 1.8, you have to manually invoke the _setOption method from the base widget      </span>\r\n\t  \t\t$.Widget.prototype._setOption.apply( <span style=\"color:blue\">this</span>, arguments );\r\n      \t\t<span style=\"color:green\">// In jQuery UI 1.9 and above, you use the _super method instead</span>\r\n\t\t\t<span style=\"color:blue\">this</span>._super( <span style=\"color:#a31515\">&quot;_setOption&quot;</span>, key, value );    \r\n\t\t},\r\n \r\n    \t<span style=\"color:green\">// Use the destroy method to clean up any modifications your widget has made to the DOM    </span>\r\n\t\tdestroy: <span style=\"color:blue\">function</span>() {\r\n\t\t\t<span style=\"color:green\">// In jQuery UI 1.8, you must invoke the destroy method from the base widget      </span>\r\n\t\t\t$.Widget.prototype.destroy.call( <span style=\"color:blue\">this</span> );\r\n\t\t\r\n\t\t\t<span style=\"color:green\">// In jQuery UI 1.9 and above, you would define _destroy instead of destroy and not call the base method    </span>\r\n\t\t}  \r\n\t});\r\n}( jQuery ) );\r\n\r\n<span style=\"color:blue\">interface</span> JQuery {\r\n\twidget(name:string, widget: JQueryUIWidget);\r\n\tWidget: any;\r\n}\r\n\r\n<span style=\"color:blue\">interface</span> JQueryUIWidget {\r\n\toptions?:any;\r\n\t_create: () =&gt; any;\r\n\t_setOption?: (key: string, value) =&gt; any;\r\n\tdestroy?: () =&gt; <span style=\"color:blue\">void</span>;\r\n}\r\n\r\n<span style=\"color:blue\">interface</span> DemoWidget <span style=\"color:blue\">extends</span> JQueryUIWidget {\r\n\tfoo: string;\r\n}\r\n</pre>\r\n</div>\r\n",
    "PostedDate": "2012-10-11T18:36:38.937-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "925805",
    "ThreadId": "399052",
    "Html": "<p>Thanks for alerting me to type assertions. &nbsp;I don't like this approach very much, though. &nbsp;The object literal is a widget prototype - it isn't a Widget itself, and it doesn't inherit. &nbsp;It's just a bag of static methods which will be .call(widget, ...) or .apply(widget, [...]) by the consuming $.widget() code. &nbsp;We have to put question marks on every member, since they're all optional for the prototype to supply even though the supplied `this` will actually have those things.</p>\r\n<p>I'm thinking that a syntax like the following would work to optionally supply the type information to the otherwise implicit `this` parameter. &nbsp;An optional first parameter called \"this\", which is I think illegal in javascript and so would not pose any conflict, should be allowed:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>$.widget( <span style=\"color: #a31515;\">\"demo.multi\"</span>, {\r\n    _setOption: <span style=\"color: blue;\">function</span>( <strong><span style=\"color: blue;\">this</span> : JQueryUIWidget, </strong>key: string, value) { \r\n        <span style=\"color: blue;\">this</span>._trigger(...); \r\n    } \r\n});\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p><br />When calling this function, the type inferencer and intellisense would know not to expect a value for that first parameter in the arguments list. &nbsp;But it could help enforce that the function is .call()ed or .apply()ed correctly.</p>\r\n<p>It would be useful in lots of scenarios, but I'm having trouble coming up with a more general example. &nbsp;In many very general situations, the cheat of section&nbsp;4.9.2 Arrow Function Expressions works because outer scope knows supplies a closure (unlike the case of the widget), or as in the callback for Array.forEach, `this` is already correctly the target array.</p>",
    "PostedDate": "2012-10-12T06:45:19.5-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "933525",
    "ThreadId": "399052",
    "Html": "<p>I use a kind of hack, but it seems to work :&nbsp;<br /><br />var that : JQuery = &lt;JQuery&gt;&lt;Object&gt;this;<br /><br />&lt;JQuery&gt;this alone does not work, you get an error that this can not be cast to JQuery.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-10-28T09:14:16.277-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]