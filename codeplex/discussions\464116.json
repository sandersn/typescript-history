[
  {
    "Id": "1113804",
    "ThreadId": "464116",
    "Html": "Greetings!<br />\n<br />\nA quick search reveals that this issue has been brought up a couple of times before, but I believe that I have a different enough view/point to warrant a new thread (discussion) on the issue.<br />\n<br />\nFrom what I understand, Typescript is supposed to be a strongly typed, object-oriented language that compiles to javascript.<br />\n<br />\nHowever, there is still a relic (quirk) of javascript that typescript does not yet abstract away, namely, the variable this context. When I create a typescript function inside of a class like so:<br />\n<pre><code>class FooBar {\n    bar: number = 0;\n    foo(){\n        return this.bar;\n    }\n}\n</code></pre>\n\nTypescript compiles to:<br />\n<pre><code>var FooBar = (function () {\n    function FooBar() {\n        this.bar = 0;\n    }\n    FooBar.prototype.foo = function () {\n        return this.bar;\n    };\n    return FooBar;\n})();\n</code></pre>\n\nThis allows for the this context to get changed by anything that calls foo, which doesn't make sense from an object-oriented perspective. Being able to change the this context would make sense in the context of a <em>static</em> function, but not in a member function. If I was to code something similar in a language like C++/C#, I would always assume that the this context would be invariable, and set to the class object.<br />\n<br />\nI understand that there are coding patterns in typescript that will compile to functions with bound this contexts, but they all involve lambda functions that cannot be inherited (one of the greatest benefits of Object Oriented design).<br />\n<br />\nIf that wasn't enough of a case for bound this contexts in member functions, there is also the matter of the type of the this keyword. Typescript always assumes that the type of the this keyword is the type of the function's parent class object. However, that is not enforced! This means that a framework that takes callbacks (I'm looking at you Knockout, JQuery), could (and often does) change the this context of function callbacks. This effectively results in a function callback with a this context with a different type then that of the parent class object, and violates Typescript's typing. Having a bound this context prevents this behaviour.<br />\n<br />\nI would argue that Typescript should be modified to always bind the this context to the class object (what most people coming from OO languages would expect) for non-static functions, or at the very least, make the this context get bound by default, with an optional (opt-out) keyword. This would add consistency, and make the transition from an OO language to Typescript easier.<br />\n<br />\nI welcome any counter-points or discussion. I really like Typescript, and want it to be the best language (dialect?) possible.<br />\n",
    "PostedDate": "2013-10-29T12:49:33.803-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1113850",
    "ThreadId": "464116",
    "Html": "There's a lot to cover on this topic, so thank you for starting a forum post :)\r<br />\n<br />\nOne of the key reasons we don't automatically bind every class member function to its instance is memory / performance. The additional overhead of an extra closure per method per class instance would quickly make TypeScript unusable for large-scale projects, which would be a bit self-defeating with our goal of making application-scale development easier. We added the ability to have per-instance methods so that people could opt-in to this behavior (see below); I think this covers the use case pretty well but would be interested to hear where it's falling short for you.\r<br />\n<br />\nI'm not sure what you mean about the per-instance functions not being inheritable. This works, for example:<br />\n<pre><code>    class Base {\n        constructor(public name: string) { }\n        hello = () =&gt; console.log('hello I am ' + this.name);\n    }\n\n    class Derived extends Base {\n        hello = () =&gt; console.log('hi there I am ' + this.name);\n    }\n\n    var h1 = (new Base('b')).hello;\n    h1(); // Works\n    var h2 = (new Derived('d')).hello;\n    h2(); // Works\n</code></pre>\n\nWhile it's true that Derived.hello can't invoke Base.hello, that's fundamentally a runtime problem (there isn't code we could emit that would work).\r<br />\n<br />\nWe've talked about allowing user code to specify the type of the 'this' parameter in a function signature. I don't think it fits in the v1 schedule, but I don't remember any reason we can't do it later. Personally I've been writing <code>var self = &lt;T&gt;this;</code> in those cases - not ideal, but it works.<br />\n",
    "PostedDate": "2013-10-29T14:36:57.757-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1114279",
    "ThreadId": "464116",
    "Html": "Perhaps I don't understand closures as well as I thought I did.<br />\n<pre><code>var FooBar = (function () {\n    function FooBar() {\n        var _this = this;\n        this.bar = &quot;stuff&quot;;\n        this.foo = function () {\n            _this.bar = &quot;newstuff&quot;;\n            return _this.bar;\n        };\n        this.foo2 = function () {\n            return _this.bar;\n        };\n    }\n    return FooBar;\n})();\n\nvar bar = new FooBar();\nconsole.log(bar.foo2());\nconsole.log(bar.foo());\nconsole.log(bar.foo2());</code></pre>\n\nRunning this logs:<br />\n<pre><code>stuff\nnewstuff\nnewstuff</code></pre>\n\nDoesn't this only create a closure once? If two separate closures (and two seperate _this objects) were created, wouldn't changing bar in foo not be reflected in calls to foo2?\r<br />\n<br />\nThis isn't to say that creating one extra closure per class <em>isn't</em> a performance concern, but I would think that making one extra closure per class might be an alright trade-off in the default scenario in order to have a consistent this context.\r<br />\n<br />\nThe trouble I'm having is not that there isn't a coding pattern that covers my use case, so much as it's confusing that I have to do something special at all in order to make my this context consistent in a class. Anytime a new developer joins the team, or someone familiar with a language like C# migrates to Typescript, they are all going to have their this context changed on them when they don't expect it, run in to bugs and not understand why what they did is a bug/wrong. Also, when I'm creating a function, I now need to either make all my function declarations like your example, or not use my class instance at all because I can't guarantee that I'll have access to it.\r<br />\n<br />\nBottom-line, I assumed that Typescript's classes behaved very similar to classes in other languages, and they don't (unless I change my coding pattern). But, if making the this context consistent has that much of a performance impact, then I suppose whether or not it makes sense is irrelevant.<br />\n",
    "PostedDate": "2013-10-30T10:35:35.047-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1114527",
    "ThreadId": "464116",
    "Html": "The code you've written creates 2 closures per invocation of FooBar (one for foo, one for foo2):<br />\n<pre><code>var bar1 = new FooBar();\nvar bar2 = new FooBar();\nconsole.log(bar1.foo === bar2.foo); // false -- two different objects were allocated</code></pre>\n\nThey can update 'bar' because both closures have the same parent environment object (the one created during each invocation of FooBar).\r<br />\n<br />\nThe broader context is &quot;TypeScript is a superset of JavaScript&quot; and therefore &quot;Understanding TypeScript is a superset of understanding JavaScript&quot;. The default assumption for all JavaScript is that it's unsafe to peel a method off an object and invoke it without context. With TypeScript, hopefully, you would document methods written with the lambda syntax that are safe to use in a context-losing position.\r<br />\n<br />\nI'm hoping someone will write some tooling that detects the most common ways that people lose their context. It turns out to be fairly difficult to plumb the concept through the type system without breaking a lot of code.<br />\n",
    "PostedDate": "2013-10-30T14:00:08.41-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1114970",
    "ThreadId": "464116",
    "Html": "I'm not really sure that JavaScript's &quot;this&quot; context behaviour actually breaks any object oriented principles.\r<br />\n<br />\nIn pure JavaScript the onus is really on the <strong><em>user</em></strong> of your class, not you as the designer, to ensure the &quot;this&quot; context is set correctly.\r<br />\n<br />\nFor example, I would simply ensure those coming from C#/C++/whatever understand the following:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> FooBar {\n    bar = <span style=\"color:#A31515;\">&quot;bar&quot;</span>;\n    foo(){\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>.bar;\n    }\n}\n\n<span style=\"color:Blue;\">var</span> foobar = <span style=\"color:Blue;\">new</span> FooBar();\n<span style=\"color:Blue;\">var</span> badMethod = foobar.foo;\n<span style=\"color:Blue;\">var</span> goodMethod = foobar.foo.bind(foobar);\n\nconsole.log(badMethod()); <span style=\"color:Green;\">// Undefined - wrong &quot;this&quot; context</span>\nconsole.log(goodMethod()); <span style=\"color:Green;\">// &quot;bar&quot; - bound this context</span>\n\n<span style=\"color:Green;\">// or alternatively</span>\nconsole.log(badMethod.call(foobar)); <span style=\"color:Green;\">// &quot;bar&quot; - specified &quot;this&quot; context</span>\r\n</pre></div>In the code above it is really the user of FooBar who decides how they want to act on your class. That doesn't really break encapsulation.\r<br />\n<br />\nNow, unfortunately the people behind TypeScript listened to a vocal minority (mostly JavaScript noobs IMO) and decided to try to fix &quot;this&quot;. So they introduced the per-instance lambda fix:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> FooBar {\n    bar = <span style=\"color:#A31515;\">&quot;bar&quot;</span>;\n    foo = () =&gt; <span style=\"color:Blue;\">this</span>.bar;\n}\n\n<span style=\"color:Blue;\">var</span> foobar = <span style=\"color:Blue;\">new</span> FooBar();\n<span style=\"color:Blue;\">var</span> method = foobar.foo;\nconsole.log(method()); <span style=\"color:Green;\">// &quot;bar&quot;</span>\r\n</pre></div>There are two problems with this:<br />\n<ul>\n<li>The method goes on the instance rather than the prototype and hence it's both non-performant and consumes more memory per instance.</li>\n<li>\nThe onus has now shifted onto the <strong><em>designer</em></strong> of class FooBar to manage the &quot;this&quot; context, in order to avoid surprising users.<br />\n</li>\n</ul>\nPersonally, I have avoided using the per-instance lambda fix introduced by TypeScript and relied instead on the JavaScript model, because it's cleaner, both conceptually and practically.<br />\n",
    "PostedDate": "2013-10-31T03:26:49.37-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1115308",
    "ThreadId": "464116",
    "Html": "The per-instance lambda pattern you mention simply reflects an alignment with ES6's arrow functions (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/arrow_functions\" rel=\"nofollow\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/arrow_functions</a>). Obviously you could do the same thing with a normal function expression and manual 'this' capture on a class property.<br />\n",
    "PostedDate": "2013-10-31T13:15:04.353-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1116641",
    "ThreadId": "464116",
    "Html": "@danquirk, point taken. I suppose all that you're doing is providing a short-cut for the following:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> FooBar {\n    bar = <span style=\"color:#A31515;\">&quot;bar&quot;</span>;\n    foo: () =&gt; <span style=\"color:Blue;\">string</span>;\n    \n    <span style=\"color:Blue;\">constructor</span>(){\n    \n       <span style=\"color:Blue;\">var</span> self = <span style=\"color:Blue;\">this</span>;\n       <span style=\"color:Blue;\">this</span>.foo = <span style=\"color:Blue;\">function</span>(){\n            <span style=\"color:Blue;\">return</span> self.bar;\n        }\n   }\n}\r\n</pre></div>Although in earlier versions of TypeScript this short-cut did not exist.<br />\n<br />\nThe advice to class designers still holds: don't try to provide a guarantee that you will manage the &quot;this&quot; context, because that is simply not feasible for large scale projects.<br />\n",
    "PostedDate": "2013-11-01T10:41:11.93-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]