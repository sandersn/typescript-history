[
  {
    "Id": "1137060",
    "ThreadId": "474364",
    "Html": "in the following example example, there is 2 little things that I do not understand:<br />\n<ul>\n<li>first without the second overload of <code>autoCurry</code> definitions the compiler won't accept function that returns <code>void</code>, while this is not really problematic since there is workaround it does not feel very natural.</li>\n<li>\nMy main concern is about the call of <code>myArrayEach2</code> in this case <code>value</code> has type  <code>any</code> :/.<br />\n</li>\n</ul>\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">interface</span> Curried2&lt;L, M, N&gt; {\n    (l: L, m: M): N;\n    (l: L): (m: M) =&gt; N;\n}\n\n<span style=\"color:Blue;\">declare</span> <span style=\"color:Blue;\">var</span> autoCurry: {\n   \n    &lt;L, M, N&gt;(func: (l: L, m: M) =&gt; N ): Curried2&lt;L, M, N&gt;;\n    \n    &lt;L, M&gt;(func: (l: L, m: M) =&gt; <span style=\"color:Blue;\">void</span> ): Curried2&lt;L, M, <span style=\"color:Blue;\">void</span>&gt;;\n}\n    \n<span style=\"color:Blue;\">var</span> myArray: <span style=\"color:Blue;\">string</span>[] = [<span style=\"color:#A31515;\">&quot;hello&quot;</span>,<span style=\"color:#A31515;\">&quot;world&quot;</span>];\n\n    \n<span style=\"color:Blue;\">var</span> eachString = autoCurry(<span style=\"color:Blue;\">function</span> (array: <span style=\"color:Blue;\">string</span>[], callback: (value: <span style=\"color:Blue;\">string</span>) =&gt; <span style=\"color:Blue;\">void</span>){\n    array.forEach(callback);\n}) \n\n\n<span style=\"color:Blue;\">var</span> myArrayEach = eachString(myArray);  \nmyArrayEach(value =&gt; alert(value.toLowerCase()));\n\n\n<span style=\"color:Blue;\">var</span> each = autoCurry(<span style=\"color:Blue;\">function</span> &lt;T&gt;(array: T[], callback: (value: T) =&gt; <span style=\"color:Blue;\">void</span>){\n    array.forEach(callback);\n}) \n\n    \n<span style=\"color:Blue;\">var</span> myArrayEach2 = each(myArray);\nmyArrayEach2(value =&gt; alert(value.toLowerCase()));\n\r\n</pre></div>Is there any way to define what I want without losing typing ?<br />\n",
    "PostedDate": "2013-12-17T03:34:47.913-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1137314",
    "ThreadId": "474364",
    "Html": "Few issues here:\r<br />\n<br />\nFundamentally what you're trying to do with each + autoCurry isn't going to work this way. The compiler can't unify the generic signature passed to autoCurry and autoCurry's generic parameters and leave you with a new generic signature type (each) that will be instantiated later based on the provided arguments. What you can do instead is something like this:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> makeCurriedEach&lt;T&gt;(x: T[]) {\n    <span style=\"color:Blue;\">var</span> each = autoCurry(<span style=\"color:Blue;\">function</span> (array: T[], callback: (value: T) =&gt; <span style=\"color:Blue;\">void</span>) {\n        array.forEach(callback);\n    })\n\n    <span style=\"color:Blue;\">return</span> each(x);\n}\n\n<span style=\"color:Blue;\">var</span> myArrayEach2 = makeCurriedEach(myArray);\nmyArrayEach2(value =&gt; alert(value.toLowerCase())); <span style=\"color:Green;\">// value correctly typed as string</span>\n\n<span style=\"color:Blue;\">var</span> myArrayEach3 = makeCurriedEach([1,2,3]);\nmyArrayEach3(value =&gt; alert(value.toFixed())); <span style=\"color:Green;\">// value correctly typed as number</span>\r\n</pre></div>Now the function passed to autoCurry is not generic (ie does not introduce its own type parameters) and things can work how you want.\r<br />\n<br />\nIn addition, note a couple things:\r<br />\n1) There is currently a bug in what the compiler does with your original autoCurry call that takes a generic function. We're in the process of fixing it now, but it won't actually make your pattern work anyway.\r<br />\n2) Type inference will choose {} (empty object) for a type parameter for which no inferences can be made. When you see this type in error messages or Quick Info of generics it's usually a sign something is not working as you expected. In your original code you'll note that the type of <code>each</code> has a few such types in it. This is the clue that type inference for <code>autoCurry</code> did not succeed in the way you expect. The reason you get an error when <code>autoCurry</code> doesn't have the second overload is because N is inferred to be {}, but the function you provided returns void, and void cannot be assigned to {}. The second overload allows this call to work, although L and M are still inferred to be {} themselves. This is what also causes the issue you're seeing with <code>value</code>. The type of <code>each</code> is (m: {}) =&gt; void. So <code>myArrayEach2</code>'s parameter type is just {}, which permits you to pass a function as an argument, but since the parameter is not a function type there's no contextual typing to apply to 'value.'\r<br />\n<br />\nDoes that make sense?<br />\n",
    "PostedDate": "2013-12-17T16:40:25.057-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1137405",
    "ThreadId": "474364",
    "Html": "Very clear explanation thanks.\r<br />\nHowever there are some little things that I feel that they could be improved in the language concerning generics :\r<br />\n<br />\nIf I want to describe <code>each</code> without autoCurry I'll do that :<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">declare</span> <span style=\"color:Blue;\">function</span> each&lt;T&gt;(target: T[], callback: (t: T) =&gt; <span style=\"color:Blue;\">void</span>): <span style=\"color:Blue;\">void</span>;\n<span style=\"color:Blue;\">declare</span> <span style=\"color:Blue;\">function</span> each&lt;T&gt;(target: T[]): (callback: (t: T) =&gt; <span style=\"color:Blue;\">void</span>) =&gt; <span style=\"color:Blue;\">void</span>; \r\n</pre></div>But when I look at my <code>Curried2</code> interface :<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">interface</span> Curried2&lt;L, M, N&gt; {\n    (l: L, m: M): N;\n    (l: L): (m: M) =&gt; N;\n}\r\n</pre></div><code>each</code> definition is in fact <code>Curried2&lt;T[], (t: T) =&gt; void, void&gt;</code>\r<br />\n<br />\nIn general there is no way to define a function as a 'specialized' generic function of another generic function signature, even if, in a certain way, we can do that for class :<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Base&lt;A, B&gt; {\n    a: A;\n    b: B;\n}\n\n<span style=\"color:Blue;\">declare</span> Specified&lt;T&gt; <span style=\"color:Blue;\">extends</span> Base&lt;T[], (t: T) =&gt; <span style=\"color:Blue;\">void</span>&gt; {\n    \n}\r\n</pre></div>While it's not a very important feature, I think it could be a nice addition to the generic system.\r<br />\nAnyway thanks again for your explanation.<br />\n",
    "PostedDate": "2013-12-18T01:23:42.01-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]