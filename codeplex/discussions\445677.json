[
  {
    "Id": "1051583",
    "ThreadId": "445677",
    "Html": "Consider the following seeming equivalent statements:<br />\n<ol>\n<li></li>\n</ol>\n<pre><code>class C\n{\n m(){\n  x.foo = function() { this.a = 1; };\n  x.foo()\n }\n}</code></pre>\n\nHere, &quot;this&quot; gets bound to window.<br />\n<ol>\n<li></li>\n</ol>\n<pre><code>class C\n{\n m(){\n  x.foo = () =&gt; { this.a = 1; };\n  x.foo()\n }\n}</code></pre>\n\nHere, &quot;this&quot; gets bound to an instance of c, if m was called on the context of it.\r<br />\n<br />\nIMO, it's odd to have so greatly different semantics for equivalent syntax.\r<br />\n&quot;this&quot; should be really worked around in TS, and always point to the class instance. \r<br />\nEven if this means diverging form ES.\r<br />\n<br />\nTS has the opportunity to be better than ES, and since it'll always compile to ES, there's not need to keep the semantics identical.<br />\n",
    "PostedDate": "2013-06-01T12:01:09.207-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1051725",
    "ThreadId": "445677",
    "Html": "@yaakovd, \r<br />\n<br />\nprobably one of the first things to bear in mind with TypeScript is that <code>() =&gt; {}</code> and <code>function(){}</code> are not equivalent.\r<br />\n<br />\nWe need both because sometimes we want access to the &quot;this&quot; context provided by the designer of an API.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\n <span style=\"color:Blue;\">var</span> element = document.body;\nelement.innerHTML = <span style=\"color:#A31515;\">&quot;&lt;div&gt;foo&lt;/div&gt;&quot;</span>\n\nelement.onclick = <span style=\"color:Blue;\">function</span>(){\n    console.log(<span style=\"color:Blue;\">this</span>.firstChild.innerHTML); <span style=\"color:Green;\">// foo</span>\n}\n\r\n</pre></div>The request to fix &quot;this&quot; is not an infrequent topic on this forum - and IMO rather tedious, because it is often raised by those coming directly to TypeScript from another language, having bypassed JavaScript altogether.\r<br />\n<br />\n<a href=\"https://typescript.codeplex.com/discussions/445319\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/445319</a>\r<br />\n<a href=\"https://typescript.codeplex.com/discussions/445528\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/445528</a>\r<br />\n<a href=\"https://typescript.codeplex.com/discussions/429350\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/429350</a>\r<br />\n<a href=\"https://typescript.codeplex.com/discussions/437633\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/437633</a>\r<br />\n<a href=\"https://typescript.codeplex.com/discussions/437989\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/437989</a>\r<br />\n<a href=\"https://typescript.codeplex.com/discussions/433717\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/433717</a>\r<br />\n<a href=\"https://typescript.codeplex.com/discussions/403675\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/403675</a>\r<br />\n<a href=\"https://typescript.codeplex.com/discussions/430229\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/430229</a>\r<br />\n<a href=\"https://typescript.codeplex.com/discussions/397774\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/397774</a>\r<br />\n<br />\n<a href=\"https://typescript.codeplex.com/workitem/248\" rel=\"nofollow\">https://typescript.codeplex.com/workitem/248</a>\r<br />\n<a href=\"https://typescript.codeplex.com/workitem/468\" rel=\"nofollow\">https://typescript.codeplex.com/workitem/468</a>\r<br />\n<a href=\"https://typescript.codeplex.com/workitem/477\" rel=\"nofollow\">https://typescript.codeplex.com/workitem/477</a>\r<br />\n<a href=\"https://typescript.codeplex.com/workitem/851\" rel=\"nofollow\">https://typescript.codeplex.com/workitem/851</a><br />\n",
    "PostedDate": "2013-06-02T03:45:20.533-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1051730",
    "ThreadId": "445677",
    "Html": "<blockquote>\nWe need both because sometimes we want access to the &quot;this&quot; context provided by the designer of an API.<br />\n</blockquote>\n<ol>\n<li>\nI'd argue that &quot;this&quot; in the above example should be replaced with &quot;element&quot;.<br />\n</li>\n</ol>\n<blockquote>\nThe request ... is often raised by those coming directly to TypeScript from another language, having bypassed JavaScript altogether<br />\n</blockquote>\nYou're assuming wrong. <br />\nI converted JS code to TS, wrapping prototype-based JS &quot;classes&quot; as TS classes, and had to replace all function expressions with lambda expressions to maintain proper binding. So ironically TS's attempt to stay compatible with ES, actually broke my JS code.<br />\nI.e. The following code yielded the proper &quot;this&quot; semantics under JS, but NOT under TS:<br />\n<pre><code>var Class = {};\nClass.prototype.foo = function()\n{\n   setTimeout(100, function(){this.x = 5;}); //&quot;this&quot; is a Class instance\n}</code></pre>\n\nDoing a straightforward TS porting broke my code:<br />\n<pre><code>class Class\n{\n  foo()\n  {\n    setTimeout(100, function(){this.x = 5;});//&quot;this&quot;  is window!\n  }\n}</code></pre>\n\nYou should either not break things, or break them properly. Since TS porting breaks JS, it should do so in a meaningful &amp; predictable manner.<br />\n<br />\nThe &quot;non-infrequency&quot; of this topic might suggest that people want TS to be something other, and better, than ES.<br />\n",
    "PostedDate": "2013-06-02T04:06:05.543-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1051742",
    "ThreadId": "445677",
    "Html": "@yaakovd, \r<br />\n<br />\nNo offence to you personally: I was simply articulating something I had observed on the forum.\r<br />\n<br />\nYes, in my example one could replace &quot;this&quot; with &quot;element&quot;, but the &quot;this&quot; context can be anything as decided by the API designer. I personally don't like &quot;this&quot; to be changed at all - but that is how many popular JavaScript libraries have been developed. I believe TypeScript is simply trying to cater for both situations.\r<br />\n<br />\nThere appears to be something wrong with your code: In the first snippet <code>Class</code> is an object literal and won't have a prototype. Also settimeout should take the duration as the second parameter. \r<br />\n<br />\nIn both JS and TS the &quot;this&quot; context will be window.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> Class = <span style=\"color:Blue;\">function</span> (){};\n\nClass.prototype.foo = <span style=\"color:Blue;\">function</span>()\n{\n   setTimeout(<span style=\"color:Blue;\">function</span>(){<span style=\"color:Blue;\">this</span>.x = 5;}, 100); <span style=\"color:Green;\">//&quot;this&quot; is a window instance</span>\n}\r\n</pre></div>",
    "PostedDate": "2013-06-02T05:06:40.173-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1051747",
    "ThreadId": "445677",
    "Html": "You're right about the mistakes in my code examples; I wrote them ad-hoc without copying from any production code.\r<br />\n<br />\nYou're correct also about the &quot;this&quot; binding in the examples -- it will bind to window indeed.\r<br />\n<br />\nI rechecked our code to understand what went wrong during the porting. Here's what I found:\r<br />\n<br />\nWith JS prototypical classing, the code would look like this:<br />\n<pre><code>var Class = function (){};\nClass.foo = function()\n{\n  ...\n}\n\nClass.bar = function()\n{\n  setTimeout(Class.foo, 500);\n}\n</code></pre>\n\nfoo here is called on the <em>prototype</em>, instead of the <em>instance</em> level. I believe this isn't what the original author who wrote it intended.\r<br />\nThere's only a single instance of Class in our app, so everything worked on the &quot;static&quot; level, even when invoked at the instance level.\r<br />\nie. it was used like this:<br />\n<pre><code>var c = new Class();\nc.bar(); //bar called at the instance level, but the inner foo resorts to the prototype level. </code></pre>\n\nWhen converting to TS, I replaced<br />\n<pre><code>setTimeout(Class.foo, 500);</code></pre>\n\nwith <br />\n<pre><code>setTimeout(this.foo, 500);</code></pre>\n\nwhich broke it.\r<br />\n<br />\nSo, it's not TS's fault after all, but the way it was originally written, and the fact that I changed the calling semantics from static to instance.<br />\n",
    "PostedDate": "2013-06-02T05:39:47.307-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]