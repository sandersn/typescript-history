[
  {
    "Id": "951478",
    "ThreadId": "405601",
    "Html": "\r\n<p>Hi everyone...&nbsp;My team just launched a major&nbsp;re-design to our website\r\n<a href=\"http://so.cl/\">http://so.cl</a> today and the new site is 100% written in TypeScript on the browser side.&nbsp; We have a little over 30,000 lines of TypeScript in our project so we think it's a great example of using TypeScript to develop web applications\r\n at scale.&nbsp; Please give the site a try and if you have any questions about what went into developing a site of this scale in TypeScript please ask away...</p>\r\n<p>Oh and to the TypeScript team... Thanks again for <a href=\"http://blogs.msdn.com/b/typescript/archive/2012/12/04/congratulations-to-fuse-labs-on-the-new-socl.aspx?CommentPosted=true#commentmessage\">\r\nblog post</a>... If it weren't for you guys we'd still be trying to get this thing out the door :)</p>\r\n<p>-steve</p>\r\n",
    "PostedDate": "2012-12-04T20:57:01.653-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "953266",
    "ThreadId": "405601",
    "Html": "\r\n<p>First of all, a great looking site and a nice concept.</p>\r\n<p>One questions I have is that it looks like you went for the internal module approach (device.pkg.js has at least the signature of internal modules usage in there). What was the reasoning behind this and not going for external modules using for example AMD?</p>\r\n<p>I'm often&nbsp;struggling in deciding what would be the best approach for some of my pet-projects and my gut feeling is telling me that internal modules are easier to start with, but could lead to less&nbsp;maintainable&nbsp;code since the change on name-clashes is bigger.\r\n Especially if a project uses only 1 module name. Overall internal modules feel more monolithic to me.</p>\r\n<p>Also incremental compilation seems much harder to do with internal modules. Every time you have to compile all 30.000 lines of code (at least when you use the tsc command line tool).&nbsp;</p>\r\n<p>Your insight would be much appreciated!</p>\r\n<p>// Peter</p>\r\n",
    "PostedDate": "2012-12-08T02:14:34.403-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "953429",
    "ThreadId": "405601",
    "Html": "\r\n<p>Thanks... And way to jump straight to the tough questions :)</p>\r\n<p>There's a couple of things going on with the way we're using TypeScript. &nbsp;We, obviously, started using TypeScript fairly early on (like 9 months ago so ages ago) and a lot of pieces weren't in place yet. &nbsp;One of which was the ability to generate\r\n a single .js file from multiple .ts files. &nbsp;That lead to us building our own tooling for doing just that. &nbsp;We have something called the &quot;packager&quot; that converts these pkg files we define (essentially JSON based make files) into .pkg.js &amp; .pkg.min.js\r\n files. &nbsp;The packager drives the compilation of all our hundreds of TypeScript files and does other things like converting our UI templates (based on jQuery Templates) into TypeScript files and compiling our LESS files into CSS. &nbsp;Once the packager\r\n has compiled everything it then does a combine and optional minification step with the ultimate goal being that we want a single file as output the contains everything needed to run our site. &nbsp;As you point out incremental compiles are essential for a\r\n project of this size and our packager has it's own simplistic form of of incremental compile logic which is largely why we're still using it versus moving to TypeScripts single output file model.</p>\r\n<p>As you observed we do in fact currently use internal modules versus external modules. &nbsp;The reason for this is pretty simple. &nbsp;If you've seen any of my other post you might notice a bit of a theme. My initial approach to TypeScript was to try and\r\n model everything the way I would in C#. &nbsp;I love JavaScript and I love C#. &nbsp;TypeScript to me is the perfect marriage of both those worlds so I wanted to see how much of the C# world I could bring into JavaScript via TypeScript (it turns out a lot.)\r\n &nbsp;The decision to use internal modules was simply my attempt to model the namespacing found within C# projects in TypeScript. &nbsp;It also let us enforce some team wide rules like saying that the namespace of objects MUST reflect where the code for those\r\n objects are located in the source tree. &nbsp;For instance, the Socl.Data.Post class can be found in the &quot;Socl/Data/Post.ts&quot; file which is nice.</p>\r\n<p>You pointed out that incremental compilation is hard with internal modules and you're correct. &nbsp;But we have this package concept which allows us to define exactly which files (and therefore which classes) reside in a package. &nbsp;The incremental compile\r\n logic of our package works on the package boundary so the only time we need to recompile a set of files is when we detect that one of the files within a &quot;package&quot; has changed. &nbsp;Our packager supports dependent packages and anytime a file changes it re-compiles\r\n all of the files within that package as well as any of the packages that were dependent upon that package.</p>\r\n<p>with all of that said... I am in fact currently evaluating the move from internal modules to external modules for some of the reasons you point out. &nbsp;The broader reason for potentially making this move though is that today we have a 100% typescript\r\n UI which talks to a 100% C# backend. &nbsp;I'd like to see us move some of the pieces of our backend to node.js so that we can start realizing better code reuse between our UI and server pieces. &nbsp;In the node.js world it's all about CommonJS modules so\r\n to sort of unify the experience across these two worlds I'm looking into adopting the use of external modules across our entire system.</p>\r\n<p>-steve&nbsp;</p>\r\n<p>Edit: I should probably note that what I'm calling Backend above our server guys call the frontend. &nbsp;The backend to them is our database &amp; indexes that the frontend servers talk to. &nbsp;Given that our UI is effectively a 100% browser based app\r\n I consider anything in the cloud as backend. &nbsp;So it's some of the bits in the middle I'd like to see moved to node.js :)</p>\r\n",
    "PostedDate": "2012-12-08T19:22:54.897-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "953550",
    "ThreadId": "405601",
    "Html": "\r\n<p>Thanks for the extensive reply, very&nbsp;helpful!!! Good to know what was the reasoning behind some of the decisions and the&nbsp;challenges&nbsp;your team faced. One of the things I didn't really think about is that for people with a C# background, internal modules feel\r\n very natural.&nbsp;</p>\r\n<p>For me with a different background, external modules seem a more natural fit. However I feel that a main downside of using external modules is that a single file is a module and as a result you need many imports (even more so if you are going to provide\r\n typing info). And almost everywhere in your code your are going to see a module prefix.&nbsp;Also if using a class per external module approach, it provides&nbsp;awkward&nbsp;naming issues. What to call the module that contains the single class?</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">import</span> mWidget = module(<span style=\"color:#a31515\">&quot;./core/widget&quot;</span>); \r\n<span style=\"color:blue\">var</span> widget = <span style=\"color:blue\">new</span> mWidget.Widget(); \r\n...\r\nadd(widget: mWidget.Widget) {...}\r\n</pre>\r\n</div>\r\n<p></p>\r\n<p>I tried a number of prefixes, like the &quot;m&quot; prefix in the above example, but overall it makes the code less&nbsp;readable.&nbsp;One way around this is to put multiple classes into a single external module file (lets cal it core). So you would get:</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">import</span> core = module(<span style=\"color:#a31515\">&quot;./core&quot;</span>); \r\n<span style=\"color:blue\">var</span> widget = <span style=\"color:blue\">new</span> core.Widget(); \r\n...        \r\nadd(widget: core.Widget) {...}\r\n</pre>\r\n</div>\r\n<p></p>\r\n<p>This looks and feels better and also reduces the number of required imports, since the &quot;core&quot; module contains a number of classes. &nbsp;However I feel that this approach provides&nbsp;&nbsp;the wrong granularity (from a version control and&nbsp;maintainability&nbsp;perspective).\r\n But again this just could be my Java background.</p>\r\n<p>I also played around a bit with mixing internal and external modules, but that felt always &quot;artificial&quot;, although perhaps I should give it another go. I guess some more experimenting is required before a optimal solution is found.</p>\r\n<p>// Peter<br>\r\n<br>\r\n</p>\r\n",
    "PostedDate": "2012-12-09T08:24:11.207-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "953994",
    "ThreadId": "405601",
    "Html": "\r\n<p>It is useful to keep in mind that TypeScript support for ES6 modules is incomplete, and even ES6 modules haven't quite settled down yet (the latest committee meeting introduced a re-design the details of which I haven't seen yet). Among the details still\r\n under discussion are internal vs external modules and modules that export a single object. Also, the existing spec provides for some abbreviations that TS doesn't support yet, so using TS external modules is more awkward than it will be. And finally, TS has\r\n types, which aren't covered in ES6 modules (so one can abbreviate module paths and module value imports, but not module type imports).</p>\r\n<p>For those who have practical experience with TS modules, it might help to ask for module support priority to be increased (I did so in\r\n<a href=\"http://typescript.codeplex.com/wikipage?title=Roadmap\">Roadmap</a> comments), and to keep an eye on the ES6 modules spec, making sure that it covers your use cases. It is difficult to foresee uses of a new spec, even if based on existing systems.</p>\r\n<p>Btw, in my experience (with reusing typescript compiler and services code), TS references-to-internal/import-of-external modules do not mix well - either choice seems to be infectious (apart from hacks like presenting an external module front for internal\r\n module code).</p>\r\n",
    "PostedDate": "2012-12-10T07:28:28.6-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "956151",
    "ThreadId": "405601",
    "Html": "\r\n<p>Congrats on a huge launch!</p>\r\n<p>Some things I see from an SEO perspective:</p>\r\n<ul>\r\n<li>The title tag for all you pages is SOCL, this should be the name of the collage\r\n</li><li>Consider changing the urls to be more SEO friendly (title of the post as part the url rather than that random string). &nbsp;This used to help with SERP placement but at a minimum helps clickthrough rates on search results\r\n</li><li>How are you handling Webcrawler crawling of this content?&nbsp; </li></ul>\r\n<p>Best of luck, great start!</p>\r\n<p>Jon</p>\r\n",
    "PostedDate": "2012-12-14T07:49:38.61-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "956290",
    "ThreadId": "405601",
    "Html": "\r\n<p>Thanks Jon... Yes, the title thing is something we noticed right as we were getting ready to launch and it didn't make the cut list of bugs to fix. &nbsp;We're not currently crawlable as you've noticed but we do have a task to add support for &quot;ugly&quot; urls to address\r\n the crawling issue. &nbsp;We haven't decided if we want to do web snapshots or just implement an unstyled HTML version of the site to deal with crawling but again it's another task on a long list.</p>\r\n<p>&nbsp;</p>\r\n<p>-steve</p>\r\n",
    "PostedDate": "2012-12-14T13:39:09.96-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]