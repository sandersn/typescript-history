[
  {
    "Id": "1176984",
    "ThreadId": "507413",
    "Html": "Hey!\r<br />\n<br />\nWe're playing around with typescript and we really love it! We want to rewrite an existing AngularJS app in typescript.\r<br />\n<br />\nRight now we're searching a good workflow for our project. We want one file per class and the final js should be a single js file. \r<br />\n<br />\nWe wounder how to manage all the dependencies between the single files. There are a lot of people which suggest to have one reference.ts file which has all references. We adopted this particular strategy: <a href=\"http://www.youtube.com/watch?v=0-6vT7xgE4Y\" rel=\"nofollow\">http://www.youtube.com/watch?v=0-6vT7xgE4Y</a>\r<br />\n<br />\nThis works fine but our laptops aren't very new and quite slow. So we have compilation times bigger than 15 seconds. This is quite anoying especially if we experiment with UI/UX things. To try some little chances we always have to way 15 seconds. This comes because with the reference.ts file, always all files are compiled again. Is there a workflow which only compiles the changed file and not all referenced files.\r<br />\n<br />\nWe don't use Visual Studio. We use Nodejs, Webstorm7 and Grunt.\r<br />\n<br />\nThanks for every advice and hint\r<br />\nTschoartschi<br />\n",
    "PostedDate": "2014-01-18T05:15:18.333-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1178026",
    "ThreadId": "507413",
    "Html": "Roughly how much code are you compiling that takes that long?<br />\n<br />\nI'm not really familiar with Webstorm, but your IDE might utilize incremental compilation for code completion and syntax highlighting as you edit, but then invoke a full build when you run the app.<br />\n<br />\nIn general, the old workflow of &quot;make a tiny change and then reload the browser to see it&quot; has gone out the window. It's also an entirely unproductive workflow. Batching changes into changesets before running and manually testing/examining is a mindset that is lacking in front end development. Can you imagine if backend applications were made via a single change at a time?<br />\n<br />\nMy tip is to heavily leverage a good web debugger like Chrome's WebKit inspector. It's an IDE in and of itself. Prototype CSS and markup changes in browser using the inspector before altering any code. You can even modify and <em>save</em> code in the inspector. In fact, you can modify code while it's running, and when you save Chrome will step back in time to before the modified portion so you can run the modified bits(!). Since TS and JS are idiomatic, copying prototypical changes back into source is easy.<br />\n<br />\nSeparation of concerns is important too. You're using Angular, so you're probably not writing much DOM handling code. Excellent! Leaning on data-binding and templating cuts down on code costs across the board. Avoid writing against the DOM like the plague.<br />\n<br />\nBuild times within a specific TS version are going to increase linearly as your codebase grows. That's the price for static analysis and type safety, and it's one that's worth paying, IMO. We now pay in time up front for avoiding certain classes of bugs, rather than finding them asynchronously. That's a good thing.<br />\n",
    "PostedDate": "2014-01-18T11:38:15.74-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1178103",
    "ThreadId": "507413",
    "Html": "Hello,\r<br />\n<br />\nMy current workflow:<br />\n<ul>\n<li>only external modules - that makes dependencies simple as you don't need to use reference files at all and you have one class (or group of functions) per file. Dependencies are automatically resolved by tsc (at compile time) and AMD loader (at run time). It's just like imports in Java - you import something it it Just Works without worrying about ordering etc. For that to work you'll need AMD loader (e.g. require.js) but I used it anyway in my JavaScript projects. Honestly I can't imagine working on a big project (TS or JS) without require.js.</li>\n<li>enable source maps generation and you'll be debugging real source code in browser.</li>\n<li>code is minified using grunt (all depedencies to one file + minify it). You get one JS file (also minified HTML and CSS as part of grunt task). As an added bonus require.js minifier also outputs source maps so you can debug minified JS too (although currently you'll see JS instead of TS).</li>\n<li>I wrap all &quot;native&quot; JS libraries in define() calls (for AMD loader) and add definition files (.d.ts) so they behave like regular TypeScript dependencies.</li>\n<li>when I checked IDE support 2 months ago Eclipse had the best plugin (I've checked VS, Eclipse, IntelliJ and Sublime Text): <a href=\"https://github.com/palantir/eclipse-typescript\" rel=\"nofollow\">https://github.com/palantir/eclipse-typescript</a> it recompiles files as you save so you don't need grunt watch for that. It almost feels like early Java development :)</li>\n<li>\ntslint in Eclipse ( <a href=\"https://github.com/palantir/eclipse-tslint\" rel=\"nofollow\">https://github.com/palantir/eclipse-tslint</a> ) and in grunt file, failing the build when it detects warnings.<br />\n</li>\n</ul>\nI've built a sample project that shows most of those (external modules, require.js and minification): <a href=\"https://github.com/wiktor-k/ts-amd\" rel=\"nofollow\">https://github.com/wiktor-k/ts-amd</a> It's simple but you can get the idea of how it works.<br />\n",
    "PostedDate": "2014-01-18T12:07:37.417-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1180224",
    "ThreadId": "507413",
    "Html": "Thank you for your advices! It is true that we could use the chrome web dev tools more. But I don't agree totally with the idea to bundle many changes and then test/debug them. Jeah, but maybe we change our mind if we use the debugger more effectively. \r<br />\nI don't know why compilation takes that long, but I think it is a grunt issue. For more details see: <a href=\"https://github.com/basarat/grunt-ts/issues/7\" rel=\"nofollow\">https://github.com/basarat/grunt-ts/issues/7</a> The whole project has about 70 files and 4500 lines of code. Running the compiler on the command line takes about 5 seconds. (which is significantly faster than the grunt plugins. We also tried others than grunt-ts).\r<br />\n<br />\nI'll definetly try the workflow which wiktork suggested and have a look into his repo. If I have more questions I'll come up here again ;)\r<br />\n<br />\nPS: my laptop is more than 4 years old, so I understand, that compilation can not be blasting fast. (CPU: Intel Core i5 <a href=\"mailto:520M@2.4GHz\" rel=\"nofollow\">520M@2.4GHz</a> with 8 GB RAM)<br />\n",
    "PostedDate": "2014-01-19T03:34:10.963-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1180283",
    "ThreadId": "507413",
    "Html": "I am honestly not being facetious: why are you using hopelessly inadequate hardware to do your jobs?<br>\r\n<br>\r\n-- <br>\r\n<div dir=\"ltr\"><b><font face=\"arial black, sans-serif\" color=\"#666666\">Mark Rendle</font></b>\r\n<div><font><i>Founder & CEO</i></font></div>\r\n<div><font><i>Oort Corporation</i></font></div>\r\n<div><font><i>Makers of</i> <a href=\"https://zud.io/\" target=\"_blank\"><b><font color=\"#0000ff\">Zudio</font></b></a></font></div>\r\n</div>\r\n<br>\r\n",
    "PostedDate": "2014-01-19T04:00:36.77-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1180431",
    "ThreadId": "507413",
    "Html": "@tschoarschi I've got a project of over 50 files and 3700 lines of code (excluding js or .d.ts files) and the compilation in grunt also takes about 4 or 5 seconds but with the Eclipse plugin CTRL+S compiles so fast it almost feels like JavaScript development - CTRL+S, switch to browser, F5, viola! I won't say it's a miraculous silver bullet but it's worth to try out.\r<br />\n<br />\nI've had issues that the plugin produced empty file but then you can grunt typescript entire project and it works.\r<br />\n<br />\nThe repo I provided has minimal setup so you can check whether it suits you, there are several things to optimize there (in grunt build step).<br />\n",
    "PostedDate": "2014-01-19T05:01:42.423-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1180994",
    "ThreadId": "507413",
    "Html": "<strong>wiktork wrote:</strong><br />\n<blockquote>\nHonestly I can't imagine working on a big project (TS or JS) without require.js.<br />\n</blockquote>\n_\r<br />\nWe have a Visual Studio-based project structure with the following statistics<br />\n<ul>\n<li>25 separate projects</li>\n<li>450 TypeScript files (includes about a hundred .d.ts files)</li>\n<li>325 exported classes + 50 private classes</li>\n<li>\nSome 40K lines of code<br />\n</li>\n</ul>\nWe do not use external modules (i.e. we do not use Require JS), instead we use the internal &lt;reference&gt; mechanism.\r<br />\n<br />\nSome features of the structure and workflow<br />\n<ul>\n<li>One class per file.</li>\n<li>All classes contained within a hierarchical namespace structure originating from a single property on Window (e.g </li>\n</ul>\n<div style=\"color:Black;background-color:White;\"><pre>\r\nwindow.rootNamespace : { \n    namespaceOne: { ClassOne: ... }, \n    namespaceTwo: { ClassTwo: ...  } \n}\r\n</pre></div><ul>\n<li>No source maps (because the compiled JavaScript is eminently readable).</li>\n<li>In debug mode every single JavaScript file is served up individually to the browser.</li>\n<li>In release mode all scripts are bundled and minified into a single JavaScript file.</li>\n<li>The Visual Studio solution can scale by adding new projects and configuring them with the bundling mechanism</li>\n<li>There is no extra maintenance when a new TypeScript file is added to a Visual Studio project.</li>\n<li>The project is organised into a set of library classes and client classes.</li>\n<li>Library classes may depend on other library classes but may not depend on client classes (obviously)</li>\n<li>Client classes may depend on each other and the library classes.</li>\n<li>\nEach file compiles on save, a project can be compiled individually or the entire solution can be compiled.<br />\n</li>\n</ul>\nWe have had no complaints, with regard to scalability, compilation, debugging, maintenance - in general the coding, debugging, deployment workflow functions well and speedily at that.\r<br />\n<br />\nI would be interested to learn if anyone is able to suggest an improvement to this set-up with AMD or anything else.<br />\n",
    "PostedDate": "2014-01-19T08:28:23.297-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1181042",
    "ThreadId": "507413",
    "Html": "Hi nabog,\r<br />\n<br />\nCan you elaborate on this point &quot;In debug mode every single JavaScript file is served up individually to the browser.&quot;? How do you serve those files?\r<br />\nDo you by &quot;debug mode&quot; also mean development?\r<br />\nHow do your &lt;script&gt; tags look in HTML?\r<br />\n<br />\nI'd like to compare your workflow with mine.<br />\n<blockquote>\nHonestly I can't imagine working on a big project (TS or JS) without require.js.<br />\n</blockquote>\nYeah, that can also be explained by limited imagination :)<br />\n",
    "PostedDate": "2014-01-19T08:44:45.987-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1181119",
    "ThreadId": "507413",
    "Html": "Hi, wiktork,\r<br />\n<br />\nThe files are bundled and served up by the <a href=\"http://www.asp.net/mvc/tutorials/mvc-4/bundling-and-minification\" rel=\"nofollow\">ASP.Net Bundling and Mnification mechanism</a>.\r<br />\n<br />\nThe file containing the script tag is a &quot;.cshtml&quot; file that is processed by the ASP.Net pipeline and converted into a corresponding HTML file. The directive for generating the scripts is a one liner:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">&lt;</span><span style=\"color:#A31515;\">script</span> <span style=\"color:Red;\">type</span><span style=\"color:Blue;\">=</span><span style=\"color:Blue;\">&quot;text/javascript&quot;</span> <span style=\"color:Red;\">src</span><span style=\"color:Blue;\">=</span><span style=\"color:Blue;\">&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.js&quot;</span><span style=\"color:Blue;\">&gt;</span><span style=\"color:Blue;\">&lt;/</span><span style=\"color:#A31515;\">script</span><span style=\"color:Blue;\">&gt;</span>\n   \n<span style=\"color:Green;\">&lt;!-- Custom scripts --&gt;</span>\n@Scripts.Render(&quot;~/FooScripts&quot;)\r\n</pre></div>In this snippet we have a regular script tag for JQuery say and a directive to the ASP.Net bundler to load the bundle &quot;FooScripts&quot;. The bundles are configured in C# code, which you can read about in the link above.\r<br />\n<br />\nThe switch between generating script tags for each individual file versus a single script tag is controlled in the web config:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">&lt;</span><span style=\"color:#A31515;\">system.web</span><span style=\"color:Blue;\">&gt;</span>\n    <span style=\"color:Blue;\">&lt;</span><span style=\"color:#A31515;\">compilation</span> <span style=\"color:Red;\">debug</span><span style=\"color:Blue;\">=</span><span style=\"color:Black;\">&quot;</span><span style=\"color:Blue;\">true</span><span style=\"color:Black;\">&quot;</span> <span style=\"color:Blue;\">/&gt;</span>\n<span style=\"color:Blue;\">&lt;/</span><span style=\"color:#A31515;\">system.web</span><span style=\"color:Blue;\">&gt;</span>\r\n</pre></div>In debug (yes, development) mode the flag is &quot;true&quot;, while in a release build this is automatically converted to &quot;true&quot;.\r<br />\n<br />\nThis may sound complicated, but it's one of those configure-once-and-forget procedures.\r<br />\n<br />\nI believe the actual bundler lives in the .Net System.Web.Optimisation.dll and may have an open source equivalent.<br />\n",
    "PostedDate": "2014-01-19T09:10:24.003-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1181298",
    "ThreadId": "507413",
    "Html": "Okay, now I understand that.\r<br />\n<br />\nIt seems your workflow is tied to ASP.NET so probably it will suit you better than AMD + require.js.\r<br />\n<br />\nI'll take your list of features and compare with mine:<br />\n<ul>\n<li><em>One class per file.</em> - I've got the same although some files are just plain modules with directly exported functions</li>\n<li>\n<em>All classes contained within a hierarchical namespace structure originating from a single property on Window (e.g\r<br />\n window.rootNamespace : { <br />\n namespaceOne: { ClassOne: ... }, <br />\n namespaceTwo: { ClassTwo: ...  } <br />\n}</em> - During development I've got only require.js functions exposed (&quot;require&quot; and &quot;define&quot;) and in production build there are no symbols exported in window (see below for explanation).\n</li>\n<li><em>No source maps (because the compiled JavaScript is eminently readable).</em> - I've got source maps but yes, the JS code is readable as it is + I've got source maps for the minified JS file (for debugging in production, sometimes they are very handy).</li>\n<li><em>In debug mode every single JavaScript file is served up individually to the browser.</em> - in development I have only one &lt;script&gt; tag to load require.js and point to the main module. All other dependencies are automatically transitively inferred and loaded in correct order.</li>\n<li><em>In release mode all scripts are bundled and minified into a single JavaScript file.</em> - the same</li>\n<li><em>There is no extra maintenance when a new TypeScript file is added to a Visual Studio project.</em> - the same</li>\n<li><em>The project is organised into a set of library classes and client classes.</em> - my project is small enough so that the library client classes are just subdirectories</li>\n<li>\n<em>Each file compiles on save, a project can be compiled individually or the entire solution can be compiled.</em> - the same. I've got IDE that compiles on save and Grunt task that lints everything then compiles everything, concatenates, minifies JS, CSS, HTML and gzip compresses for faster serving static resources.<br />\n</li>\n</ul>\nThe main difference to your workflow is that with require.js you don't need server side processing at all during development and you can just have a &quot;dumb&quot; HTTP server that just serves plain files. (plus IDE compiling ts-&gt;js).\r<br />\n<br />\ntsc --module amd emits special define calls that are used by require.js to asynchronously load dependencies before any component that depends on them runs. The define calls also make sure that no symbols leak to global object so you don't need to organize namespaces using JS objects (but rather file and folder structure). require.js is also smart enough to load only those dependencies that you really use in your application. The minifier is just a loader that puts all used dependencies in one file and minifies them.\r<br />\n<br />\nThe dependency information can be used by different tools to produce for example dependency graphs: <a href=\"https://github.com/pahen/madge#examples\" rel=\"nofollow\">https://github.com/pahen/madge#examples</a>\r<br />\n<br />\nSee my other thread for how does the tsc output looks like when using module amd: <a href=\"https://typescript.codeplex.com/discussions/510900\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/510900</a>\r<br />\nAnd the &quot;Why AMD&quot; is also interesting: <a href=\"http://requirejs.org/docs/whyamd.html#amd\" rel=\"nofollow\">http://requirejs.org/docs/whyamd.html#amd</a><br />\n<blockquote>\nThis may sound complicated, but it's one of those configure-once-and-forget procedures. <br />\n</blockquote>\nHaha, I could say the same about require.js + external modules :)\r<br />\n<br />\nI have an extremely sample application that demonstrates this approach: <a href=\"https://github.com/wiktor-k/ts-amd\" rel=\"nofollow\">https://github.com/wiktor-k/ts-amd</a> You'll need npm and grunt ( <a href=\"http://gruntjs.com/\" rel=\"nofollow\">http://gruntjs.com/</a> ) to do the production build but for development you just need to compile the ts files (tsc.cmd or VS). Then it just works (assuming you're serving the files through http not locally).\r<br />\n<br />\nAnd I wouldn't necessarily consider it an &quot;improvement&quot; over yours. They're just different mostly because we have different needs and constraints. But it certainly never hurts knowing other ways of doing things :)<br />\n",
    "PostedDate": "2014-01-19T10:17:51.287-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1181765",
    "ThreadId": "507413",
    "Html": "Regarding the server-side processing during development, in practise the ASP.Net code is pretty efficient and processes and serves up the 300+ files in less than a second.  So the workflow of &quot;Compile-on-save + F5 on the browser&quot; works instantly. But I agree it would be nice to have only a dependency on a &quot;dumb&quot; HTTP server.\r<br />\n<br />\n(BTW: ASP.Net is another <a href=\"http://www.asp.net/open-source\" rel=\"nofollow\">open source</a> project by Microsoft.)\r<br />\n<br />\nThe main differences (assuming a one class per file approach) as I see them are:<br />\n<ul>\n<li>With the Require JS approach outlined above, all code needs to be organised under one root directory, because as you say &quot;I have only one &lt;script&gt; tag to load require.js and point to the main module&quot;. Not sure how it's possible to compile a project individually with this set-up - unless there is some scripting being done.  With Visual Studio and bundling one is free to have projects anywhere on the network, since they can be referenced by the solution. The ASP.Net bundler also works on CSS files and a linter can be run as a post build step if necessary.</li>\n<li>With AMD the browser needs to make an additional HTTP request for every new class that needs to be loaded. With the bundled approach there is only ever one request per script bundle. I believe there is a <a href=\"http://requirejs.org/docs/optimization.html\" rel=\"nofollow\">Require JS optimiser</a> that bundles together classes, but that seems to suggest extra maintenance and we lose the &quot;load only when required&quot; advantage.</li>\n<li>\nWhile Require JS does load the dependencies for each class it is necessary to explicitly specify that dependency via <code>import foo = require(&quot;./mydependency&quot;);</code>. This generates an additional closure: <code>define([&quot;require&quot;, &quot;exports&quot;, &quot;./mydependency&quot;</code> per class. This creates additional maintenance and also extract code that needs to be transmitted over the wire. With the &lt;reference&gt; approach we instead inform the class &quot;here is an interface, just assume that a type that implements this interface will be available at runtime&quot;. <br />\n</li>\n</ul>\nI believe these factors will have a significant impact when one is considering 300+ classes.\r<br />\n<br />\nI do agree that each approach suits a different need and set of constraints - so, yes, it's useful to know exactly which bits one is losing or gaining by picking a particular approach.<br />\n",
    "PostedDate": "2014-01-19T13:08:27.133-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1181977",
    "ThreadId": "507413",
    "Html": "I see, so the <a href=\"mailto:@Scripts.Render(&quot;~/FooScripts&quot;)\" rel=\"nofollow\">@Scripts.Render(\"~/FooScripts\")</a> concatenates all scripts and inserts one &lt;script&gt; tag? How does it know the correct order of concatenation? Builder configuration? references files?<br />\n<blockquote>\nWith the Require JS approach outlined above, all code needs to be organised under one root directory<br />\n</blockquote>\nWhat do you mean by &quot;one root directory&quot;? Do you mean the fact that I'm putting all my scripts under &quot;scripts&quot; directory? You can access modules up in the folder hierarchy using relative imports like &quot;../../lib/Promise&quot;. And of course all ts files are not in one big flat directory :)<br />\n<blockquote>\nWith AMD the browser needs to make an additional HTTP request for every new class that needs to be loaded<br />\n</blockquote>\nYes that's true. At development one script per class is loaded. But loading from localhost is not THAT slow. One big file sounds faster though :)<br />\n<blockquote>\nWith the bundled approach there is only ever one request per script bundle.<br />\n</blockquote>\nAs you're getting that during development time I think it's nice. But how does debugging and code browsing feel in one huge file?<br />\n<blockquote>\nI believe there is a Require JS optimiser that bundles together classes, but that seems to suggest extra maintenance and we lose the &quot;load only when required&quot; advantage.<br />\n</blockquote>\nYes optimiser will do that (bundle together classes) and more (can also act as a preprocessor or inline text templates or conditionally remove code fragments (like [Conditional[&quot;DEBUG&quot;]) etc.). I think that's what your bundler does - builds production site.\r<br />\n<br />\nYou don't loose &quot;load only when required&quot; - during optimization it will take only those dependencies that are really used by your main module. So if you've got library with 3 classes and project A uses only one class from it r.js optimizer will take only that one.<br />\n<blockquote>\nThis generates an additional closure<br />\n</blockquote>\nMinification + gzipping will reduce the size of file - especially when it's repeated over and over. Sure there is a runtime cost but for me it's like micro-optimization (like... do you avoid extending other classes because that would mean longer prototype chain and slower method calls?). Or maybe you're targeting older browsers - that's a different constraint. I'm personally waiting for browsers to implement it natively: <a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:modules\" rel=\"nofollow\">http://wiki.ecmascript.org/doku.php?id=harmony:modules</a> But for now I get easy development and fast runtime in modern browsers.<br />\n<blockquote>\nThis creates additional maintenance<br />\n</blockquote>\nWhat do you mean by maintenance in this context? I don't count code autogenerated by tsc as one that needs maintaining.<br />\n<blockquote>\nI believe these factors will have a significant impact when one is considering 300+ classes. <br />\n</blockquote>\nWhen I hit that mark I'll tell you what the difference is as I plan to measure it :)<br />\n<blockquote>\nI do agree that each approach suits a different need and set of constraints - so, yes, it's useful to know exactly which bits one is losing or gaining by picking a particular approach.<br />\n</blockquote>\nYes, each choice is a trade-off. I wanted to build a project that's completely backend agnostic (servers and technologies) and uses JavaScript for what it can and some more.\r<br />\n<br />\nWell if you think about it it's great that the TypeScript team could build a tool that can serve so many different needs. I usually very carefully select my dependencies (tools, frameworks) but TS brings so much value that now I can't live without it! :)<br />\n",
    "PostedDate": "2014-01-19T14:26:53.09-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1183909",
    "ThreadId": "507413",
    "Html": "<blockquote>\nSo the <a href=\"mailto:@Scripts.Render(&quot;~/FooScripts&quot;)\" rel=\"nofollow\">@Scripts.Render(\"~/FooScripts\")</a> concatenates all scripts and inserts one &lt;script&gt; tag? <br />\n</blockquote>\nOnly in production. In development same as your workflow: one script tag per file. So yes, in development one HTTP request per file. How does Require JS work in production to avoid the multiple HTTP requests?<br />\n<blockquote>\nHow does it know the correct order of concatenation? Builder configuration? references files?<br />\n</blockquote>\nThere is a builder configuration. The organisation of the projects into library and client ensures the configuration is minimal. However, this is the primary advantage of Require JS over my method.<br />\n<blockquote>\nWhat do you mean by &quot;one root directory&quot;? <br />\n</blockquote>\nAMD<br />\n<ul>\n<li>\nRoot<br />\n<ul>\n<li>\nLib<br />\nFile1.ts\n</li>\n<li>\nClient<br />\nFile2.ts<br />\n</li>\n</ul>\n</li>\n</ul>\nMy method<br />\n<ul>\n<li>\nLib<br />\nFile1.ts\n</li>\n<li>\nF:\\somepath\\Client<br />\nFile2.ts<br />\n</li>\n</ul>\n<blockquote>\nBut how does debugging and code browsing feel in one huge file?<br />\n</blockquote>\nThis is a misunderstanding. See the first answer.<br />\n<blockquote>\nWhat do you mean by maintenance in this context?<br />\n</blockquote>\nThe fact that with AMD every class that has a dependency on class Y must have an import statement referencing class Y. If class Y needs to move or be renamed then all import statements need to be modified. This is the maintenance that I refer to. With the &lt;reference&gt; approach we only deal with &quot;.d.ts&quot; and the reference is added only once per project.\r<br />\n<br />\nE.g:<br />\n<ul>\n<li>\nLib<br />\n_exports.d.ts // Exported types<br />\nFile1.ts<br />\n...<br />\nFileN.ts<br />\n</li>\n<li>\nClient<br />\n_references.d.ts // Contains &lt;reference path=&quot;../Lib/_exports.d.ts&quot; /&gt;<br />\nFile2.ts<br />\n</li>\n</ul>\nFrom the discussion it's a bit clearer that <br />\n<ul>\n<li>The Visual Studio-based approach has a further unit of compilation that is not explicitly spelled out in your approach: that of a &quot;Project&quot;, which is a collection of files. So, while it is necessary to configure the dependencies, it doesn't need to be done at the individual file level, rather it's done at the project level. So one may say &quot;This is my Library project, I will list it first in my bundling configuration in order to ensure those are the first &lt;script&gt; tags&quot;.</li>\n<li>\nWith AMD there is no need to worry about dependencies, so long as they are specified correctly via import statements. However, for our requirements this is too granular.<br />\n</li>\n</ul>\n",
    "PostedDate": "2014-01-20T02:59:59.643-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1184040",
    "ThreadId": "507413",
    "Html": "<blockquote>\nHow does Require JS work in production to avoid the multiple HTTP requests?<br />\n</blockquote>\nThe same way Script.Render does - by concatenating and minifying everything to one script file. But when you switch flag debug to false (or create Release build) I execute from command line &quot;grunt build&quot; and get optimized site in a &quot;dist&quot; subdirectory.<br />\n<br />\nWell, why talk about abstract things - you probably saw this micro-project: <a href=\"https://github.com/wiktor-k/ts-amd\" rel=\"nofollow\">https://github.com/wiktor-k/ts-amd</a><br />\nI checked it out at <a href=\"https://metacode.biz/sandbox/ts-amd/\" rel=\"nofollow\">https://metacode.biz/sandbox/ts-amd/</a> - no further modifications just git clone and compile ts (grunt).<br />\nAfter running &quot;grunt build&quot; in the same directory I get the production build: <a href=\"https://metacode.biz/sandbox/ts-amd/dist/\" rel=\"nofollow\">https://metacode.biz/sandbox/ts-amd/dist/</a><br />\n<br />\nFiddling with developer tools will show you how it's structured.<br />\n<blockquote>\n<blockquote>\nWhat do you mean by maintenance in this context?<br />\n</blockquote>\nThe fact that with AMD every class that has a dependency on class Y must have an import statement referencing class Y. If class Y needs to move or be renamed then all import statements need to be modified.<br />\n</blockquote>\nYes that is a weak point of my approach although I like that the dependencies are clearly specified and just glancing at the file header I can see how coupled it is with the rest of the system (I think it's called <a href=\"https://en.wikipedia.org/wiki/Confirmation_bias\" rel=\"nofollow\">confirmation bias</a> :) )<br />\n<br />\nIf you move a class to a different module you still need to update references though? Or does refactoring do that for you?<br />\n<br />\nThe _exports.d.ts and _references.d.ts sounds like a clean solution dividing code into projects. Do you know if it's a thing that VS plugin provides or could it be used from command line &quot;tsc&quot; tool? A quick google search didn't yield any interesting articles of how to set this up.<br />\n",
    "PostedDate": "2014-01-20T03:44:55.447-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1184339",
    "ThreadId": "507413",
    "Html": "The &quot;project&quot; is a Visual Studio thing. It is a way of organising a collection of code files that logically belong together. This works for C#, VB etc. and now there is a project type for TypeScript as well. \r<br />\n<br />\nIn the established C#/VB projects, Project A can add a reference to Project B in order to import all public types contained within that project.\r<br />\n<br />\nTypeScript projects at the moment do not permit referencing other projects. So the _exports/_references mechanism is something we've come up with to deal with it.\r<br />\n<br />\nIt looks a bit like this\r<br />\n<br />\n<strong>ProjectA</strong>\r<br />\n  _exports.ts    // &lt;reference path=&quot;One.ts&quot; /&gt; &lt;reference path=&quot;Two.ts&quot; /&gt;\r<br />\n  One.ts\r<br />\n  Two.ts\r<br />\n  Three.ts      // This is not exported\r<br />\n<br />\n<strong>ProjectB</strong>\r<br />\n   _references.ts  // &lt;reference path=&quot;../ProjectA/_exports.d.ts&quot; /&gt;\r<br />\n  //      Now has access to classes One, Two\r<br />\n<br />\nIf I were to rename class Two.ts to FooBar.ts (also renaming the TypeScript class defined within) then I only need to update ProjectA/_exports.ts.\r<br />\n<br />\nWhen ProjectB is compiled I would get an error that &quot;class Two does not exist&quot;. The thing to note is that it is a compilation error - not a reference error.\r<br />\n<br />\nOf course the way to avoid the compilation error is to ensure we use interfaces rather than concrete classes:\r<br />\n<br />\n<strong>ProjectInterfaces</strong>\r<br />\n  _exports.d.ts\r<br />\n  MyInterfaces.d.ts     // Defines interface FooBar\r<br />\n<br />\n<strong>ProjectA</strong>\r<br />\n   _references.ts  // &lt;reference path=&quot;../ProjectInterfaces/_exports.d.ts&quot; /&gt;\r<br />\n  One.ts\r<br />\n  FooBar.ts  // Implements interface FooBar\r<br />\n  Three.ts\r<br />\n<br />\n<strong>ProjectB</strong>\r<br />\n   _references.ts  // &lt;reference path=&quot;../ProjectInterfaces/_exports.d.ts&quot; /&gt;\r<br />\n  // Only knows about interface FooBar, doesn't care who implements it\r<br />\n<br />\nWill take a look at your project as well. Thanks!<br />\n",
    "PostedDate": "2014-01-20T05:26:57.98-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1184381",
    "ThreadId": "507413",
    "Html": "Okay now I understand it.\r<br />\n<br />\nI also saw that the _references.ts file is part of tsc: <a href=\"http://blogs.msdn.com/b/typescript/archive/2013/12/05/announcing-typescript-0-9-5.aspx\" rel=\"nofollow\">http://blogs.msdn.com/b/typescript/archive/2013/12/05/announcing-typescript-0-9-5.aspx</a> that may come in handy one day.<br />\n<blockquote>\nWhen ProjectB is compiled I would get an error that &quot;class Two does not exist&quot;. The thing to note is that it is a compilation error - not a reference error. <br />\n</blockquote>\nI don't know if I stated it but a missing external module is also a compile error (as tsc uses external modules to get type information):\r<br />\n<br />\ntest.ts:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">import</span> z = require(<span style=\"color:#A31515;\">&#39;z&#39;</span>);\r\n</pre></div><pre><code>&gt; tsc --module amd test.ts\ntest.ts(1,1): error TS2071: Unable to resolve external module ''z''.</code></pre>\n\nThanks for taking your time explaining your setup!\r<br />\n<br />\nReading this thread one can have enough &quot;workflows&quot; to choose from ;)<br />\n",
    "PostedDate": "2014-01-20T05:43:16.537-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1228960",
    "ThreadId": "507413",
    "Html": "FYI <code>grunt-ts</code> is no slower than raw <code>tsc</code> at the moment : <a href=\"https://github.com/grunt-ts/grunt-ts/issues/7#issuecomment-36444636\" rel=\"nofollow\">https://github.com/grunt-ts/grunt-ts/issues/7#issuecomment-36444636</a> <br />\n",
    "PostedDate": "2014-04-01T04:14:49.627-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1229281",
    "ThreadId": "507413",
    "Html": "Hi all,\r<br />\n<br />\nWiktork and Nabog - fantastically useful discussion there, it's really helping me understand the issues.  As a non-windows developer I'm probably going down Wiktork's route of grunt/require.js, but it was great to see the explanation of things to think about.\r<br />\n<br />\nI was wondering:<br />\n<ul>\n<li>\nIn both cases you've referred to large projects.  Do you use an existing MVC framework for them - like Backbone/Marionette or Angular?  If so, how have they coped with your workflows?  If not, did you build your own or go for a completely different approach?<br />\n</li>\n</ul>\nThanks,\r<br />\nAlastair<br />\n",
    "PostedDate": "2014-04-01T23:19:26.387-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1229843",
    "ThreadId": "507413",
    "Html": "Hi Alastair,\r<br />\n<br />\nWhen I started working on my project about a year ago I considered Angular but the definition files from DefinitelyTyped were poor. Every day I had to fix them or add more special cases and that was when I was still learning Angular so aligning my code to the framework was taking me too much time.\r<br />\n<br />\nIn the end I decided to write a small model/view layer in TS similar to Backbone but lightweight and strongly-typed and that worked well because of my application scope (small number of views and models). Most of my application's code is framework agnostic (the application can work completely offline and synchronizes data with backend when you're online).\r<br />\n<br />\nThe UI looks like that: <a href=\"https://metacode.biz/sandbox/issues-4.png\" rel=\"nofollow\">https://metacode.biz/sandbox/issues-4.png</a> you can judge if that's complex or not (although you don't see that the items are contenteditable and most of the backend-in-frontend synchronization logic :) ). For me the 4 KLOC of TS is not <em>that</em> large - I think nabog's project is far more bigger and ... &quot;enterprise&quot; :)\r<br />\n<br />\nI think now the definition files are more accurate so in your case I'd make a prototype to check that and to feel whether the framework feels natural. Oh, and if you're going with the AMD path I'd consider making everything an AMD dependency and dropping the /// references syntax at all. See pure.d.ts and pure.js here: <a href=\"https://github.com/wiktor-k/ts-amd/tree/master/scripts/lib\" rel=\"nofollow\">https://github.com/wiktor-k/ts-amd/tree/master/scripts/lib</a> It works well for any non-TS code that I have.<br />\n",
    "PostedDate": "2014-04-03T05:04:30.963-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1230246",
    "ThreadId": "507413",
    "Html": "Hi Wiktork,\r<br />\n<br />\nThanks for that.  I'm still not decided on the AMD issue but I am indeed working through a prototype.<br />\n\r<br />\nSo far, it's not clear to me why I should use AMD/require instead of just references?  Given that I grunt everything into a single app.js file, which so far that seems to be pretty quick, and that (as you mentioned) the definition files are now very comprehensive.  What advantage do you see?\r<br />\n<br />\nI'm keen to use a third-party, well-established MVC if possible.  We have an existing home-grown javascript MVC based loosely on backbone, but I'd like to move to something where lots of other people have done the wheel-inventing for me.  I'm looking at Backbone/Marionette at the moment and working back through the &quot;Gentle introduction to Marionette&quot; guide by Davic Sulc (<a href=\"https://leanpub.com/marionette-gentle-introduction\" rel=\"nofollow\">https://leanpub.com/marionette-gentle-introduction</a>), but with typescript instead.\r<br />\n<br />\nIt's working ok and typescript definitely makes for a smoother and more reliable experience.  But it's clear that as typescript gains in popularity there's scope for a more strongly-typed version, taking advantage of the compiler to reduce the number of &quot;magic strings&quot;.  I wouldn't be at all surprised if we see a &quot;typescript MVC&quot; in the near future.\r<br />\n<br />\ncheers,\r<br />\nAlastair<br />\n",
    "PostedDate": "2014-04-04T02:03:04.017-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1230451",
    "ThreadId": "507413",
    "Html": "Hi,\r<br />\n<br />\nWell there are two approaches to modules in TypeScript - you go with external modules and AMD or you go with internal modules and references. You don't want to mix them because it starts to become messy really quickly. I use AMD as I was already using require.js and plugins (text plugin, css plugin) when I worked on JavaScript projects. Then I concatenate the files into one only during production build (not development) using grunt: <a href=\"https://github.com/wiktor-k/ts-amd/blob/master/Gruntfile.coffee\" rel=\"nofollow\">https://github.com/wiktor-k/ts-amd/blob/master/Gruntfile.coffee</a> . Nabog uses internal modules and it works fine too. I like external modules/AMD as they look similar to Java, they look like modules proposed by ES6 (internal modules have been deprecated from ES6 but TS will support them) and... well... they look cleaner to me - import is part of the syntax but /// &lt;references&gt; looks like an ugly hack to me.\r<br />\n<br />\nBut as you can see from this thread it's more a matter of style than a clearly superior approach (like using spaces instead of tabs).\r<br />\n<br />\nUsing third-party MVC is a smart choice if you have a development team and want to concentrate on writing a product instead of framework and THEN a product :)\r<br />\n<br />\nYeah, &quot;magic strings&quot; is what annoys me too. See events (DOM events or Backbone events). For my project I wrote a simple class more similar to events used in Chrome extensions and that worked better with static types (one object per event type like onChange instead of functions accepting magic strings like addEventListener). But that's a topic on designing TS libraries and not workflow for typescript projects :)\r<br />\n<br />\nWiktor<br />\n",
    "PostedDate": "2014-04-04T10:52:27.35-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1231848",
    "ThreadId": "507413",
    "Html": "Just adding to @wiktork's explanations above...\r<br />\n<br />\nFirstly we are talking about client (Browser) code. For server-side code (NodeJS), one would always use external (CommonJS) modules.\r<br />\n<br />\nThe primary deciding factor between external and internal modules on the browser is to do with the management of the Global Scope. The internal modules approach starts off by partitioning the Global Scope into &quot;namespaces&quot;, where each namespace is a container for related types. With the external modules approach the global scope is inaccessible.\r<br />\n<br />\nHere is an example of the two approaches:\r<br />\n<br />\n<strong>External Modules</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">/* globals.ts */</span>\n<span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">enum</span> Colour {\n    red,\n    blue\n}\n\n<span style=\"color:Green;\">/* foo.ts*/</span>\n<span style=\"color:Green;\">// Error: Could not find symbol Colour</span>\n<span style=\"color:Blue;\">var</span> colour = Colour.blue;\n\n<span style=\"color:Green;\">// Okay</span>\n<span style=\"color:Blue;\">import</span> enums = require(<span style=\"color:#A31515;\">&#39;&lt;path&gt;/globals&#39;</span>);\n<span style=\"color:Blue;\">var</span> colour = enums.Colour.blue;\r\n</pre></div><strong>Internal Modules</strong><br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">/* globals.ts */</span>\n<span style=\"color:Blue;\">module</span> enums {\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">enum</span> Colour {\n        red,\n        blue\n    }\n}\n\n<span style=\"color:Green;\">/* foo.ts */</span>\n<span style=\"color:Green;\">/// &lt;reference path=&#39;&lt;path&gt;/globals.d.ts&#39; /&gt;</span>\n<span style=\"color:Blue;\">var</span> colour = enums.Colour.blue; <span style=\"color:Green;\">// okay</span>\r\n</pre></div>Each approach has its advantages.\r<br />\n<br />\nExternal modules Pros<br />\n<ul>\n<li>Cleaner conceptual model. Every type used in a specific file must be imported; no access to the global scope.</li>\n<li>\nLanguage support for the <code>import</code> statement.<br />\n</li>\n</ul>\nExternal modules Cons<br />\n<ul>\n<li>Import hell. Every type used in a specific file must be imported. This conflicts with the objectives of modularisation and one class per file. See <a href=\"https://typescript.codeplex.com/workitem/2212\" rel=\"nofollow\">workitem #2212</a> for a description of this problem.</li>\n<li>\nHigher maintenance/refactoring costs. Changing the file name of an exported module would require having to edit every importing file.<br />\n</li>\n</ul>\nInternal modules Pros<br />\n<ul>\n<li>More scalable. Types can be added to the global namespace and made available throughout the code-base.</li>\n<li>\nLess maintenance/refactoring costs. See <a href=\"#PostDetailsCell_1184339\" rel=\"nofollow\">my example above</a> on why this is true.<br />\n</li>\n</ul>\nInternal modules Cons<br />\n<ul>\n<li>The &lt;reference&gt; mechanism is still in a state of flux. No native language support has been proposed.</li>\n<li>\nRequires careful management of the global scope. Namespaces and types can be overwritten, resulting in runtime errors.<br />\n</li>\n</ul>\n<strong>How internal modules can be improved</strong>\r<br />\n<br />\nWe would require language support in order to ensure internal modules enjoy the same &quot;clean conceptual model&quot; as external modules:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">/* globals.ts */</span>\n<span style=\"color:Blue;\">module</span> enums {\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">enum</span> Colour {\n        red,\n        blue\n    }\n}\nObject.freeze(window.enums); <span style=\"color:Green;\">// Ensure namespaces are read-only</span>\n\n<span style=\"color:Green;\">/* foo.ts*/</span>\n<span style=\"color:Green;\">/// &lt;reference path=&#39;&lt;path&gt;/globals.ts&#39; /&gt;</span>\n<span style=\"color:Blue;\">var</span> colour = enums.Colour.blue; <span style=\"color:Green;\">// Should be error</span>\n\n<span style=\"color:Green;\">// New keyword &quot;import namespace&quot;</span>\n<span style=\"color:Blue;\">import</span> namespace enums;\n\n<span style=\"color:Blue;\">var</span> colour = Colour.blue; <span style=\"color:Green;\">// Now okay</span>\r\n</pre></div>In summary:<br />\n<ul>\n<li>The discussion of external vs internal modules is relevant only for client code.</li>\n<li>There is a lot of room for improving support for internal modules.</li>\n<li>Go with external modules if you have a small or medium sized project, or you do not have good control over the global scope (lots of externally loaded scripts).</li>\n<li>\nGo with internal modules for large projects and you have a good handle on the global scope.<br />\n</li>\n</ul>\nRelated discussions:\r<br />\n<br />\n<a href=\"https://typescript.codeplex.com/discussions/407063\" rel=\"nofollow\">TypeScript namespacing and modules</a>\r<br />\n<a href=\"https://typescript.codeplex.com/discussions/448336\" rel=\"nofollow\">Is module confusion holding back TypeScript?</a>\r<br />\n<br />\nAlso refer to the <a href=\"https://typescript.codeplex.com/wikipage?title=Modules%20in%20TypeScript&amp;referringTitle=Documentation\" rel=\"nofollow\">official documentation</a> for a basic introduction.<br />\n",
    "PostedDate": "2014-04-08T06:25:59.413-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1232054",
    "ThreadId": "507413",
    "Html": "Note: Object.freeze is a bad idea if added by default.  It makes property access slower because of the added security.<br />\n<br />\n<a href=\"http://jsperf.com/freeze-vs-seal-vs-normal/3\" rel=\"nofollow\">http://jsperf.com/freeze-vs-seal-vs-normal/3</a><br />\n<br />\nSome 2D game engines I know of stopped doing this awhile ago to gain speed.  If freeze was to be added, it would need to be optional - perhaps using a &quot;sealed/frozen&quot; modifier.<br />\n<br />\nIn regards to workflow, also consider source control.  I usually set '.gitignore' to exclude all .ts generated files (<em>.js, </em>.min.js, *.map) under a single folder nested in the main web project folder.  This helps me keep the .js files in parent directories/folders.  This I guess is more useful for those using multiple .js files instead of compiling into one big one, but thought I'd mention it anyhow.<br />\n",
    "PostedDate": "2014-04-08T14:59:17.037-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1232231",
    "ThreadId": "507413",
    "Html": "@jamesnw, \r<br />\n<br />\nObject.freeze <strong><em>cannot</em></strong> be added automatically because the compiler will never know if all the types for a specific namespace have been declared. That is something that will need to be added by the developer - perhaps in a script footer.\r<br />\n<br />\nThe performance of Object.freeze is largely due to a <a href=\"https://code.google.com/p/v8/issues/detail?id=1858\" rel=\"nofollow\">bug in Chrome</a>.\r<br />\n<br />\nIn Visual Studio there is no need to worry about generated files making their way to source control, because (since TS version 0.9) generated files are not included in the project, and, because the subversion, git, or TFS clients work off the project configuration, these are automatically excluded from source control.<br />\n",
    "PostedDate": "2014-04-09T03:35:55.403-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1232349",
    "ThreadId": "507413",
    "Html": "Yes, I'm aware of the chrome bug, but it still is current;y slower in many other browsers as well (though I admit not by much).  Unfortunately, people don't always update their browsers to latest ones (especially large development firms with strict policies).\r<br />\n<br />\ntschoartschi mentioned he doesn't use Visual Studio.  Also, I'm afraid your statement isn't true (especially for those who don't use VS).  You are right with TFS, but not Git.  I have GIT setup on many projects, and if you don't add files to .gitignore, then ALL files (in project or not) are picked up.  In fact , I use the &quot;<em>Microsoft</em> Git Provider&quot; extension, and had the same issues.  All other extensions I've tried do the same thing.  In fact, you can install the Git GUI and see yourself that all .js files are picked up (Git doesn't care about VS).  This is not TS related, but Git related.<br />\n",
    "PostedDate": "2014-04-09T07:38:01.32-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1232379",
    "ThreadId": "507413",
    "Html": "Okay, yes, a minor point, git is a special case. \r<br />\n<br />\nAs people move on to 100% TypeScript then the .gitignore shouldn't be that complicated an issue.<br />\n",
    "PostedDate": "2014-04-09T08:23:15.127-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1232384",
    "ThreadId": "507413",
    "Html": "100% TypeScript?  :)  Not sure what that means, but any web project would most likely never be 100% TypeScript because of .js files such as jquery, etc., that are used by many projects, and are only .js files (possibly with .d.ts files).  That said, I'm with you - the internet should all move to TS only. ;)<br />\n",
    "PostedDate": "2014-04-09T08:32:53.36-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1234852",
    "ThreadId": "507413",
    "Html": "This is a good discussion and I'm intrigued by some of the approaches here.\r<br />\n<br />\nI started a TS project awhile ago (a game) and I also use multiple VS TS projects and a Node.js project. So I learned the hard way I was supposed to start out with the AMD module approach... so I had part of a day when I switched all my internal modules from my other projects into AMD modules.\r<br />\n<br />\nNow, however, the only pain point I have is that my Shared TS project must copy its files into any dependent projects:<br />\n<ul>\n<li>Shared (TS)</li>\n<li>Engine (TS)</li>\n<li>Server (TS)</li>\n<li>\nNode (Node.js)<br />\n</li>\n</ul>\nSince my server contains both server-side and browser-side logic, Engine runs in browser but uses types from Shared. Server (TS) runs in Node but requires types from Shared.\r<br />\n<br />\nShared must be referenced by Engine and Server, as I share interfaces and utility methods. In order to do this with minimal pain, I have a Build Event on Shared that copies <em>.js and </em>.ts over to a <code>Engine\\Shared</code> directory, <code>Server\\Shared</code> and <code>Node\\Server\\Shared</code> directory (effectively).\r<br />\n<br />\nMy Engine and Server TS projects are configured to output to <code>..\\Node\\public\\javascripts</code> (Engine) and <code>..\\Node\\Server</code> (Server) respectively, so I don't need build events for those.\r<br />\n<br />\nThen in my Engine.ts (for example), I can do this:<br />\n<pre><code>import Models = require('./Shared/Models');</code></pre>\n\nwhere &quot;Models.ts&quot; is copied via build event from Shared TS project.\r<br />\n<br />\nThis works but I'm not super enthused about manual copy commands. Does anyone have an approach with AMD/CommonJS module approach that would work without that?<br />\n",
    "PostedDate": "2014-04-16T13:32:54.23-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1234952",
    "ThreadId": "507413",
    "Html": "@kayub correct me if I'm wrong but you want to use the same files in both projects without copying anything but you're using <code>--module amd</code> for the browser and <code>--module commonjs</code> for node?\r<br />\n<br />\nIf so, with a little bit of magic you can use TS files compiled with <code>--module amd</code> in node using this package: <a href=\"https://www.npmjs.org/package/amd-require\" rel=\"nofollow\">https://www.npmjs.org/package/amd-require</a> \r<br />\n<br />\nYou just add a line in your node.js code like that: <code>require('amd-require').baseUrl = '.';</code> and then <code>define()</code> and <code>require()</code> calls from AMD just work.\r<br />\n<br />\nOr you can use <a href=\"http://browserify.org/#middle-section\" rel=\"nofollow\">browserify</a> to do the reverse - get commonjs modules working in the browser. I think it would require an additional build step but I'm not sure as I haven't used this approach.<br />\n",
    "PostedDate": "2014-04-17T01:22:24.297-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1237096",
    "ThreadId": "507413",
    "Html": "The main problem from our projects perspective is that when using <br />\n<ul>\n<li>internal modules </li>\n<li>one class per file -approach and</li>\n<li>\noutputting to single file with 'tsc --out' <br />\n</li>\n</ul>\nyou have to maintain '/// references'-declarations in way or another by hand to get single file output correctly generated.\r<br />\n<br />\nWhat do you think, would it make sense if the <strong>compiler itself produced single file output with all necessary orderings</strong> already performed? It certainly has all the information available. \r<br />\n<br />\n(In other words, explain to me why on earth is this not already happening. Coming from any enterprise-y background, Java for example, this is the least you could expect from the compiler. And the typescript staff seems to wipe this issue under the rug every time. (<a href=\"http://typescript.codeplex.com/workitem/1590\" rel=\"nofollow\">#1590</a>))<br />\n",
    "PostedDate": "2014-04-23T08:14:37.39-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1237191",
    "ThreadId": "507413",
    "Html": "PSP2 - you're definitely correct.  A major shortcoming with TypeScript today is that it's far more difficult than it should be to follow the one class per file approach.\r<br />\n<br />\nVery simple projects (demos or tests) don't run into this problem because they can live all in one file, and &quot;application scale&quot; projects don't either since the time spent to implement the work-arounds is small compared to their entire scope.  It's the developers working on small to medium real-world projects that feel this pain the most.\r<br />\n<br />\nI'm hopeful that with TypeScript 1.0 is out the door that we'll see some significant improvements here.<br />\n",
    "PostedDate": "2014-04-23T11:02:53.21-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1237394",
    "ThreadId": "507413",
    "Html": "For reference, this is how palantir is going about their typescript modules: <a href=\"https://github.com/palantir/eclipse-typescript/issues/128\" rel=\"nofollow\">https://github.com/palantir/eclipse-typescript/issues/128</a><br />\n",
    "PostedDate": "2014-04-24T00:33:47.52-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1240373",
    "ThreadId": "507413",
    "Html": "<strong>wiktork wrote:</strong><br />\n<blockquote>\n@kayub correct me if I'm wrong but you want to use the same files in both projects without copying anything but you're using <code>--module amd</code> for the browser and <code>--module commonjs</code> for node?<br />\n<br />\nIf so, with a little bit of magic you can use TS files compiled with <code>--module amd</code> in node using this package: <a href=\"https://www.npmjs.org/package/amd-require\" rel=\"nofollow\">https://www.npmjs.org/package/amd-require</a> <br />\n<br />\nYou just add a line in your node.js code like that: <code>require('amd-require').baseUrl = '.';</code> and then <code>define()</code> and <code>require()</code> calls from AMD just work.<br />\n<br />\nOr you can use <a href=\"http://browserify.org/#middle-section\" rel=\"nofollow\">browserify</a> to do the reverse - get commonjs modules working in the browser. I think it would require an additional build step but I'm not sure as I haven't used this approach.<br />\n</blockquote>\nI checked and am using CommonJS across the board.<br />\n<br />\nNo, the issue is at <em>compile time</em> in VS, I need the references in the appropriate folders.<br />\n<br />\nFor example, in <code>Server\\Models.ts</code> I want to go and get some common interfaces:<br />\n<pre><code>import Shared = require('.\\Shared\\Models.ts');\n</code></pre>\n\nFor this to work, that TS file must be there at compile time. In order to get it there, I use a post-build event on the Shared project to copy into the destination directories.<br />\n<br />\nOn a related note, I wish TS supported the module folders... so I could just require a folder with a bunch of TS files instead of individual ones.<br />\n",
    "PostedDate": "2014-05-01T13:04:35.267-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1246051",
    "ThreadId": "507413",
    "Html": "For what its worth, I started our enterprise-scale project using Internal modules (as detailed above by @nabog), and have just recently switched over to External modules using RequireJS.  I'm quite happy with the result, and am fairly certain this will be much more maintainable as the project grows.<br />\n\r<br />\nThe main issue we had with Internal modules was the ordered loading of scripts - if you got one script loaded in the wrong order, your app blows up at runtime.  We use the excellent <a href=\"https://github.com/grunt-ts/grunt-ts\" rel=\"nofollow\">Grunt-TS</a> to compile, which generates a useful <code>reference.ts</code> file which you can tweak to specify the order of your TS scripts.  But, you have to get the order right, and it doesn't concern itself with any external JS libs that also need to be loaded first and in a specific order.  When your project starts getting over 100+ TS scripts, and you create a class that has several dependencies and is also a dependency for other classes, you have to be sure that its loaded in a very precise order.  When you have even a few people working on a project, this isn't sustainable.\r<br />\n<br />\nIt's also worth noting that using ASP.NET script bundling would still expose the same issue - you need to ensure the correct load order, as ASP.NET doesn't know about any script dependencies.  Although we have .NET services, we chose not to use ASP.NET anyway, as its an unnecessary dependency for a html/js app.\r<br />\n<br />\nSo we switched to External AMD modules and RequireJS.  Yes, you have to have imports at the top of each file - but this isn't much different to namespace/package imports in C#/Java, and makes it very clear what the dependencies are for a class.  And, if you find you're amassing a huge list in a file, then it's a good hint that your class is perhaps trying to do too much and time to refactor.  Once you've set up your RequireJS config with any specific paths and shims for non-AMD libs, you're pretty much good to go.\r<br />\n<br />\nAnyway, it's early days, but this is certainly proving to be a much more sustainable workflow for enterprise apps.<br />\n",
    "PostedDate": "2014-05-16T02:55:58.59-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1246057",
    "ThreadId": "507413",
    "Html": "@MarcusWhit just a heads up grunt-ts can help you with external modules as well. \r<br />\n<br />\nIf you do <code>///ts:import=commandServices</code> in your file, grunt ts will generate something like: <br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">///ts:import=commandServices</span>\n<span style=\"color:Blue;\">import</span> commandServices = require(<span style=\"color:#A31515;\">&#39;../../../types/commandServices&#39;</span>); <span style=\"color:Green;\">///ts:import:generated</span>\r\n</pre></div>before it compiles the typescript file. The good news is that a.) you don't care about relative paths. and b.) The path is updated if you move the file around in your project. \r<br />\n<br />\nAlso supported are these transforms: \r<br />\n<br />\n<code>///ts:export=someThing</code> that does an <code>import export</code> \r<br />\n<code>///ts:ref=someThing</code> that does a tranditional <code>///&lt;reference</code>  import.\r<br />\n<br />\nDesign notes : <a href=\"https://github.com/grunt-ts/grunt-ts/issues/85\" rel=\"nofollow\">https://github.com/grunt-ts/grunt-ts/issues/85</a><br />\n",
    "PostedDate": "2014-05-16T03:09:04.437-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1246058",
    "ThreadId": "507413",
    "Html": "@basarat - that's gold.  We were just complaining yesterday of all the string paths and issues created if you want to move files around!  Thanks.<br />\n",
    "PostedDate": "2014-05-16T03:19:42.6-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1246186",
    "ThreadId": "507413",
    "Html": "<strong>MarcusWhit wrote:</strong><br />\n<blockquote>\nYes, you have to have imports at the top of each file - but this isn't much different to namespace/package imports in C#/Java, and makes it very clear what the dependencies are for a class.<br />\n</blockquote>\n<code></code>\r<br />\n<br />\n<br />\n@MarcusWhit, TypeScript imports are <strong><em>not</em></strong> the same as the C# using directives when following the one class per file approach. (They are only equivalent if, in the TypeScript case, all the types in a namespace are declared in one file which is then imported.)\r<br />\n<br />\nYes, if you have very complicated dependencies between classes then RequireJS would be the right solution.\r<br />\n<br />\nIt might also be worth asking &quot;why do I have such complicated dependencies?&quot;<br />\n",
    "PostedDate": "2014-05-16T09:04:45.147-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1246231",
    "ThreadId": "507413",
    "Html": "\r\n<p dir=\"ltr\">I didn't say they're the same, I just suggested it's similar to what most are already used to in C#/Java. Some don't want to have several require statements in each file, but it's really a non issue when you consider this.\r\n</p>\r\n<p dir=\"ltr\">In my experience, the dependencies don't need to be especially complicated to make listing them all in a perfect order somewhat painful. Each class may only have a few dependencies, but if you have a large enterprise application with 100's or 1000's\r\n of classes, the dependency tree is going to be difficult to manually manage in one central list. In a small app it's unlikely to be an issue.\r\n</p>\r\n<p dir=\"ltr\">Each to their own though. </p>\r\n<div></div>\r\n",
    "PostedDate": "2014-05-16T10:03:44.457-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1246282",
    "ThreadId": "507413",
    "Html": "thanks, this was explained wonderfully.  I really like your idea of the &quot;import namespace&quot; keywords.  Can't believe that I've spent the better part of a day and half researching modules and how to correctly organize code!! (and I'm still confused as hell!)  I barely gave this two minutes of thought in the .Net world!  Sorry just had to vent, thanks again.<br />\n",
    "PostedDate": "2014-05-16T11:43:16.123-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1246646",
    "ThreadId": "507413",
    "Html": "@MarcusWhit, there is something that you are doing wrong here. I am not at all sure what the &quot;dependency tree&quot; is that you have to manage.\r<br />\n<br />\nWe have well in excess of the 100 TypeScript files that you have, and less than five script dependencies to manage.\r<br />\n<br />\n@FreddyV, glad the discussion was useful to you. To be honest we learnt a few things from this as well, in particular @wiktork's comment about having a dependency only on a &quot;dumb HTTP server&quot; is a good one.<br />\n",
    "PostedDate": "2014-05-18T07:24:00.613-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]