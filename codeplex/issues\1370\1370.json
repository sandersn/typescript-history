{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "As part of our move to GitHub, we're closing our CodePlex suggestions and asking that people move them to the GitHub issue tracker for further discussion.  Some feature requests may already be active on GitHub, so please make sure to look for an existing issue before filing a new one.\n\nYou can find our GitHub issue tracker here:\nhttps://github.com/microsoft/typeScript/issues\n",
    "ClosedDate": "2014-07-28T15:18:09.957-07:00",
    "CommentCount": 9,
    "Custom": null,
    "Description": "It would be interesting to extend TypeScript in a more reliable fashion by allowing the compiler to be extensible. As a result, 3rd parties could leverage the published TypeScript version and, through the use of a composition or plugin model, extend TypeScript along a well-defined API surface.\r\n\r\nIdeally it would be a great benefit to have a mechanism where a plugin or extension author could subclass the Compiler, Scanner, Parser, Pull-Type Checker, Emitter, and other interesting internals, to add additional capabilities.\r\n\r\nAs a result, plugin authors could use the well-defined surface to add additional behavior to TypeScript, such as minification at compile time, extensions to the language, embed other languages, localize at compile time, emit debug or coverage metadata, refactoring, etc., without needing to fork the entire codebase and find a means to keep the fork and the extensions in sync.\r\n\r\nPlease consider providing a published extensibility API for the TypeScript compiler, and a means to provide plugins either via command-line switches and/or by providing a global \"plugins\" folder in the TypeScript installation path. \r\n\r\nThere of course are open questions and likely concerns around forcing TypeScript into a well-defined API surface, which could make it more difficult to change the API to add future capabilities, as well as how plugins could effectively interface with tooling such as the Visual Studio language extensions.",
    "LastUpdatedDate": "2017-11-27T11:51:33.707-08:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Unassigned",
      "Severity": 0,
      "Id": 0
    },
    "ProjectName": "typescript",
    "ReportedDate": "2013-07-18T17:09:32.697-07:00",
    "Status": {
      "Name": "Closed",
      "Id": 4
    },
    "ReasonClosed": {
      "Name": "External"
    },
    "Summary": "Make the TypeScript Compiler extensible",
    "Type": {
      "Name": "Unassigned",
      "Id": 5
    },
    "VoteCount": 27,
    "Id": 1370
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "Thanks for the suggestion, assigned to Jonathan.",
      "PostedDate": "2013-07-19T11:14:12.853-07:00",
      "Id": 106655
    },
    {
      "Message": "As an example use of compiler extensibility, we can think of AngularJS and its DI annotations.\n\n```\nexport class TodoCtrl {\n\n\t// $inject annotation.\n\t// It provides $injector with information about dependencies to be injected\n\t// into constructor. It is better to have it close to the constructor, because\n\t// the parameters must match in count and type.\n\t// See http://docs.angularjs.org/guide/di\n\tpublic static $inject = [ '$scope', '$location', 'todoStorage', 'filterFilter' ];\n\n\t// dependencies are injected via AngularJS $injector\n\tconstructor(\n\t\tprivate $scope: ITodoScope,\n\t\tprivate $location: ng.ILocationService,\n\t\tprivate todoStorage: ITodoStorage,\n\t\tprivate filterFilter\n\t) {\n\t\t//...\n```\n\nIn order for DI not to break after minification, developers have to add $inject annotations manually. Would be cool if it was generated by the compiler.\n\n```\nexport class TodoCtrl {\n\n\t[Injectable] // this attribute tells the compiler extension to generate $inject for us\n\tconstructor(\n\t\tprivate $scope: ITodoScope,\n\t\tprivate $location: ng.ILocationService,\n\t\tprivate todoStorage: ITodoStorage,\n\t\tprivate filterFilter\n\t) {\n\t//...\n```\n",
      "PostedDate": "2013-10-06T13:24:25.33-07:00",
      "Id": 117602
    },
    {
      "Message": "I'd love to see this. Postsharp-style attributes (http://doc.postsharp.net/postsharp-2.1/Default.aspx##PostSharp-2.1.chm/html/T_PostSharp_Aspects_OnMethodBoundaryAspect.htm) would be amazing (except they'd probably transform a compile-time syntax tree rather than doing runtime AOP).\n\nAnother use case for this could be an attribute that makes all of a class' properties into knockout observables, or a way to control which method is used to implement inheritance (so I can use a JS framework's object.extend method instead of typescripts, for specific classes instead of the current global hack)",
      "PostedDate": "2013-10-06T17:57:36.087-07:00",
      "Id": 117609
    },
    {
      "Message": "On the other hand, this might be achievable with macros if they were added to the language.",
      "PostedDate": "2013-10-09T06:08:42.853-07:00",
      "Id": 117910
    },
    {
      "Message": "This is probably my #1 request for the language. I think a feature like this would really help strengthen the TypeScript platform / ecosystem. I can think of quite a few uses, most notably:\n\n1 - Tree-shaking assertions, and other debug-related development code before shipping.\n2 - Custom linters that enforcing company-specific guidelines on various code structures.\n\nPlease consider!",
      "PostedDate": "2014-01-31T09:38:52.513-08:00",
      "Id": 132243
    },
    {
      "Message": "I wrote a small story about [module resolution plugins here](https://typescript.codeplex.com/discussions/539193).",
      "PostedDate": "2014-03-16T17:39:54.28-07:00",
      "Id": 136987
    },
    {
      "Message": "This would be great for custom APIs. I think this would open many creative doors. :)",
      "PostedDate": "2014-04-08T18:20:00.737-07:00",
      "Id": 141038
    },
    {
      "Message": "Indeed, this is #1 feature IMO. Mother of all features. Please give users the opportunity to explore their ideas.",
      "PostedDate": "2014-04-08T19:29:44.807-07:00",
      "Id": 141048
    },
    {
      "Message": "Another use: adding JSDoc comments to the AST based on type information. Currently I have to hack with TS internals to achieve that: https://typescript.codeplex.com/discussions/541331",
      "PostedDate": "2014-05-23T16:51:12.68-07:00",
      "Id": 147590
    }
  ]
}