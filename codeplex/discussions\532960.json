[
  {
    "Id": "1210809",
    "ThreadId": "532960",
    "Html": "Hey guys,<br />\n<br />\nI'm currently evaluating TypeScript for quite intensive use in the near future. These days I use Haxe a lot and I got used to the wonderful and lightweight entity-component system that is <a href=\"http://www.ashframework.org/\" rel=\"nofollow\">Ash Framework</a>.<br />\n<br />\nSince there are no TypeScript definitions on DefinitelyTyped for <a href=\"https://github.com/brejep/ash-js\" rel=\"nofollow\">AshJS</a>, I have to make my own as I go.<br />\n<br />\nThe problem comes from the fact that nodes, which are user made classes extending ash.core.Node (Ash.Node), need to be created this way in the JS version of Ash:<br />\n<pre><code>var CustomNode = Ash.Node.create( { componentVarName: ComponentClass } );</code></pre>\n\nwhich is a convenience function relying on of Ash.Node.extend. &quot;CustomNode&quot; is meant to be a class btw, not an instance.<br />\n<br />\n<strong>The exact problem is that I need a CustomNode type to exist in the eyes of TypeScript compiler, but I need to define CustomNode using Ash.Node.create. How can I reconcile those two ?</strong><br />\n<br />\n<br />\n<br />\nYou can read on for more information:<br />\n<br />\nAsh.Node.extend, used by Ash.Node.create, comes from a very small API that mimics inheritance. You can find the code <a href=\"https://github.com/brejep/ash-js/blob/master/lib/brejep/class.js\" rel=\"nofollow\">here</a>.<br />\n<br />\nSo if CustomNode is created as a class, it conflicts with the Ash.Node.create method.<br />\n<br />\nCustomNode signature should be<br />\n<pre><code>class CustomNode extends Ash.Node&lt;CustomNode&gt; { componentVarName:ComponentClass; }</code></pre>\n\nIn ash.d.ts, I declared Node itself as follows:<br />\n<pre><code>declare module Ash {\n    export class Node&lt;TNode extends Node&lt;TNode&gt;&gt; {\n        // stuff\n    }\n}</code></pre>\n\nThen in the code, sometimes you need to retrieve all nodes of a certain type, it is done as follows:<br />\n<pre><code>var list:NodeList&lt;CustomNode&gt; = engine.getNodeList&lt;CustomNode&gt;(CustomNode);</code></pre>\n\nwith getNodeList declared within ash.d.ts as:<br />\n<pre><code>getNodeList&lt;TNode extends Node&lt;TNode&gt;&gt;(nodeClass:any):NodeList&lt;TNode&gt;;</code></pre>\n\nNodes are never instantiated by the user - he only defines them. They are used internally by the engine to group components by type.<br />\n<br />\nSo as I said, the bottom line is that I need the CustomNode type to exist in TypeScript, yet have CustomNode defined with Ash.Node.create.<br />\n<br />\n<br />\nThanks A LOT if you can untangle this ! :)<br />\n",
    "PostedDate": "2014-02-19T15:33:44.773-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1211239",
    "ThreadId": "532960",
    "Html": "I'm not familiar with that framework, but a couple things that hopefully will help.\r<br />\n<br />\nThe first is that if you're creating .d.ts files for existing JS libraries, I'd start by using interfaces for pretty much every type first.  Once you get it typed that way, you can look into using classes.  Interfaces are generally the most flexible and expressive.\r<br />\n<br />\nFor example, an interface that describes the constructor function:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">declare</span> <span style=\"color:Blue;\">module</span> Ash.Node {\n                <span style=\"color:Blue;\">interface</span> Constructable&lt;T&gt; {\n                                <span style=\"color:Blue;\">new</span>(...args: <span style=\"color:Blue;\">any</span>[]): T;\n                }\n\n                <span style=\"color:Blue;\">function</span> create&lt;T&gt;(prototype: T): Constructable&lt;T&gt;;\n}\n\n<span style=\"color:Blue;\">var</span> Node = Ash.Node.create({ helloWorld: () =&gt; console.log(<span style=\"color:#A31515;\">&#39;hi&#39;</span>) });\n<span style=\"color:Blue;\">var</span> n = <span style=\"color:Blue;\">new</span> Node();\nn.helloWorld();\n\r\n</pre></div>The part I'm less sure about is mapping parameters from what you pass into new over to the resulting class.  You can do some of this with generics, though the recursively constrained generics like you're using like &lt;TNode extends Node&lt;TNode&gt;&gt;are being <a href=\"https://typescript.codeplex.com/wikipage?title=Known%20breaking%20changes%20between%200.8%20and%200.9&amp;referringTitle=Documentation\" rel=\"nofollow\">removed to simplify the type system</a>, and I'm not sure you need them in this case - at least to get started.<br />\n",
    "PostedDate": "2014-02-20T08:48:49.05-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1211353",
    "ThreadId": "532960",
    "Html": "Interesting way to define stuff, I'll try to think more in this way. I still don't quite get when to declare stuff as modules, classes or interfaces. For now I tend to default to module = mostly lib packages, class = whenever I need to extend the object's functionality, interface = when TypeScript only needs to instantiate that object, not extend it.<br />\n<br />\nRegarding the issue, the compiler complains whenever I use CustomNode as a type if I use your example. (Error TS2095 &quot;could not find symbol&quot;)<br />\nBefore reading your reply I decided to just fall back to doing whatever Ash.Node.create is doing by hand, which means defining CustomNode this way:<br />\n<pre><code>class CustomNode extends Ash.Node&lt;CustomNode&gt;\n{\n    public componentVarName: ComponentClass;\n    public types: { componentVarName: typeof ComponentClass; };\n}\nCustomNode.prototype.types = {componentVarName: ComponentClass};\nCustomNode.prototype.componentVarName = null;</code></pre>\n\nIt works without compiler error but I guess that ideally I shouldn't use prototype in TypeScript :)<br />\n<br />\n<br />\nRegarding recursive generics, I thought it described the situation properly. The main Ash.Node class has members of type T, but these must extend Node. I'm not sure that code completion works correctly when I access those members, but the compiler accepts it. I suppose I'll simplify the defs with a bunch of &quot;any&quot; when v0.9.7 is out :)<br />\n<br />\n<br />\nBy the way, do you know a way to define the type of nodeClass here ? This is defined inside an &quot;export class&quot;.<br />\n<pre><code>getNodeList&lt;TNode extends Node&lt;TNode&gt;&gt;(nodeClass:any):NodeList&lt;TNode&gt;;</code></pre>\n\n&quot;any&quot; is supposed to be &quot;typeof TNode&quot;, but that's incorrect use of generics (symbol not found). Just curious. The solution probably necessitates to rewrite that declaration completely...<br />\n",
    "PostedDate": "2014-02-20T12:20:08.097-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1211356",
    "ThreadId": "532960",
    "Html": "Some others can probably chime in with their experiences but I'll echo what Jonathan said. When I was using TypeScript with a JS library that did inheritance with this sort of pattern (the ImpactJS game engine) I found that it was best to stick with interfaces rather than classes for the most part. <br />\n<br />\nTo your second post: Interfaces can be extended just as classes can. Modules are containers (of types, values and/or other containers), while classes and interfaces are used to describe the shape of types (and their implementation in the case of classes).<br />\n<br />\nThe typeof operator only operates on values, not types. TNode is a type in this case.<br />\n",
    "PostedDate": "2014-02-20T12:23:55.777-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]