[
  {
    "Id": "1093717",
    "ThreadId": "457222",
    "Html": "Hello,<br />\n<br />\nI'm trying to create a simple node.js project with typescript, but I just can't structure my code into several files as I usually do. It seems that I would have to put everything in one big file to be able to compile it to usable javascript.<br />\n<br />\nUsed Typescript version: 0.9.1.1<br />\n<br />\n<strong>Here is a simple test project of 3 files:</strong><br />\n<br />\nmain.ts:<br />\n<pre><code>/// &lt;reference path=&quot;config.ts&quot; /&gt;\n\nimport my = require(&quot;myclass&quot;);\n\nconsole.log(&quot;Main: &quot; + Config.secret);\n\nvar m = new my.MyClass();\nm.hello();</code></pre>\n\nThe main file references a config file and the myclass external module.<br />\n<br />\nmyclass.ts:<br />\n<pre><code>/// &lt;reference path=&quot;config.ts&quot; /&gt;\n/// &lt;reference path=&quot;node.d.ts&quot; /&gt;\n\nimport util = require(&quot;util&quot;);\n\nclass MyClass { \n    hello() {\n        util.log(&quot;Hello World: &quot;+Config.secret);\n    }       \n}</code></pre>\n\nUnfortunately this module cannot be referenced with a reference comment, because it automatically becomes an external module when I put the import ... require statement in it to use the util node.js module. But note that it also uses the config file.<br />\n<br />\nconfig.ts:<br />\n<pre><code>module Config {\n    export var secret = 42;\n}</code></pre>\n\nThis file is referenced by the other two. They both use the secret constant.<br />\n<br />\nNow the question is: <br />\n<strong>How can I compile this simple project with tsc to a working javascript code?</strong><br />\n<br />\nLet's see what I got:<br />\n<br />\n<strong>1. Let's try to build each file separately</strong><br />\n<blockquote>\ntsc main.ts --module commonjs<br />\nnode main.js<br />\nmain.js:4<br />\nconsole.log(&quot;Main: &quot; + Config.secret);<br />\nReferenceError: Config is not defined<br />\n</blockquote>\nSo it compiles. I get: main.js, myclass.js, config.js. But they are not connected in any way which means that if I try to run this version the main.js won't see the config file. I would have to manually concatenate the two.<br />\n<br />\n<strong>2. Let's ask typescript to put everything in one output file:</strong><br />\n<blockquote>\ntsc main.ts --module commonjs --out main.js<br />\nnode main.js<br />\n</blockquote>\nIt also compiles. I get two files: main.js and myclass.js. But when I try to run it, nothin happens at all. Why? Let's see the generated main.js.<br />\n<br />\nmain.js:<br />\n<pre><code>var Config;\n(function (Config) {\n    Config.secret = 42;\n})(Config || (Config = {}));</code></pre>\n\nWhat?? The main.js contains the config file, just as I would expect I referenced it from main.ts, so it gets compiled to main.js. But where is the rest of the file? It's missing!<br />\n<br />\nLet's see what we got in myclass.js.<br />\n<br />\nmyclass.js:<br />\n<pre><code>/// &lt;reference path=&quot;config.ts&quot; /&gt;\n/// &lt;reference path=&quot;node.d.ts&quot; /&gt;\nvar util = require(&quot;util&quot;);\n\nvar MyClass = (function () {\n    function MyClass() {\n    }\n    MyClass.prototype.hello = function () {\n        util.log(&quot;Hello World: &quot; + Config.secret);\n    };\n    return MyClass;\n})();\n</code></pre>\n\nUh-oh. No config here. This wouldn't work either. This somehow didn't understand my wish to put referenced files where they need.<br />\n<br />\n<strong>3. I'm out of ideas.</strong> I don't know any other method how I could compile this project to a working javascript program.<br />\n<br />\n<strong><em>Let's see what I would expect from the compiler:</em></strong><br />\n<br />\n<strong>1. The easiest way and simplest way:</strong> The compiler would take each external modules, compile them separately and it should copy all the referenced files in each and every external module. In this case main.js and myclass.js should both contain the config file, so they can use it.<br />\n<br />\nLike this:<br />\n<br />\nmain.js should be:<br />\n<pre><code>var my = require(&quot;myclass&quot;);\n\nvar Config;\n(function (Config) {\n    Config.secret = 42;\n})(Config || (Config = {}));\n\nconsole.log(&quot;Main: &quot; + Config.secret);\n\nvar m = new my.MyClass();\nm.hello();</code></pre>\n\nmyclass.js should be:<br />\n<pre><code>var util = require(&quot;util&quot;);\n\nvar Config;\n(function (Config) {\n    Config.secret = 42;\n})(Config || (Config = {}));\n\nvar MyClass = (function () {\n    function MyClass() {\n    }\n    MyClass.prototype.hello = function () {\n        util.log(&quot;Hello World: &quot; + Config.secret);\n    };\n    return MyClass;\n})();</code></pre>\n\n<strong>2. The smart way:</strong> The compiler shouldn't consider myclass.ts an external module just because I have imported a node.js module in it. It should be easily referenced with the reference comment in main.ts. And the resulting main.js should contain MyClass and also Config. The compiler should be able to understand that they both need the Config module so it would come first. <br />\n<br />\nSomething like this:<br />\n<br />\nmain.js should be if the compiler would be very smart:<br />\n<pre><code>var Config;\n(function (Config) {\n    Config.secret = 42;\n})(Config || (Config = {}));\n\nvar util = require(&quot;util&quot;);\n\nvar MyClass = (function () {\n    function MyClass() {\n    }\n    MyClass.prototype.hello = function () {\n        util.log(&quot;Hello World: &quot; + Config.secret);\n    };\n    return MyClass;\n})();\n\nconsole.log(&quot;Main: &quot; + Config.secret);\n\nvar m = new MyClass();\nm.hello();</code></pre>\n\nSo I could get a nice and working program. What do you think? Should I put everything in what huge app.ts file? Isn't there any way that I could structure my node.js app source code into several files? At the end of course I want one javascript file, or at least a file for each module, but I expect the compiled program to run and work properly in node.js. <br />\n<br />\n<strong>Any ideas how I could achieve this?</strong><br />\n<br />\nThank you!<br />\n<br />\nps: When I started my research about this topic I didn't completely understand why I couldn't reference a file that contains import ... require. I have wrote about my experiences here: <a href=\"https://typescript.codeplex.com/workitem/1690\" rel=\"nofollow\">https://typescript.codeplex.com/workitem/1690</a> What about using var ... require to use node modules?<br />\n",
    "PostedDate": "2013-09-17T12:44:14.68-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1098817",
    "ThreadId": "457222",
    "Html": "In Node.js every piece of code you load is a module - including the very first file you specify on the command line.  Nothing you write contributes to the global scope.  Everything should be compiled with --module commonjs.\r<br />\n<br />\nWhen compiling for the global scope (i.e. simple browser files loaded via &quot;script&quot; tags, and NOT using the --module switch), you can use --out to join files together.  However TypeScript does not support multi-file external modules.  Each input source file should map to one external module when using --module.\r<br />\n<br />\nIt appears you are trying to join the config.ts file into your modules via /// references.  Due to the above rule, this can't be done.  This code either needs to be within the source file, or you need to load it as an external module (i.e. &quot;import config = require('./config');&quot; in the consumer, and &quot;export var secret = 42;&quot; in the config.ts).\r<br />\n<br />\nBasically, you should not use /// reference tags in external modules for anything other than declarations of other external modules (i.e. as the node.d.ts file does to  declare module &quot;path&quot;, and &quot;fs&quot; etc....).  It doesn't make sense to /// reference other implementation code due to our one-on-one source-to-module mapping, and the fact that in Node everything you write is an external module.\r<br />\n<br />\nHopefully this makes sense.<br />\n",
    "PostedDate": "2013-09-24T17:45:16.473-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1099415",
    "ThreadId": "457222",
    "Html": "Thank you for your explanation.\r<br />\nI'll try to put everything in an external module then if there is no other solution.\r<br />\n<br />\nWhat about writing this in typescript:<br />\n<pre><code>var util = require(&quot;util&quot;);</code></pre>\n\nThen the typescript compiler wouldn't consider my source file as an external module, so I could just reference everything and compile the program into one file with the --out option. I tried it and it works, but with this trick intellisense stops working in visual studio. Is there a way to make typescript write &quot;var util = require(&quot;util&quot;);&quot; to the output and still declare util as a module somehow?\r<br />\n<br />\nI want this so badly because it doesnt seem right to create an external module for each class just because I want to write classes in separate files. Maybe a preprocessor could help that would merge ts files into one before compilation?<br />\n",
    "PostedDate": "2013-09-25T15:48:09.93-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1099466",
    "ThreadId": "457222",
    "Html": "I also found the compilation behavior of TypeScript with multiple associated files to be awkward in my project.  It would be great to have a story closer to &quot;partial classes&quot; found in VB/C#.  The solution I was able to come up with was keeping each of the files separate in the initial build (meaning that I have to reference each one separately in my tests html file), but to then combine them in the minification step using UglifyJS 2 (so I have separate HTML files that run the tests against the &quot;built&quot; JS files and the minified JS files).\r<br />\n<br />\nI'm honestly allowing my core library file to grow to an unmanageable size mainly because I'm afraid of refactoring it due to the pain of how TypeScript 0.9.1.1 deals with many files declaring the same module name.\r<br />\n<br />\nIf anyone is interested, the Node.js script that I use to build my TypeScript project and minify the results is here:\r<br />\n<br />\n<a href=\"https://github.com/ShamnaSkor/WafleProject/blob/master/Wafle/Wafle/build/build.ts\" rel=\"nofollow\">https://github.com/ShamnaSkor/WafleProject/blob/master/Wafle/Wafle/build/build.ts</a>\r<br />\n<br />\nPS: I'm also using an &quot;eval&quot; trick on line 30 that I found on Stack Overflow to load the compiled wafleCore.js so I can pull out the version number which is stored in a variable - that's one way to use the outputted JS files without requiring them to be CommonJS modules.<br />\n",
    "PostedDate": "2013-09-25T20:45:47.563-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1099751",
    "ThreadId": "457222",
    "Html": "It seems that some functionality got lost when modules lost their interfaces: we can no longer refer to the interface of a string-named module (like <code>module &quot;util&quot;</code>).\r<br />\n<br />\nFor non-string-named modules, we could use<br />\n<pre><code>declare module u {\n    export function format(format: any, ...param: any[]): string;\n    ...\n}\n\nvar util:typeof u = require(&quot;util&quot;);</code></pre>\n\nto get external modules imported without creating an external module, while still getting IDE functionality. But in the case of string-named modules, I don't know of a valid syntax to express the same idea.<br />\n",
    "PostedDate": "2013-09-26T10:05:07.723-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1102558",
    "ThreadId": "457222",
    "Html": "If you don't reference an imported module in a value position (i.e. only reference it for types) then it will get optimized away, and not imported at runtime.  Thus if you declared module foo in foo.ts such as the below<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">declare</span> <span style=\"color:Blue;\">module</span> <span style=\"color:#A31515;\">&quot;foo&quot;</span> {\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">var</span> x: <span style=\"color:Blue;\">number</span>;\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">function</span> y(a: <span style=\"color:Blue;\">string</span>): <span style=\"color:Blue;\">string</span>;\n} \r\n</pre></div>You could then reference the declaration, import the module, use it only in the type position to declare a variable of its type (via the typeof keyword), and the actual import at the top-level would get optimized away, e.g.<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">/// &lt;reference path=&#39;foo.ts&#39;/&gt;</span>\n\n<span style=\"color:Blue;\">import</span> footype = require(<span style=\"color:#A31515;\">&#39;foo&#39;</span>);\n\n<span style=\"color:Green;\">// later...</span>\n<span style=\"color:Blue;\">var</span> x: <span style=\"color:Blue;\">typeof</span> footype = require(<span style=\"color:#A31515;\">&#39;foo&#39;</span>);\nx.y; <span style=\"color:Green;\">// etc...</span>\r\n</pre></div>Note however that in many cases trying to defer load like this is an anti-pattern.  For module loaders such as RequireJS, it looks in the function for &quot;require&quot; calls (via toString) and still asynchronously loads the module as a dependency before entering the function (even if the 'require' call is in an &quot;if&quot; block that never runs).  For Node, the loading is synchronous, so it does happen on demand, however unless there are a lot of modules that probably won't be needed, I still err on the side of trying to load dependencies on startup, and avoid the latency of the disk fetch when it comes to performing the processing needs it.  But that's just me :-)<br />\n",
    "PostedDate": "2013-10-01T22:57:10.633-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1258363",
    "ThreadId": "457222",
    "Html": "This is how I'd done it (<a href=\"https://github.com/andraaspar/node-js-test):\" rel=\"nofollow\">https://github.com/andraaspar/node-js-test):</a>\r<br />\n<br />\n1) I've rewritten node.d.ts to remove the quotes from module names.<br />\n<pre><code>declare module &quot;http&quot; {...}</code></pre>\n\nbecame<br />\n<pre><code>declare module http {...}</code></pre>\n\n2) I've removed unnecessary imports from node.d.ts, like this one: <br />\n<pre><code>import events = require(&quot;events&quot;);</code></pre>\n\n3) I've captured a reference to the global object like this:<br />\n<pre><code>module illa {\n    export var GLOBAL = (function() {\n        return this;\n    })();\n}</code></pre>\n\n4) Written code like this (<a href=\"https://github.com/andraaspar/node-js-test/blob/v1/src/Main.ts):\" rel=\"nofollow\">https://github.com/andraaspar/node-js-test/blob/v1/src/Main.ts):</a><br />\n<pre><code>/// &lt;reference path='node.d.ts'/&gt;\n/// &lt;reference path='../lib/illa/Log.ts'/&gt;\n\nilla.GLOBAL.http = require('http');\n\nvar server = http.createServer(function(request, response) {\n    response.writeHead(200, {'Content-Type': 'text/plain; charset=utf-8'});\n    response.end('Árvíztűrő tükörfúrógép', 'utf-8');\n});\nserver.listen(8888);\n\nilla.Log.info('Yay!');</code></pre>\n\nThis can then be compiled into a single file (<a href=\"https://github.com/andraaspar/node-js-test/blob/v1/build/test.js\" rel=\"nofollow\">https://github.com/andraaspar/node-js-test/blob/v1/build/test.js</a>), and keeps type checking intact. The only thing you've gotta be careful about is requiring all node modules you use.<br />\n",
    "PostedDate": "2014-06-20T10:39:57.327-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]