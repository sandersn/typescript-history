[
  {
    "Id": "1065345",
    "ThreadId": "449258",
    "Html": "I was able to get a TypeScript class converted to an angular controller by calling the constructor on the passed in $scope. This lets you avoid having to create a separate interface to list all the fields you're going to assign to scope, and if you have a base class definition for angular's scope, you can get intellisense and type checking for fields/methods assigned by angular. But, I'm not sure if this method will work in the general case - with various class heirarchies, generics, etc. Does anyone see any reason why this wouldn't work for some particular scenario? warning, typing this on a phone and potentially mucking up the syntax:<br />\n<pre><code>class SimpleController {\npublic field: string;\nconstructor($http: any) { \nthis.field = &quot;hi&quot;;\n}\n}\n\nangular.module(&quot;app&quot;).controller(&quot;SimpleController&quot;, [&quot;$scope&quot;, &quot;$http&quot;, function($scope, $http) {\nvar args = Array.prototype.splice.call(arguments).splice(1);\nSimpleController.call($scope, args);\n}]);\n</code></pre>\n\n",
    "PostedDate": "2013-07-07T15:03:18.473-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1065697",
    "ThreadId": "449258",
    "Html": "Not quite sure I follow.  Are you saying you want a way of specifying only some of the interface without having to specify all of the member?\r<br />\n<br />\nIf so, one way you can do this is to access the members you want to use untyped using the x[&quot;member&quot;] syntax, which will assume 'any'.  <br />\n",
    "PostedDate": "2013-07-08T10:58:34.82-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1065873",
    "ThreadId": "449258",
    "Html": "Thanks, I wasn't aware that x[&quot;member&quot;] syntax assumes any, which is very helpful. In this case, however, my goal is to define angular controllers (which .Net developers would call view-models) as TypeScript classes. I think I need to provide a little bit of context. AngularJS supports data-binding that is somewhat MVVM-ish. Angular templates data-bind to fields and functions of the $scope. There may be child scopes of parent scopes, which prototypically inherit from a parent scope, or isolated scopes which do not inherit from a parent scope. <br />\n<br />\nThe $scope is the &quot;view-model&quot;, so to speak. $scopes are instantiated by Angular and injected into Angular Controllers, which are effectively just functions with the current $scope passed in as a method parameter. In my example above, the function with $scope and $http arguments is the controller. $scope is the view model. The controller's primary job is just to add fields and functionality to the view-model - which is why I use &quot;controller&quot; and &quot;view-model&quot; interchangeably. <br />\n<br />\nThe array definition ([&quot;$scope&quot;, &quot;$http&quot;, function($scope, $http) {...}] is part of Angular's dependency injection. It just tells angular to inject the current $scope and the $http service into the function. This makes it so you can minimize your code and still use dependency injection (because the $http and $scope argument names would presumably be shortened). <br />\n<br />\nMy goal is to define a TypeScript class to use as the view-model (on $scope) without casting $scope to any first. The problem is that Angular instantiates $scopes for you, and passes them in via dependency injection. They already may have their own prototypes representing the $scope hierarchy, up to the shared methods on all $scopes (such as the $watch function). It does this because it manages the $scope hierarchy based on directives/templates/etc.. in the markup. <br />\n<br />\nOne way I could do this is to just create a new instance of a TypeScript class and assign that instance to the $scope variable:<br />\n<pre><code>// controller.js\nangular.module(&quot;app&quot;).controller(&quot;SimpleController&quot;, [&quot;$scope&quot;, function($scope) {\n$scope.vm = new SimpleController();\n}]);\n\n// template.html\n&lt;span&gt;Value of SimpleController.field: {{vm.field}}&lt;/span&gt;</code></pre>\n\nBut this is somewhat cumbersome because, in the markup, I will need to prefix all the bindings with the name of the field (in this case &quot;vm&quot;). It's an acceptable workaround, but I wanted something slightly more integrated. Instead of assigning an instance of a class to the $scope variable, I wanted the class to BE the $scope. The only way I could think of to make this work is to call the constructor function explicitly, passing the $scope as &quot;this&quot; and the rest of the dependency injection arguments as arguments to the class constructor (in my example, just the $http service).<br />\n<br />\nBut I had doubts that this would work, so that's why I'm posting here. I'm especially concerned that TypeScript classes which already extend other classes might just break horribly if I tried to call the constructor explicitly on an object which already prototypically inherits from something else.<br />\n<br />\nEdit: I should probably give an example of what I'm trying to avoid by going this route. If you look at the DefinatelyTyped example for defining AngularJS controllers in typescript (<a href=\"https://github.com/borisyankov/DefinitelyTyped/tree/master/angularjs\" rel=\"nofollow\">https://github.com/borisyankov/DefinitelyTyped/tree/master/angularjs</a>), you see that they recommend defining an interface for everything you're going to assign on $scope, then assigning those things in the controller. The controller function looks like normal, except that you set the type of $scope to the interface you define (which extends ng.IScope). <br />\n<pre><code>interface ICustomScope extends ng.IScope {\n    title: string;\n}\n\nangular.module(&quot;app&quot;).controller(&quot;Controller&quot;, [&quot;$scope&quot;, function Controller($scope: ng.ICustomScope) {\n    $scope.$broadcast('myEvent');\n    $scope.title = 'Yabadabadu';\n}]);</code></pre>\n\nThis can be a real pain to work with, because every time you want to add a new function or field to the scope, you have to modify the interface (ICustomScope in this example). What I want to do instead is something like this:<br />\n<pre><code>function MergeClassIntoScope(theClass: any, scope: ng.IScope, args: any[]) {\n  // What do I do here?\n}\n\nclass Controller extends ng.IScope {\n    title: string = &quot;Yabadabadu&quot;;\n    constructor($http: ng.IHttp) {\n        this.$broadcast('myEvent');\n    }\n}\n\nangular.module(&quot;app&quot;).controller(&quot;Controller&quot;, [&quot;$scope&quot;, &quot;$http&quot;, function($scope: ng.IScope, $http: ng.IHttp) {\n    MergeClassIntoScope(Controller, $scope, [$http]);\n}]);</code></pre>\n\n",
    "PostedDate": "2013-07-08T17:47:41.403-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1066938",
    "ThreadId": "449258",
    "Html": "You may find this video useful. He defines controllers in typescript similar to your last implementation.  Assigning $scope.vm = this; \r<br />\n<br />\n<a href=\"http://www.youtube.com/watch?v=WdtVn_8K17E\" rel=\"nofollow\">http://www.youtube.com/watch?v=WdtVn_8K17E</a><br />\n",
    "PostedDate": "2013-07-11T02:06:48.303-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]