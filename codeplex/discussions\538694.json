[
  {
    "Id": "1221645",
    "ThreadId": "538694",
    "Html": "Dear TypeScript Team,\r<br />\n<br />\nI love TypeScript, and I've been using it daily since the 0.8 release. It has given my client-side programming experience a total makeover. Thank you for that.\r<br />\n<br />\nThe issue that I am bringing up today concerns function overloading, and I imagine you've heard this complaint before.\r<br />\n<br />\nPlease please please allow more permissive function and method overloading. There are times when designing an api where you need to have one method do multiple things. And these different uses do not use argment and return types that are assignable to each other.\r<br />\n<br />\nThis is a problem I run into all the time. Perhaps the simplest case I can think of is a function that could take a string or an int as a parameter:\r<br />\n<br />\nRight now, I would write this function like this:<br />\n<pre><code>module Module {\n    export function overloadedFunction(value: number);\n    export function overloadedFunction(value: string);\n\n    //For overload resolution only\n    export function overloadedFunction(value: any) {\n            //Do something with a string or a number\n    }\n}</code></pre>\n\nThe problem with this code is that no compiler error is issued if the caller changes the argument to a type other than a string or a number, which is clearly the behavior that the author intended. \r<br />\n<br />\nPlease allow one of these two solutions to be valid. I am truly begging you.<br />\n<pre><code>//Any set of method signatures are valid overloads\nmodule Module {\n    export function overloadedFunction(value: number);\n    export function overloadedFunction(value: string) {\n            //Do something with a string or a number\n    }\n}</code></pre>\n\nOr<br />\n<pre><code>//Functions and methods can have private overloads\nmodule Module {\n    export function overloadedFunction(value: number);\n    export function overloadedFunction(value: string);\n\n    //The overly permissive overload is declared as private\n    function overloadedFunction(value: any) {\n            //Do something with a string or a number\n    }\n}</code></pre>\n\nIn the first case, it is the callers responsibility to enforce the function/method signatures they have specified. I think this is perfectly reasonable.\r<br />\n<br />\nIn the second case, the overly permissive overload is declared either to not be exported, or to be private in the case of a method. Therefore the caller is exposed to it, and the compiler will enforce only the public overloads. \r<br />\n<br />\nWhile I would prefer the first case, the second seems like a much easier change for the existing compiler.\r<br />\n<br />\nOne argment that could be made against the second case is that the caller still has access to the method overload, whether they can see it or not. This is true. But users have access to private member variables, despite the fact that the TypeScript compiler won't allow it. This fact did not prevent the private member feature from being implemented. \r<br />\n<br />\nPlease consider these two alternatives. Overloading is a such an important feature, and the way it is currently implemented in TypeScript is far too restrictive to allow us developers to utilize it to its full potential.\r<br />\n<br />\nThank you for your consideration.\r<br />\n<br />\nSincerely,\r<br />\nDoug Rubino<br />\n",
    "PostedDate": "2014-03-11T16:17:30.187-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1222009",
    "ThreadId": "538694",
    "Html": "There is generally some confusion around overload lists and what they mean.  We actually already handle this as you suggest.  The overload list and the function declaration are distinct.  In this example, the function only has two overloads, not three:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">module</span> Module {\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">function</span> overloadedFunction(value: <span style=\"color:Blue;\">number</span>);\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">function</span> overloadedFunction(value: <span style=\"color:Blue;\">string</span>);\n\n    <span style=\"color:Green;\">//For overload resolution only</span>\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">function</span> overloadedFunction(value: <span style=\"color:Blue;\">any</span>) {\n            <span style=\"color:Green;\">//Do something with a string or a number</span>\n    }\n}\r\n</pre></div>You can see this in the intellisense.  The 'value: any' is actually part of the function declaration and does not change the overload set.  Instead, it only affects how we treat the parameter <em>inside</em> the function.  This is a way of letting the user describe the declaration that is, if you will, a union of all the overloads.<br />\n<br />\nYou can also see this by trying to call the function with the wrong type:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">module</span> Module {\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">function</span> overloadedFunction(value: <span style=\"color:Blue;\">number</span>);\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">function</span> overloadedFunction(value: <span style=\"color:Blue;\">string</span>);\n\n    <span style=\"color:Green;\">//For overload resolution only</span>\n    <span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">function</span> overloadedFunction(value: <span style=\"color:Blue;\">any</span>) {\n            <span style=\"color:Green;\">//Do something with a string or a number</span>\n    }\n}\n\nModule.overloadedFunction({x: 4});  <span style=\"color:Green;\">//&lt;-- error, supplied parameter does not match</span>\r\n</pre></div>In the above, I'm passing an object.  While this matches 'any', the 'any' isn't actually one of the overloads.  Instead, the object has to match one of either number or string, which it doesn't, and we throw an error.<br />\n",
    "PostedDate": "2014-03-12T11:13:18.49-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1222176",
    "ThreadId": "538694",
    "Html": "Thank you for the clarification!<br />\n",
    "PostedDate": "2014-03-12T18:55:42.09-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]