[
  {
    "Id": "1249080",
    "ThreadId": "546430",
    "Html": "<strong>Agenda</strong><br />\n<ul>\n<li>Overload ordering of globally-scoped functions</li>\n<li>Type argument inference candidate collection algorithm</li>\n<li>Overload resolution algorithm tweaks</li>\n<li>Legal alias merging</li>\n<li>Infinitely expanding types</li>\n<li>Losing accuracy during type inference</li>\n<li>\nProtected<br />\n</li>\n</ul>\n<strong>Overload ordering of globally-scoped functions</strong><br />\n<br />\nThe compiler seems to have a bug with how overloads of ambient functions are merged across functions.  In the example below:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">//A.ts</span>\n\ndeclare <span style=\"color:Blue;\">function</span> f(x: number);\n\n<span style=\"color:Green;\">// B.ts</span>\n\ndeclare <span style=\"color:Blue;\">function</span> f(x: string);\r\n</pre></div>If A.ts is sent to the compiler before B.ts, then the f(x: number) overload gets precedence, even though overloads in all other contexts are merged in reverse order to allow for plugin-style typing.<br />\n<br />\n<strong>Recommendation:</strong> fix the bug and merge in the correct order.  Would need to message that this is a minor design change to resolve the issue.<br />\n<br />\n<strong>Type argument inference candidate collection algorithm</strong><br />\n<br />\n<strong>Current behavior:</strong> During inferential typing of something with signatures for the purpose of generic type inference, we relate the N signatures of the target to the M signatures of the source in an NxM manner. However, only signatures with at least as many parameters as their targets are considered possible sources during this operation.<br />\n<br />\n<strong>Proposal:</strong> When making inferences between a two types, correlate the signatures in a 1:1 parallel fashion, starting with the last signatures first and proceeding backward until we run out of signatures. We suspect no arity checking is needed at this point. This seems to produce better results, and is faster.<br />\n<br />\n<strong>Concern:</strong> Disjoint overload sets lead to poor inference. Unclear how to solve that.<br />\n<strong>Concern:</strong> Doesn’t this possibly lead to inference of types that won’t be assignable to the actual calls?<br />\n<br />\n<strong>Recommendation:</strong> Need to experiment with an implementation of the proposal, and throw enough code at it we can understand any potential shortcomings.<br />\n<br />\n<strong>Overload resolution algorithm tweaks</strong><br />\n<br />\n<strong>Current behavior:</strong> “Provisional binding” occurs during overload resolution. Example: when a function expression with a contextually-typable signature is passed to an overloaded function, the compiler needs to “try” to apply each contextual type and see if it causes a failure, which is potentially very large and quadratic.<br />\n<br />\n<strong>Proposal:</strong> During overload resolution, first, look at all arguments that aren’t subject to contextual typing of function expressions. Apply overload resolution to these ‘primary’ arguments first, treating ‘secondary’ arguments as being universally compatible. At that point, apply the matching overload and push the contextual type into the secondary arguments and proceed.<br />\n<br />\nThis is based on the observation that functions cannot reasonably change their behavior based on the expectations of the body of a function expression.  If we do a first pass of the non-lambda components and then do lambda components, we can avoid having to rebind lambda types.<br />\n<br />\n<strong>Question:</strong> What is a contextually-typable argument? <br />\n<strong>Answer:</strong> It’s based on the lexical shape of the argument<br />\n<br />\n<strong>Question:</strong> What about non-function contextually-typable arguments? <br />\n<strong>Answer:</strong> Those are ‘primary’ because they are re-typable<br />\n<br />\nThis could potentially fix the typing of Array#reduce.<br />\n<br />\n<strong>Recommendation:</strong> Definitely sounds like potentially a positive change.  Will need to investigate impact.<br />\n<br />\n<strong>Legal alias merging</strong><br />\n<br />\n<strong>Current behavior:</strong> It was legal to ‘import’ two times as long as one was value-only and one was type-only.  This was not intended and could lead to confusing code.<br />\n<br />\n<strong>Proposal:</strong> Only one import into a lexical name is allowed.<br />\n<br />\nApplies to both internal and external module imports.<br />\n<br />\n<strong>Infinitely expanding types</strong><br />\n<br />\n<strong>Current behavior:</strong> Illegal and/or confusing.  When users get this error message, they may be getting it for perfectly valid types.<br />\n<br />\n<strong>Proposal:</strong> Detect structural comparison at depths &gt; 10 that are identical in the ‘stack’ of how we got there on both sides. When that stack is sufficiently deep and identical, assume it continues forever and presume that the relationship in question is true. As a thought - at depth &gt; 100, assume the compiler is going to crash and issue an error for diagnostics’ sake.<br />\n<br />\nThis may have false positives, but they are likely degenerate and coders would likely have difficulty in reasoning about them.<br />\n<br />\n<strong>Losing accuracy during type inference</strong><br />\n<br />\nGiven the example:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> forEach&lt;T, U&gt;(array: T[], func: (v: T) =&gt; U): U[] {\n    <span style=\"color:Blue;\">var</span> result: U[] = [];\n    <span style=\"color:Blue;\">for</span> (<span style=\"color:Blue;\">var</span> i = 0; i &lt; array.length; i++) {\n        result.push(func(array[i]));\n    }\n    <span style=\"color:Blue;\">return</span> result;\n}\n\n<span style=\"color:Blue;\">var</span> strings = [<span style=\"color:#A31515;\">&quot;foo&quot;</span>, <span style=\"color:#A31515;\">&quot;bar&quot;</span>];\n<span style=\"color:Blue;\">var</span> addOne = (v: number) =&gt; v + 1;&#160;\n\n<span style=\"color:Blue;\">var</span> result = forEach(strings, addOne);\r\n</pre></div>The problem in the above is that T gets inferred to both string and number, with the best common type being {}.  Once it goes to {}, we actually let the more specific 'number' type out of the return because U only has one candidate.  This allows a hole in typechecking.<br />\n<br />\nCovariance of function parameters allows { } to be a legitimate inference, so the user never gets the error.<br />\n<br />\n<strong>Recommendation:</strong> See what happens if we make BCT = {} an error during generic type inference<br />\n<br />\n<strong>Protected</strong><br />\n<br />\nWhat does 'protected' mean in a structural type system?  Protected in C# is closely related to the nominal subclassing.  Is there a way that this can be encoded into the structural type system we use?<br />\n<br />\nSome motivating examples:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">// Calling base class methods from derived when using fat arrow methods</span>\n<span style=\"color:Green;\">//&#160;https://typescript.codeplex.com/workitem/2491</span>\n&#160;\n<span style=\"color:Blue;\">class</span>&#160;Base&#160;{\n&#160;&#160;&#160;&#160;<span style=\"color:Green;\">//&#160;General&#160;handler</span>\n&#160;&#160;&#160;&#160;<span style=\"color:Green;\">//&#160;Desired&#160;visibility:&#160;protected</span>\n&#160;&#160;&#160;&#160;<span style=\"color:Blue;\">public</span>&#160;_doHandleEvent(e:&#160;MouseEvent)&#160;{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style=\"color:Green;\">//&#160;Do&#160;some&#160;stuff</span>\n&#160;&#160;&#160;&#160;}\n&#160;\n&#160;&#160;&#160;&#160;<span style=\"color:Green;\">//&#160;&#39;this&#39;-safe&#160;handler</span>\n&#160;&#160;&#160;&#160;<span style=\"color:Blue;\">public</span>&#160;handleMouseEvent&#160;=&#160;(e:&#160;MouseEvent)&#160;=&gt;&#160;<span style=\"color:Blue;\">this</span>._doHandleEvent(e);\n}\n&#160;\n<span style=\"color:Blue;\">class</span>&#160;Derived&#160;<span style=\"color:Blue;\">extends</span>&#160;Base&#160;{\n&#160;&#160;&#160;&#160;<span style=\"color:Blue;\">public</span>&#160;handleMouseEvent&#160;=&#160;(e:&#160;MouseEvent)&#160;=&gt;&#160;{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style=\"color:Blue;\">super</span>._doHandleEvent(e);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style=\"color:Green;\">//&#160;Do&#160;some&#160;other&#160;stuff</span>\n&#160;&#160;&#160;&#160;};\n}\r\n</pre></div><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">// Change logic for getters and setters</span>\n\n<span style=\"color:Blue;\">class</span> Base {\n    <span style=\"color:Blue;\">private</span> _x: string;\n \n    <span style=\"color:Green;\">// Intended public surface area</span>\n    <span style=\"color:Blue;\">public</span> get x() {\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>._x;\n    }\n    <span style=\"color:Blue;\">public</span> set x(newX) {\n        <span style=\"color:Blue;\">this</span>.changeX(newX);\n    }\n \n    <span style=\"color:Green;\">// Desired visbility: protected</span>\n    <span style=\"color:Blue;\">public</span> _changeX(x: string) {\n        <span style=\"color:Green;\">// Perform change notification, etc.</span>\n        <span style=\"color:Green;\">/*...*/</span>\n        <span style=\"color:Blue;\">this</span>._x = x;\n    }\n}\n \n<span style=\"color:Blue;\">class</span> Derived <span style=\"color:Blue;\">extends</span> Base {\n    <span style=\"color:Blue;\">public</span> _changeX(x: string) {\n        <span style=\"color:Green;\">// Perform additional recalculation</span>\n        <span style=\"color:Green;\">/*...*/</span>\n        <span style=\"color:Blue;\">super</span>._changeX(x);\n    }\n}\r\n</pre></div> <br />\nAny design would need to allow for overriding of the inherited protected members.  We already detect the presence of disallowed names, which we use to prevent shadowing private members.<br />\n<br />\n<strong>Recommendation:</strong> We need to work a proposal that captures the intent of protected and works for the examples given while retaining the structural flavor of the type system.<br />\n",
    "PostedDate": "2014-05-23T15:08:38.3-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1249203",
    "ThreadId": "546430",
    "Html": "As ever, thanks for sharing these notes. Really good to see.<br />\n",
    "PostedDate": "2014-05-24T08:39:21.547-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1249300",
    "ThreadId": "546430",
    "Html": "For <code>protected</code>, since anyway <code>private</code> already influences the implementation of subclass and prevents the usage of  some names, why not just relaxing the rules on the <code>private</code> namespace to allow subclass to access/override <code>private</code> members ? There is no way at runtime to prevent those members from being accessed and this change would better reflect what really happens and at least it would be more clear that we have to care about <code>private</code> members when subclassing.<br />\n",
    "PostedDate": "2014-05-25T02:36:48.203-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1250174",
    "ThreadId": "546430",
    "Html": "<strong>fdecampredon wrote:</strong><br />\n<blockquote>\nFor <code>protected</code>, since anyway <code>private</code> already influences the implementation of subclass and prevents the usage of  some names, why not just relaxing the rules on the <code>private</code> namespace to allow subclass to access/override <code>private</code> members ? There is no way at runtime to prevent those members from being accessed and this change would better reflect what really happens and at least it would be more clear that we have to care about <code>private</code> members when subclassing.<br />\n</blockquote>\nWhy would you want to turn <code>private</code> into something other than what people expect rather than just adding the <code>protected</code> modifier? \r<br />\n<br />\n@jonturner Are there any examples of how <code>protected</code> causes problems with the structural type system? The examples provided are essentially &quot;this is why people want protected&quot;, which is fine, but doesn't really seem like much of a design challenge as it's essentially the same story for any language that offers something similar (including C# and VB).\r<br />\n<br />\nAlso, Ryan Cavanaugh mentioned in the last language notes thread that you guys had whiteboarded some ideas for union types. I may be wrong, but it sounds like the &quot;Type argument inference candidate collection algorithm&quot; and &quot;Overload resolution algorithm tweaks&quot; are steps towards solving some of the problems that might come up there. Any more color on that topic?<br />\n",
    "PostedDate": "2014-05-27T12:23:30.8-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1250191",
    "ThreadId": "546430",
    "Html": "IMHO, the whole point of public, private, and protected is to help promote intended usage, which I think stands in the spirit of TypeScript.  Also, I would take it a step further and say the other modifiers, such as &quot;abstract&quot;, &quot;virtual&quot;, &quot;override&quot;, or &quot;new&quot; for methods,  also simply goes toward this same goal.<br />\n<em>(why &quot;new&quot;? because I have many times wanted to completely replace a method signature, which is valid JS)</em><br />\n",
    "PostedDate": "2014-05-27T12:57:01.107-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1250202",
    "ThreadId": "546430",
    "Html": "@MgSam/@fdecampredon<br />\n<br />\nThis came towards the end of the meeting, so I wouldn't say the notes reflect the ultimate thoughts here. Instead, they are just the beginning of the thoughts of the topic.<br />\n<br />\nThe thought here was that traditional 'protected' infer something about the nominal subclass hierarchy.  The classes below you in the hierarchy get a different view of visibility that those that reach you from outside this hierarchy (even if through a handle to an instance of a class that otherwise you have access to):<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> Base {\n    <span style=\"color:Blue;\">protected</span> foo(): <span style=\"color:Blue;\">number</span>;\n}\n\n<span style=\"color:Blue;\">class</span> Derived <span style=\"color:Blue;\">extends</span> Base {\n    <span style=\"color:Blue;\">constructor</span>() {\n        <span style=\"color:Blue;\">var</span> b = <span style=\"color:Blue;\">new</span> Base();\n        b.foo(); <span style=\"color:Green;\">// error</span>\n        <span style=\"color:Blue;\">this</span>.foo(); <span style=\"color:Green;\">// no error</span>\n    }\n}\r\n</pre></div>In a more structural type system, it's not immediately obvious what the type of Base is that would error and not error appropriately (assuming a C#-like version of protected).  One possible solution would be to type the 'this' pointer differently than just being that derived class just get a copy of the members they derive from.<br />\n<br />\nWe do some of this checking to prevent shadowing privates now, and for the above to work, we'd need to extend that.<br />\n<br />\nThe solution <em>may</em> be that we just work very similar to private.<br />\n<br />\nPerhaps a conversation for another thread, but in some sense this opens a bit of Pandora's box.  Would we want to support internal, or protected+internal or any lesser used hybrids.  Especially considering that in practice these are just design time constraints that evaporate when compiled, moving the developer further away from JavaScript.  I'm sure there are both camps of developers who want to be abstracted away from JS and those who don't, and TypeScript has to balance between those worlds.<br />\n<br />\n@MgSam - Good question about the union types and simplifying the type system around candidates and overload resolution.  It's possible they might affect each other, but we haven't gone back to talk about union types, yet.  Would be interesting if that does make things easier.<br />\n",
    "PostedDate": "2014-05-27T13:24:26.527-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1250268",
    "ThreadId": "546430",
    "Html": "Interesting, thanks. I'll admit I had to double check what C# does in the scenario you outlined since it <em>does</em> allow you to access private members in that sort of situation. I'd vote for keeping the behavior similar to what C# does, as a big chunk of TypeScript's users come from C# or are at least familiar with it.\r<br />\n<br />\nI think <code>internal</code> is certainly interesting as well. I personally like internal and/or protected type modifiers, but given the veritable <a href=\"https://roslyn.codeplex.com/discussions/541194\" rel=\"nofollow\">war</a> in the Roslyn forums over &quot;protected and internal&quot;, I imagine Anders, et al don't want to think about that again any time soon. If you guys do <code>protected</code> I hope you consider <code>internal</code> at the same time as well as I'd personally use <code>internal</code> more than I do <code>protected</code>.\r<br />\n<br />\nThanks for posting these!<br />\n",
    "PostedDate": "2014-05-27T19:03:05.107-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1250806",
    "ThreadId": "546430",
    "Html": "<strong>MgSam wrote:</strong><br />\n<blockquote>\n<strong>fdecampredon wrote:</strong><br />\n<blockquote>\nFor <code>protected</code>, since anyway <code>private</code> already influences the implementation of subclass and prevents the usage of  some names, why not just relaxing the rules on the <code>private</code> namespace to allow subclass to access/override <code>private</code> members ? There is no way at runtime to prevent those members from being accessed and this change would better reflect what really happens and at least it would be more clear that we have to care about <code>private</code> members when subclassing.<br />\n</blockquote>\nWhy would you want to turn <code>private</code> into something other than what people expect rather than just adding the <code>protected</code> modifier? <br />\n</blockquote>\nIn any other language <code>private</code> members are not a part of the class signatures, they are completely hidden from subclass and external code.\r<br />\n<code>protected</code> members however are always a part of the signature in any language, they are just inaccessible from the outside.\r<br />\n<br />\nSince with typescript <code>private</code> members are part of the signatures, I already feels like they behave halfway as <code>protected</code> one, so in my opinion, completely transforming them into <code>protected</code> would only be natural.<br />\n",
    "PostedDate": "2014-05-29T04:22:11.523-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]