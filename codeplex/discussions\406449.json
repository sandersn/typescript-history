[
  {
    "Id": "954775",
    "ThreadId": "406449",
    "Html": "\r\n<p>Hi,</p>\r\n<p>We'd like to see support for mixins in TypeScript (as also requested by a few others). Taking an\r\n<a href=\"http://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/\">\r\nexample from the web</a>, here is a working implementation that should be consistent with TypeScript principles (properties on the instance, methods on the prototype):</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:green\">// Compiler generated function for copying methods or properties</span>\n<span style=\"color:green\">// from source to destination</span>\n<span style=\"color:blue\">function</span> extend(destination, source, copyMethodsOnly?) {\n    <span style=\"color:blue\">for</span> (<span style=\"color:blue\">var</span> name <span style=\"color:blue\">in</span> source) {\n        <span style=\"color:blue\">if</span> (!destination.hasOwnProperty(name)) {\n            <span style=\"color:blue\">if</span> (copyMethodsOnly) {\n                <span style=\"color:blue\">if</span> (<span style=\"color:blue\">typeof</span> source[name] === <span style=\"color:#a31515\">&quot;function&quot;</span>) {\n                    destination[name] = source[name];\n                }\n            }\n            <span style=\"color:blue\">else</span> {\n                <span style=\"color:blue\">if</span> (<span style=\"color:blue\">typeof</span> source[name] !== <span style=\"color:#a31515\">&quot;function&quot;</span>) {\n                    destination[name] = source[name];\n                }\n            }\n        }\n    }\n}\n\n<span style=\"color:green\">// An interface that we would like to implement partially</span>\n<span style=\"color:blue\">interface</span> IRectangle {\n    area(): string;\n    grow(): <span style=\"color:blue\">void</span>;\n}\n\n<span style=\"color:green\">// The mixin type</span>\n<span style=\"color:blue\">class</span> Rectangle <span style=\"color:blue\">implements</span> IRectangle {\n\n    <span style=\"color:blue\">public</span> height: number;\n    <span style=\"color:blue\">public</span> width: number;\n\n    constructor(<span style=\"color:blue\">private</span> label: string) {\n    }\n\n    <span style=\"color:blue\">public</span> area() {\n        <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>.label &#43; (<span style=\"color:blue\">this</span>.height * <span style=\"color:blue\">this</span>.width);\n    }\n\n    <span style=\"color:blue\">public</span> grow() {\n        <span style=\"color:blue\">this</span>.height&#43;&#43;; <span style=\"color:blue\">this</span>.width&#43;&#43;;\n    }\n}\n\n<span style=\"color:green\">// The sample type demonstrating usage of the mixin</span>\n<span style=\"color:green\">// Block comments denote working code, and should be removed once the &quot;mixin&quot; keyword has been introduced</span>\n<span style=\"color:blue\">class</span> FixedHeightRect <span style=\"color:green\">/*implements IRectangle*/</span> {\n\n    <span style=\"color:green\">// Declare the mixin using the keyword</span>\n    <span style=\"color:blue\">private</span> <span style=\"color:green\">/*mixin*/</span> rectangle = <span style=\"color:blue\">new</span> Rectangle(label);\n\n    constructor(label: string, <span style=\"color:blue\">private</span> width: number, defaultHeight: number = 5) {\n\n        <span style=\"color:green\">// Compiler generated function call for copying properties from the mixin to the sample instance</span>\n        <span style=\"color:green\">// We shouldn't need to write this line of code</span>\n        extend(<span style=\"color:blue\">this</span>, <span style=\"color:blue\">new</span> Rectangle(label)); <span style=\"color:green\">// Mixin type permits constructor arguments</span>\n\n        <span style=\"color:blue\">this</span>[<span style=\"color:#a31515\">&quot;height&quot;</span>] = defaultHeight; <span style=\"color:green\">// We won't write this, rather we will write the next line</span>\n        <span style=\"color:green\">/* this.rectangle.height = defaultHeight; */</span> <span style=\"color:green\">// The compiler replaces all references to &quot;this.rectangle&quot; with &quot;this&quot;</span>\n    }\n\n    <span style=\"color:green\">// Permit overriding of a mixin method</span>\n    <span style=\"color:blue\">public</span> grow() {\n        <span style=\"color:blue\">this</span>.width&#43;&#43;;\n    }\n}\n\n<span style=\"color:green\">// Compiler generated, one-off function call for copying methods from the mixin prototype to the sample prototype;</span>\n<span style=\"color:green\">// We shouldn't need to write this line of code</span>\nextend(FixedHeightRect.prototype, Rectangle.prototype, <span style=\"color:blue\">true</span>);\n\n\n<span style=\"color:green\">// Sample usage</span>\n<span style=\"color:blue\">var</span> rect = <span style=\"color:blue\">new</span> FixedHeightRect(<span style=\"color:#a31515\">&quot;Area = &quot;</span>, 10);\nrect.grow(); <span style=\"color:green\">// Use the overridden grow; the height will not change</span>\n<span style=\"color:blue\">var</span> area = rect[<span style=\"color:#a31515\">&quot;area&quot;</span>](); <span style=\"color:green\">// Use the mixin function</span>\n\nalert(area); <span style=\"color:green\">// Alerts &quot;Area = 55&quot;</span>\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>-----------------------------------------------------------------------------------------------------------</p>\r\n<p>&nbsp;</p>\r\n<p>Hopefully the comments are clear enough. Basically, we would like the type FixedHeightRect implement the IRectangle interface, but do so by only implementing a subset of the interface, while mixing-in the default implementation from Rectangle.</p>\r\n<p>Clearly we could have FixedHeightRect inherit from Rectangle, but I'd like to avoid steering the discussion into the inheritance versus composition debate, but rather consider the benefits of having mixins supported natively by the language.</p>\r\n<p>The code above should work in its present form. The suggestion is that TypeScript permit the rectangle property to be declared with the &quot;mixin&quot; keyword (or something similar) &nbsp;that would magically endow the FixedHeightRect with the properties and methods\r\n of Rectangle.</p>\r\n<p>Any thoughts?</p>\r\n<p>Thanks</p>\r\n<p>PS: The extend would need to recurse up the prototype chain - omitted for clarity.</p>\r\n",
    "PostedDate": "2012-12-11T13:11:34.06-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "955739",
    "ThreadId": "406449",
    "Html": "\r\n<p>Thanks for taking the time to put your idea down.</p>\r\n<p>We've seen some thoughts on the forums around mixins, and I agree they could be very handy in cases like you've described.&nbsp; For the near future, we'll likely focus on just getting a 1.0 out the door, and that's largely going to be trying to make it easier\r\n to use and type JavaScript as well as align with ES6 as the standard is completed.&nbsp; After 1.0, we'll likely then start looking at features, like mixins, that really help the language be&nbsp;richer and&nbsp;more expressive.</p>\r\n",
    "PostedDate": "2012-12-13T11:35:09.48-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "955805",
    "ThreadId": "406449",
    "Html": "\r\n<p>nabog, while your example does work you have an issue currently that you won't get any intelisense for&nbsp;your mixed in methods.&nbsp; With a slight change to your mixin interface you can fix this:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><div style=\"color:black; background-color:white\"><pre><span style=\"color:green\">// Compiler generated function for copying methods or properties</span>\r\n<span style=\"color:green\">// from source to destination</span>\r\n<span style=\"color:blue\">function</span> extend(destination, source, copyMethodsOnly?) {\r\n    <span style=\"color:blue\">for</span> (<span style=\"color:blue\">var</span> name <span style=\"color:blue\">in</span> source) {\r\n        <span style=\"color:blue\">if</span> (!destination.hasOwnProperty(name)) {\r\n            <span style=\"color:blue\">if</span> (copyMethodsOnly) {\r\n                <span style=\"color:blue\">if</span> (<span style=\"color:blue\">typeof</span> source[name] === <span style=\"color:#a31515\">&quot;function&quot;</span>) {\r\n                    destination[name] = source[name];\r\n                }\r\n            }\r\n            <span style=\"color:blue\">else</span> {\r\n                <span style=\"color:blue\">if</span> (<span style=\"color:blue\">typeof</span> source[name] !== <span style=\"color:#a31515\">&quot;function&quot;</span>) {\r\n                    destination[name] = source[name];\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n<span style=\"color:green\">// An interface that we would like to implement partially</span>\r\n<span style=\"color:blue\">interface</span> IRectangle {\r\n    area: () =&gt; string;\r\n    grow: () =&gt; <span style=\"color:blue\">void</span>;\r\n}\r\n\r\n<span style=\"color:green\">// The mixin type</span>\r\n<span style=\"color:blue\">class</span> Rectangle <span style=\"color:blue\">implements</span> IRectangle {\r\n\r\n    <span style=\"color:blue\">public</span> height: number;\r\n    <span style=\"color:blue\">public</span> width: number;\r\n\r\n    constructor(<span style=\"color:blue\">private</span> label: string) {\r\n    }\r\n\r\n    <span style=\"color:blue\">public</span> area() {\r\n        <span style=\"color:blue\">return</span> <span style=\"color:blue\">this</span>.label &#43; (<span style=\"color:blue\">this</span>.height * <span style=\"color:blue\">this</span>.width);\r\n    }\r\n\r\n    <span style=\"color:blue\">public</span> grow() {\r\n        <span style=\"color:blue\">this</span>.height&#43;&#43;; <span style=\"color:blue\">this</span>.width&#43;&#43;;\r\n    }\r\n}\r\n\r\n<span style=\"color:green\">// The sample type demonstrating usage of the mixin</span>\r\n<span style=\"color:green\">// Block comments denote working code, and should be removed once the &quot;mixin&quot; keyword has been introduced</span>\r\n<span style=\"color:blue\">class</span> FixedHeightRect <span style=\"color:blue\">implements</span> IRectangle {\r\n\r\n\t<span style=\"color:green\">// Property implemented by mixin</span>\r\n\t<span style=\"color:blue\">private</span> height;\r\n\t\r\n    constructor(label: string, <span style=\"color:blue\">private</span> width: number, defaultHeight: number = 5) {\r\n\r\n        <span style=\"color:green\">// Compiler generated function call for copying properties from the mixin to the sample instance</span>\r\n        <span style=\"color:green\">// We shouldn't need to write this line of code</span>\r\n        extend(<span style=\"color:blue\">this</span>, <span style=\"color:blue\">new</span> Rectangle(label)); <span style=\"color:green\">// Mixin type permits constructor arguments</span>\r\n\r\n        <span style=\"color:blue\">this</span>.height = defaultHeight; <span style=\"color:green\">// We won't write this, rather we will write the next line</span>\r\n        <span style=\"color:green\">/* this.rectangle.height = defaultHeight; */</span> <span style=\"color:green\">// The compiler replaces all references to &quot;this.rectangle&quot; with &quot;this&quot;</span>\r\n    }\r\n\r\n\t<span style=\"color:green\">// IRectange members</span>\r\n    <span style=\"color:blue\">public</span> area: () =&gt; string;\r\n    <span style=\"color:blue\">public</span> grow() {\r\n        <span style=\"color:blue\">this</span>.width&#43;&#43;;\r\n    }\r\n}\r\n\r\n<span style=\"color:green\">// Compiler generated, one-off function call for copying methods from the mixin prototype to the sample prototype;</span>\r\n<span style=\"color:green\">// We shouldn't need to write this line of code</span>\r\nextend(FixedHeightRect.prototype, Rectangle.prototype, <span style=\"color:blue\">true</span>);\r\n\r\n\r\n<span style=\"color:green\">// Sample usage</span>\r\n<span style=\"color:blue\">var</span> rect = <span style=\"color:blue\">new</span> FixedHeightRect(<span style=\"color:#a31515\">&quot;Area = &quot;</span>, 10);\r\nrect.grow(); <span style=\"color:green\">// Use the overridden grow; the height will not change</span>\r\n<span style=\"color:blue\">var</span> area = rect.area(); <span style=\"color:green\">// Use the mixin function</span>\r\n\r\nalert(area); <span style=\"color:green\">// Alerts &quot;Area = 55&quot;</span>\r\n\r\n</pre>\n</div>\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;If you change your mixin defined methods to be properties instead of functions you can then say that you FixedHeightRect class implements IRectangle so you'll get intelisense for these methods.&nbsp; While it's true that you then need to say your class\r\n has all of these properties, you only need to give an implementation for the ones you want to override.&nbsp;</p>\r\n",
    "PostedDate": "2012-12-13T13:54:12.257-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "956230",
    "ThreadId": "406449",
    "Html": "\r\n<p>@jonturner,</p>\r\n<p>I'm glad you agree this will be a handy feature. No need to thank me for putting ideas down: the fact is it is TypeScript that has made these ideas possible. The overlaying of a type system over the inherently dynamic JavaScript language suggests many interesting\r\n possibilities.</p>\r\n<p>&nbsp;</p>\r\n<p>@ickman,</p>\r\n<p>Yes, that is a useful interim solution. However, that is actually also the feature that I'm suggesting. That the TypeScript compiler add the properties and methods on your behalf, so that you can explicitly declare the IRectangle interface on the FixedHeightRect\r\n type, leading to resolution of statements such as &quot;var area = rect.area();&quot;, without the need for the bracket syntax.</p>\r\n<p>The problem with declaring the properties and methods yourself is that it creates rather a significant maintenance problem. Imagine that five different types implement IRectangle. Now suppose we want to add a new method to the interface, say, &quot;changeColour(colour:\r\n string)&quot;. Clearly this will break all five types and Rectangle as well. If on the other hand the compiler does the work for you, then all you have to do is implement the new method on Rectangle, and hey presto!</p>\r\n<p>Noel</p>\r\n",
    "PostedDate": "2012-12-14T10:49:02.527-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]