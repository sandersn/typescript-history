[
  {
    "Id": "1091850",
    "ThreadId": "456717",
    "Html": "An objective of TypeScript that I enjoy, is that it retains JavaScript language semantics as closely as possible - but it seems like classes veer from this principle a bit.\r<br />\n<br />\nI don't know if my computer theory language is strong enough to actually explain this in the right terms, so please bear with me, and feel free to correct my language if you feel it helps clarify what I'm trying to get across.\r<br />\n<br />\nIn JavaScript, &quot;class declarations&quot; are not interpreted at &quot;compile-time&quot; - they are actually code that executes at run-time, as illustrated by a simple example:<br />\n<pre><code>module foo {\n    class Bar\n    {\n        public run() {\n            // ...\n        }\n    }\n}\n</code></pre>\n\nWhich compiles into:<br />\n<pre><code>var foo;\n(function (foo) {\n    var Bar = (function () {\n        function Bar() {\n        }\n        Bar.prototype.run = function () {\n            // ...\n        };\n        return Bar;\n    })();\n})(foo || (foo = {}));\n</code></pre>\n\nIn JavaScript, the symbol <code>Bar</code> is defined first - and then <code>run()</code> method is defined independently, after the declaration of <code>Bar</code>. The class <code>Bar</code> which has the method <code>run()</code> is not one closed unit that is identified and defined at compile-time, it is defined step by step, at run-time.\r<br />\n<br />\nThis appears not be true of TypeScript, where apparently the class <code>Bar</code> with the method <code>run()</code> is a single unit that gets identified and defined at compile-time.\r<br />\n<br />\nIn JavaScript, if I wanted, I could write the following:<br />\n<pre><code>var foo;\n(function (foo) {\n    var Bar = (function () {\n        // I can do things here!\n        var a = [1,2,3];\n        for (var i=0; i&lt;a.length; i++) {\n            // ...\n        }       \n        function Bar() {\n        }\n        Bar.prototype.run = function () {\n            // ...\n        };\n        return Bar;\n    })();\n})(foo || (foo = {}));\n</code></pre>\n\nSeveral things happen inside the anonymous closure that produces the <code>Bar</code> prototype, but they don't occur as one &quot;thing&quot; that exists independently or at &quot;compile-time&quot;, because that's not how JavaScript works - it's prototypical, and things actually build up and get defined one method/property at a time. It's actively &quot;doing something&quot; when the code loads.\r<br />\n<br />\nThis appears not to be the case in TypeScript, where the following is not possible:<br />\n<pre><code>module foo {\n    class Bar\n    {\n        var a = [1,2,3];\n\n        for (var i=0; i&lt;a.length; i++) {\n            // ...\n        }\n\n        public run() {\n            // ...\n        }\n    }\n}\n</code></pre>\n\nWhy not?\r<br />\n<br />\nI realize the compiled JavaScript of course does build out prototypes at run-time, and obviously it has to, since that's how JavaScript works.\r<br />\n<br />\nBut it appears as though TypeScript class definitions are different, in the sense that they are defined and interpreted &quot;statically&quot;, or &quot;as a whole&quot;...\r<br />\n<br />\nIf this is true, it seems like a pretty radical departure from JavaScript semantics, and in a sense, it changes the nature of the language entirely - from being more like JavaScript or Ruby, where every class-definition is <em>code</em> that actually <em>executes</em>, towards something like PHP, where a class-definition is something that gets loaded and compiled statically, ahead of actually executing any of the code in the file.\r<br />\n<br />\nTo give a valid PHP example:<br />\n<pre><code>&lt;?php\n\n$foo = new Foo();\n\nclass Foo\n{\n}\n</code></pre>\n\nAnd a corresponding <em>valid</em> TypeScript example which will fail <em>at run-time</em>:<br />\n<pre><code>var foo = new Foo();\n\nclass Foo\n{\n}\n</code></pre>\n\nWhich produces the corresponding JavaScript:<br />\n<pre><code>var foo = new Foo();\n\nvar Foo = (function () {\n    function Foo() {\n    }\n    return Foo;\n})();\n</code></pre>\n\nThis of course fails at run-time in JavaScript, but the code is valid JavaScript, and the TypeScript code, consistently, is also valid, but will fail at run-time. So far so good.\r<br />\n<br />\nSource order matters in JavaScript, where class-definitions must actually execute before the classes are created, at run-time.\r<br />\n<br />\nI'm sure I'm missing something totally obvious, but: Why doesn't TypeScript take the full consequence of this important semantic aspect of JavaScript, and treat a class-definition, and it's member-definitions, as individual statements like any other statements?<br />\n",
    "PostedDate": "2013-09-12T11:09:44.277-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1091919",
    "ThreadId": "456717",
    "Html": "It seems to me that what you want is basically static constructors akin to what C# has <a href=\"http://msdn.microsoft.com/en-us/library/k9x6w0hc.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/k9x6w0hc.aspx</a> Then it would be fairly simple to represent this pattern (you could do something similar now but it would require manually tracking how many times a particular class has been instantiated). <br />\n",
    "PostedDate": "2013-09-12T14:21:34.503-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1092040",
    "ThreadId": "456717",
    "Html": "Static constructors in C# execute on load - in JavaScript, <em>everything</em> executes on load, so not having class-constructors (code that runs on load) isn't even really an option.\r<br />\n<br />\nThat's where I think TS class semantics detour from JS semantics - the class and member constructs are co-dependent in TS, whereas in JS, &quot;classes&quot; (prototypes) are created independently of any members created and added to them subsequently.\r<br />\n<br />\nSo the difference in language semantics in TS kind of take away this one dynamic aspect of JS - for better or worse, but there is definitely a difference, right?<br />\n",
    "PostedDate": "2013-09-12T18:06:15.337-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]