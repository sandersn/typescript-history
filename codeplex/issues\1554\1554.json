{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "Closing this as this is not a bug, but a discussion much better served by the discussion forum.\n\nWe'll take your request for auto-implementing interfaces in d.ts files into consideration for a future version.",
    "ClosedDate": "2013-08-23T10:43:22.163-07:00",
    "CommentCount": 11,
    "Custom": null,
    "Description": "how can you export a module that's a generic class? I'd think something like this might work:\r\n```\r\ndeclare module 'someModule' {\r\n    module someModule {\r\n        interface GenClass<T> {\r\n            prop:T;\r\n        }\r\n        interface GenClassStatic<T> {\r\n            ():GenClass<T>;\r\n            new():GenClass<T>;\r\n        }\r\n    }\r\n\r\n    // this wont work :(, since we need a type for the generic arg;\r\n    // var someModule:GenClassStatic<???>;\r\n\r\n    export = GenClassStatic;\r\n}\r\n```\r\n\r\nsome other file:\r\n```\r\nimport someModule = require('someModule');\r\n// compile error TS2088: Cannot invoke an expression whose type lacks a call signature\r\nvar x = new someModule<string>();\r\n```\r\n\r\nIs there a way to ```declare module \"someModule\"``` that is a generic class?",
    "LastUpdatedDate": "2013-08-27T09:47:57.417-07:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Unassigned",
      "Severity": 0,
      "Id": 0
    },
    "ProjectName": "typescript",
    "ReportedDate": "2013-08-22T00:30:27.907-07:00",
    "Status": {
      "Name": "Closed",
      "Id": 4
    },
    "ReasonClosed": {
      "Name": "By Design"
    },
    "Summary": "TS 0.9.1 - How to declare a module that's a generic class that implements an imported interface?",
    "Type": {
      "Name": "Unassigned",
      "Id": 5
    },
    "VoteCount": 1,
    "Id": 1554
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "You can simply export= a generic class declared within the module.  Unless I am misunderstanding the question, the below should work.\n\n```typescript\ndeclare module 'someGenClass' {\n    class Foo<T> {\n        static someStatic: string;\n        someMember: T;\n    }\n\n    export = Foo;\n}\n\nimport mod = require('someGenClass');\nvar i = new mod<Date>();\ni.someMember; // type is Date\n```\n\nNote that the name you give the class is irrelevant.  It is just an identifier used to indicate the module value on the 'export =' assignment.\n\nPlease reopen the issue if I've misunderstood.",
      "PostedDate": "2013-08-22T09:53:23.507-07:00",
      "Id": 110752
    },
    {
      "Message": "Hi Bill. I was trying to simplify the problem. The issue is that the class I want to export implements an external interface (the interface is being imported), which itself inherits from other interfaces; I was trying to avoid when declaring the class having to redeclare the signatures of all its inherited interfaces. A better representation of the problem is:\n\n```\n// this is imported, but put inline here for simplicity\ninterface IExternal {\n    externMethod():void;\n}\ndeclare module 'myModule' {\n    module myModule {\n        export interface IMyClass<T> extends IExternal {\n            myMethod():T;\n        }\n        export interface IMyClassStatic<T> {\n            new():IMyClass<T>;\n        }\n    }\n\n    // can't do this because IMyClassStatic needs generic type arg, but the\n    // importer of this module needs to pass the type arg as part of new statement\n    var myModule:IMyClassStatic;\n\n    // don't want to do this because then I have to redeclare signatures of all\n    // inherited interfaces\n    class myModule<T> implements IMyClass<T> {\n        // uhg, have to redeclare signature of IMyClass and its inherited members\n    }\n    export = myModule;\n}\n```",
      "PostedDate": "2013-08-22T10:53:56.927-07:00",
      "Id": 110766
    },
    {
      "Message": "\n\r\n\r** Closed by billti 08/22/2013 9:53AM",
      "PostedDate": "2013-08-22T09:53:32.29-07:00",
      "Id": 110767
    },
    {
      "Message": "Uhg I wish we could edit comments. In prior comment:\r\n```\r\nvar myModule:IMyClassStatic;\r\n\r\nclass myModule<T> implements IMyClass<T> {\r\n```\r\nshould have been\r\n```\r\nvar myModule:myModule.IMyClassStatic;\r\n\r\nclass myModule<T> implements myModule.IMyClass<T> {\r\n```\r\n\r\nObviously both wouldn't be there (and compiling will produce errors), but I put both declarations in there so you could better understand the problem.\r\n",
      "PostedDate": "2013-08-22T10:59:09.49-07:00",
      "Id": 110770
    },
    {
      "Message": "Frankly, I don't understand when DECLARING a class in a .d.ts file that implements an interface, why the signature of that interface must be redeclared. In other words, in a .d.ts declared class, why does this throw a compiler error?\n\n```\ndeclare module mod {\n    export interface IInterface {\n        bunchOfMethods():void;\n    }\n\n    // this throws error TS2137: Class mod.MyClass declares interface\n    // mod.IInterface but does not implement it: Type 'mod.MyClass' is \n    // missing property 'bunchOfMethods' from type 'mod.IInterface'\n    //\n    // Why the compile error? this isn't a class implementation, just a \n    // class declaration but compiler error says '..but does not implement it'.\n    // can't the compiler understand 'implement IInteface' means that\n    // the class implements the signature somewhere else? If I don't\n    // redeclare all the interface's method signatures here I get the compile \n    // error, so whats the purpose of having to redeclare all the signatures?\n    // what am I conceptually missing here?\n    export class MyClass implements IInterface {\n        constructor();\n        myClassMethods():void;\n    }\n}\n```",
      "PostedDate": "2013-08-22T11:17:24.283-07:00",
      "Id": 110774
    },
    {
      "Message": "To your last question about .d.ts files: implementing an interface is merely claiming to the compiler that you implement a contract, then you have to actually implement it. When extending a class there is actually a concrete implementation to inherit from automatically. Consider that your MyClass could implement bunchOfMethods with a different return type and this would satisfy the constraint imposed by implementing the interface. \n\nTo your generics question: I don't think the code you have is really doing what you think. You're attempting to export an instance of an open generic type. That's not even a new-able thing, even if open generics were available. I think you mean to want to export= IMyClass. That said, it's also not clear from your example why you want to use export= at all rather than just exporting all those elements which you want available. Generally export= is only necessary when you're actually merging declarations to create a single identifier with multiple meanings (ie a class and a function).",
      "PostedDate": "2013-08-22T14:43:43.537-07:00",
      "Id": 110817
    },
    {
      "Message": "First, I still have no answer to the original question of the post 'How to declare a module that's a generic class that implements an external, imported interface?'. So whatever module imports it can use:\n```\nimport genClass = require('mod');\nvar x = new genClass<string>();\n```\n\nThe following code does what I want (and what I know, not think, I want) without generics:\n```\n// READ THIS COMMENT!!!\n// this is imported, but put inline here for simplicity\ninterface IExternal {\n    externMethod():void;\n}\ndeclare module 'myModule' {\n    module myModule {\n        // NOTICE HOW IMyClass IS EXTENDING AN IMPORTED INTERFACE\n        export interface IMyClass extends IExternal {\n            myMethod():void;\n        }\n        export interface IMyClassStatic {\n            new():IMyClass;\n        }\n    }\n\n    var myModule:IMyClassStatic;\n\n    export = myModule;\n}\n```\n\nThe meat of the question, do the above but with a generic arg to the class:\n```\n// this is imported, but put inline here for simplicity\ninterface IExternal {\n    externMethod():void;\n}\ndeclare module 'myModule' {\n    module myModule {\n        export interface IMyClass<T> extends IExternal {\n            myMethod():T;\n        }\n        export interface IMyClassStatic<T> {\n            new():IMyClass<T>;\n        }\n    }\n\n    // what do I replace this line with??? THIS IS THE QUESTION?!?!?!? \n    var myModule:IMyClassStatic;\n\n    // OBVIOUSLY this doesn't work, and where you may have been\n    // confused stating 'I don't think the code you have is really\n    // doing what you think'. The code isn't doing ANYTHING because \n    // it's not valid code!!!, which is exactly what I think, and the heart\n    // of the issue\n\n    export = myModule;\n}\n```\n\n\nRegarding your first comment about interface implementation, you're not making any sense to me. I realize you're probably much smarter than I am, so maybe you can dumb it down a little for my feeble mind. Here's where you're confusing me:\n\nYou said:\n\"To your last question about .d.ts files: implementing an interface is merely claiming to the compiler that you implement a contract, then you have to actually implement it\"\n\nIn pure typescript (using no .d.ts files), the declaration, or 'claim' as you say, to the compiler that you implement an interface is combined with defining the implementation to the compiler. i.e in a .ts file:\n```\ninterface IInterface {\n    method():number;\n}\n// this line is the 'claim', or DECLARATION, to the compiler that I implement an interface\nclass Class implements IInterface\n{\n    // this is the 'claim', or DEFINITION, to the compiler of the actual implementation\n    method():number { return 0; }\n\n    // this does NOT implement the interface, and if it was the only method in the class\n    // the compiler would error with TS2137 because of differing return types\n    method():string { return ''; }\n}\n```\nIn a .d.ts, the ONLY THING YOU CAN DO is DECLARE, not DEFINE, an interface implementation\n```\nexport interface IInterface {\n    method():number\n}\n// Here, I'm ONLY DECLARING, or 'claiming' to the compiler 'Class'\n// implements IInterface, which exactly IMPLIES every method is \n// implemented, i.e. DEFINED, somewhere else outside of this\n// .d.ts DECLARATIONS file\ndeclare class Class implements IInterface {\n    // so WHY does the compiler require I do this\n    method():number;\n\n    // when thats EXACTLY the declared signature from IInterface\n}\n```\n\nContinuing trying to understand your comment, you say:\n\"When extending a class there is actually a concrete implementation to inherit from automatically\":\nI'm not extending a base class. There is a difference between EXTENDING and base class, where you statement is true but has nothing to do with the original question, and IMPLEMENTING an interface.\n\nAnd finally you say:\n\"Consider that your MyClass could implement bunchOfMethods with a different return type and this would satisfy the constraint imposed by implementing the interface.\"\nHere is a playground link that patently refutes your statement; a different return type for the same method name does not satisfy the interface implementation, bringing me back to my second question: in a '.d.ts' file, when DECLARING a class implements an interface, why must the interface's signature be explicitly DECLARED (not implemented) within the class declaration\n\nhttp://www.typescriptlang.org/Playground/#src=interface%20IInterface%20%7B%0A%09method()%3Anumber%3B%0A%7D%0A%0Aclass%20Class%20implements%20IInterface%20%7B%0A%09method()%3Astring%20%7B%20return%20''%3B%20%7D%0A%7D\n\n",
      "PostedDate": "2013-08-22T15:57:21.41-07:00",
      "Id": 110831
    },
    {
      "Message": "Please re-open or start a discussion in the forums if you're still unclear of the semantics here.\n\r\n\r** Closed by danquirk 08/22/2013 2:44PM",
      "PostedDate": "2013-08-22T14:44:06.14-07:00",
      "Id": 110832
    },
    {
      "Message": "You said:\n\n'How to declare a module that's a generic class that implements an external, imported interface?'.\nThe following code does what I want (and what I know, not think, I want) without generics:\n..\nThe meat of the question, do the above but with a generic arg to the class:\n..\n\nBut the non-generic example you gave is not exporting a class or interface, it's exporting a single instance of that class or interface. That was where I was confused about your intentions vs the question that was asked. Bill's initial reply showed how to export the generic class so you could later construct it with whatever type parameter you want (which is then fed through to its base classes/interfaces). It is not possible to write an instance of a generic type with an open type parameter. The fact that you're extending an imported interface isn't relevant to the problem there. It's not clear to me what a consumer of myModule is doing that this isn't sufficient:\n\n```Typescript\ndeclare module 'external' {\n    interface IExternal {\n        externMethod(): void;\n    }\n}\ndeclare module 'myModule' {\n    import e = require('external');\n    export module myModule {\n        export interface IMyClass<T> extends e.IExternal {\n            myMethod(): T;\n        }\n        export interface IMyClassStatic<T> {\n            new (): IMyClass<T>;\n        }\n    }\n}\n\nimport m = require('myModule');\nvar x: m.myModule.IMyClass<number>;\nvar y: m.myModule.IMyClass<string>;\nx.externMethod();\nvar r1: number = x.myMethod();\nvar r2: string = y.myMethod();\n```\n\nYour second interface example is meaningfully different from the first you gave by virtue of the types involved. That's why you're seeing different behavior, your .d.ts and .ts are fundamentally different code. Consider:\n\n```Typescript\ninterface A {\n    doStuff(): void;\n}\n\ninterface B extends A {\n    doStuff(): string;\n}\n\nvar a: A;\nvar b: B;\na = b;\na.doStuff();\n```\n\nThis is acceptable because the contract that A's version of doStuff specifies says 'I take no arguments, and I don't return anything useful to a consumer of my API.' So a user of the API does not have a return value of any type that they have relied on. So if instead their variable of type A is actually an instance of type B it still satisfies the contract of A.doStuff because we can ignore the return type in this case (since the base class said it just returns void). \n\nBut if A.doStuff does not return void, like in your second example where the base interface returns number, then the derived class must not violate that constraint by returning an incompatible type. That is, this is a compiler error as you'd expect:\n```Typescript\ninterface A {\n    doStuff(): number;\n}\n\ninterface B extends A {\n    doStuff(): string;\n}\n\nvar a: A;\nvar b: B;\na = b;\nvar x: number = a.doStuff();\n```\n\nbecause if it was allowed then as is clear from the last 2 lines, I've just written unsound code with a type error.",
      "PostedDate": "2013-08-22T16:39:13.417-07:00",
      "Id": 110838
    },
    {
      "Message": "In a '.d.ts' file, regarding signatures of classes that implement interfaces, you're stating because of the one special case that an interface may declare a method that returns void, and that a class can satisfy implementing that method with one that only differs in return type, that I therefore must always re-declare all of the interface's methods? Probably 99.99999% of the time the class's implementation of the interface's void-returning method will also have a void return type. On the one hand, I can understand allowing for a non-void-returning implementation satisfying the void-returning interface method, but in a practical sense, i.e. in every day use, that seems like a very flimsy reason, only in a .d.ts, to require always having to re-declare the signatures of all the interfaces methods to allow for the one special case that will rarely occur, and while technically consumers of things implementing the interface wouldn't expect a return value, for me conceptually if my implementation returns something when the interface says it shouldn't, I'm not precisely implementing the interface. It would seem far more practical to have the compiler assume, ONLY in a '.d.ts' mind you, that IF there is a void-returning interface method and ONLY IF I declare a method in the class declaration differing only in return type, THEN it should be considered implemented with a class specific method that returns something, and the interface's method signature should be excluded in the class signature; in all other cases the compiler should automatically include the interface's signature in the class signature. i.e:\n\nin a .d.ts:\n```\nexport interface IInterface {\n   method():void;\n}\n\nclass ClassOne implements IInterface {\n} \n\nclass ClassTwo implements IInterface {\n    method():string;\n}\n```\nThe compiler knows ClassOne implements 'method():void' somewhere else, and automatically includes 'method():void' as part of class signature. For ClassTwo, compiler sees there's a class method only differing to IInterface's method in that it returns a value while the interface's does not, and in that case does NOT include method():void as part of class's signature. so:\n```\nvar a = new ClassTwo();\nvar y = a.method(); // y gets typed to string;\nvar b = <IInterface>a;\nvar x = b.method() // compiler throws error\n```\n\nNow, I really do love TS and what it brings to JS development; absolute kudos to you guys. But this one special case, allowing a class to satisfy a void returning method from an interface with a type-returning method identical in every other way, you should really rethink that one. In 'pure' .ts, its not an issue because the 'implements interface' is always DECLARED and DEFINED together. But in a '.d.ts', where you're only declaring signatures, it just doesn't make sense whatsoever.\n\n\nBack to the original post's question. In the non-generic example, you say I'm exporting a single instance of a class, rather than the class constructor function itself, and I beg to differ:\n```\n// this is imported, but put inline here for simplicity\ninterface IExternal {\n    externMethod():void;\n}\ndeclare module 'myModule' {\n    module myModule {\n        export interface IMyClass extends IExternal {\n            myMethod():void;\n        }\n        export interface IMyClassStatic {\n            new():IMyClass;\n        }\n    }\n\n    var myModule:IMyClassStatic;\n\n    export = myModule;\n}\n```\nHere I've exported a variable that implements IMyStaticClass, which has the 'new()' method declared. that means, for all practical purposes regarding importers, I AM exporting a class constructor function, i.e a class, and not a class instance! Because importers can do this, and only this:\n```\nimport asClass = require('myModule');\nvar x = new asClass(); \n// compiler sees the exported var myModule', i.e. 'asClass', as a constructor function\n// and NOT as an instance of IMyClass.. its an instance of IMyClassStatic\n// which is a constructor function because it has 'new():IMyClass;' as a method\n```\nThe above declaration is the only practical way to declare a module as essentially a class constructor function when the class implements an externally imported interface, 'IExternal' in the above example. In Bill's original response, his class doesn't implement an external interface. And in your example, the module itself is not a constructor function, as evidenced by the dotted notations and the lack of a 'new' statement. A sample .js to go along with the declaration would look 'something' like this:\n```\nvar IExternal = require('externalModAsClassCtorFunc');\nvar function myClass() { //constructor stuff here }\n_.extend( myClass.prototype, IExternal );\nmodule.exports = myClass;\n```\nAnd really whats happening is IExternal is a base class that myClass is deriving from, but the '.d.ts' file that goes along with module 'externalModAsClass' has exported it as an interface, and I have no control over changing it.\n \nNow, I've really been trying to keep my original question simple, as even after all this my situation is still slightly more complex. Ideally, IExternal would have been defined as a class, like CExternal, and then I could have just used:\n```\ndeclare module 'myModule' {\n    class myClass<T> extends CExternal {\n        // CExternal can change its signature\n        // without breaking my .d.ts \n    }\n    export = myClass;\n}\n```\nBut in fact IExternal is also 2 levels down from a root base class (via _.extend()), and they've all been defined as interfaces. So I could do this:\n```\ndeclare module 'myModule' {\n    class myClass<T> implements IExternal {\n        // ok, go through all the source and .d.ts's for IExternal\n        // and it's 2 ancestors, and redeclare all their method\n        // signatures here because the TS compiler wants us\n        // to, for the super rare case when some other class\n        // needs to implement a void returning interface method\n        // with a method identical in every way except it returns\n        // a value.\n    }\n}\n```\nBut that's just not at all practical! As soon as IExternal's signature changes, or its ancestors, (which technically are classes) the .d.ts breaks. In my non-generic sample, I deal with this by creating an interface IClass that extends IExternal, and a separate interface for IClassStatic with a 'new():IClass' declaration. All that works until I want to use a generic, which leads my to the original question of this issue, and to my secondary question of the necessity, only in '.d.ts' files, to have to completely redeclare the method signatures of the interfaces implemented by a class, in the class's declaration. You've said that's to handle the super rare case when an interface method returns void, and the class wants to implement with a method that returns something. I don't agree with that technically, practically, or philosophically, only in a '.d.ts' file.\n\nSo, this is all still an issue for me; maybe not for you guys, but it should be.",
      "PostedDate": "2013-08-22T19:45:06.977-07:00",
      "Id": 110856
    },
    {
      "Message": "#__ANSWER TO ORIGINAL QUESTION:__\n...for the 2 of you out there who may have had the same question and actually read everything to this point.\n\n\nFirst to restate the question and why it was asked....\n\nWithout generics, the following works to declare a preexisting javascript module thats actually a class that derives (prototypal inheritance) from another javascript class, when the base class has been declared\nas an interface in some other .d.ts file:\n```\n// external interface in module you have no control over\ndeclare module 'extMod'\n{\n\texport interface IExternClass {\n\t\textMethod():void;\n\t}\n}\n\n// ----- PATTERN 1: -----\n// .d.ts for preexisting javascript module thats a class that 'derives'\n// from a class in another javascript lib\ndeclare module 'myMod'\n{\n    import ext = require('ext');\n\tmodule myMod {\n\t\texport interface IClass extends ext.IExternClass {\n\t\t\tmethod():string;\n\t\t}\n\t\texport interface IClassStatic {\n\t\t\tnew():IClass;\n\t\t}\n\t}\n\t// important: using 0.9.x 'module merging feature' here.\n\tvar myMod:IClassStatic;\n    export = myMod;\n}\n\n//-------------------\n// used in some typescript\nimport AsClass = import('myMod');\nvar inst = new AsClass();\n```\nThis represents preexisting javascript 'classes' as interfaces, and enables extending them without having to redeclare the inherited interface methods.\n\nIn other words, the following is the same as above but tedious (when the base IExternalClass has lots of methods that aren't actually implemented in the derived class, but inherited via prototypal inheritance):\n```\n// ----- PATTERN 2: -----\ndeclare module 'myMod'\n{\n    import ext = require('ext');\n\n\tclass myClass implements ext.IExternClass {\n\t\t// have to redeclare all of IExternClass's methods,\n\t\t// as well as any ancestor extended interfaces.\n\t\t// tedious because if IExternClass was declared\n\t\t// as a class (which in actuality it is) instead of an interface,\n\t\t// extending (vs. implementing) wouldn't require this.\n\t\textMethod():void;\n\n\t\t// class methods\n\t\tmethod():string;\n\t}\n    export = myClass;\n}\n\n//-------------------\n// used in exact same way as PATTERN 1\nimport AsClass = import('myMod');\nvar inst = new AsClass();\n```\nPATTERN 1 has been used in several '.d.ts' files the community has created. My question was how to do PATTERN 1 but with a generic class.\n\n___THE ANSWER___\n(And for the life of me I can't understand why the MSFT guys closed this issue three times without providing this answer as it was so simple, although not immediately obvious...)\n\n```\ndeclare module 'myMod'\n{\n    import ext = require('ext');\n    module myMod {\n        // the generic class\n        export interface IClass<T> extends ext.IExternClass {\n            method():T;\n        }\n        export interface IClassStatic {\n\t        // THIS IS THE ANSWER RIGHT HERE!\n\t\t    // which is to include a type param\n\t\t    // to the 'new' declaration\n\t\t    new<T>():IClass<T>;\n\t\t}\n\t}\n\t// important: using 0.9.x 'module merging feature' here.\n\tvar myMod:IClassStatic;\n    export = myMod;\n}\n\n//-------------------\n// used in some typescript\nimport AsClass = import('myMod');\nvar inst = new AsClass<string>();\n```\n",
      "PostedDate": "2013-08-24T14:33:29.187-07:00",
      "Id": 111053
    }
  ]
}