[
  {
    "Id": "1129029",
    "ThreadId": "471154",
    "Html": "Hi,<br />\n<br />\nThis is kind of a follow-up to <a href=\"https://typescript.codeplex.com/discussions/465035\" rel=\"nofollow\">https://typescript.codeplex.com/discussions/465035</a> since it sounds like TypeScript is going to be constrained in this area for at least a while. I’m hoping to get some feedback from TypeScript users and developers on the “best” approach for dealing with the case where you have two classes that you want to combine into one class.<br />\n<br />\nFor example, in Dojo, we have a Stateful class which enables accessors/mutators and watching for property changes in ES3 (get/set/watch methods), and we have an Evented class which enables listening for and emitting events on a specific object (on/emit methods). For an object that both uses accessors and also emits events, a normal construction would look like:<br />\n<br />\nvar StatefulEvented = declare([ Stateful, Evented ]);<br />\n<br />\nIn TypeScript, we can only inherit one. So what is the best solution here?<br />\n<br />\n1:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">interface</span> IStatefulEvented <span style=\"color:Blue;\">extends</span> IStateful, IEvented {}\n<span style=\"color:Blue;\">var</span> StatefulEvented:{ <span style=\"color:Blue;\">new</span> (kwArgs:Object):IStatefulEvented; } = <span style=\"color:Blue;\">declare</span>([ Stateful, Evented ]);\r\n</pre></div>or 2:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> StatefulEvented <span style=\"color:Blue;\">extends</span> Stateful <span style=\"color:Blue;\">implements</span> IEvented {\n  <span style=\"color:Blue;\">constructor</span>(kwArgs:Object) {\n    <span style=\"color:Blue;\">super</span>(kwArgs);\n    Evented.apply(<span style=\"color:Blue;\">this</span>, arguments);\n  }\n  on(type:(target:<span style=\"color:Blue;\">any</span>, listener:(event:Event) =&gt; <span style=\"color:Blue;\">void</span>) =&gt; <span style=\"color:Blue;\">void</span>, listener:(event:Event) =&gt; <span style=\"color:Blue;\">void</span>):IHandle;\n  on(type:<span style=\"color:Blue;\">string</span>, listener:(event:Event) =&gt; <span style=\"color:Blue;\">void</span>):IHandle;\n  on(type:<span style=\"color:Blue;\">any</span>, listener:(event:Event) =&gt; <span style=\"color:Blue;\">void</span>):IHandle { <span style=\"color:Blue;\">return</span> &lt;IHandle&gt; <span style=\"color:Blue;\">null</span>; }\n  emit(type:<span style=\"color:Blue;\">string</span>, event:Event):<span style=\"color:Blue;\">void</span> {}\n}\nStatefulEvented.prototype.on = Evented.prototype.on;\nStatefulEvented.prototype.emit = Evented.prototype.emit;\r\n</pre></div>or 3:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> StatefulEvented <span style=\"color:Blue;\">extends</span> Stateful <span style=\"color:Blue;\">implements</span> IEvented {\n  <span style=\"color:Blue;\">constructor</span>(kwArgs:Object) {\n    <span style=\"color:Blue;\">super</span>(kwArgs);\n    Evented.apply(<span style=\"color:Blue;\">this</span>, arguments);\n  }\n  on = Evented.prototype.on;\n  emit = Evented.prototype.emit;\n}\r\n</pre></div>or 4:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">class</span> StatefulEvented <span style=\"color:Blue;\">extends</span> Stateful <span style=\"color:Blue;\">implements</span> IEvented {\n  <span style=\"color:Blue;\">constructor</span>(kwArgs:Object) {\n    <span style=\"color:Blue;\">super</span>(kwArgs);\n    Evented.apply(<span style=\"color:Blue;\">this</span>, arguments);\n  }\n  on(type:<span style=\"color:Blue;\">any</span>, listener:(event:Event) =&gt; <span style=\"color:Blue;\">void</span>):IHandle {\n    <span style=\"color:Blue;\">return</span> Evented.prototype.on.apply(<span style=\"color:Blue;\">this</span>, arguments);\n  }\n  emit(type:<span style=\"color:Blue;\">any</span>, event:Event):<span style=\"color:Blue;\">void</span> {\n    Evented.prototype.emit.apply(<span style=\"color:Blue;\">this</span>, arguments);\n  }\n}\r\n</pre></div>…or something else?<br />\n<br />\nThe first one doesn’t create a class that can be extended any more. The second one is gross for reasons that are hopefully obvious. The third one is gross like the second one, except also sets the <code>on</code> and <code>emit</code> methods on every instance. The fourth one is most like what one might expect from an unassisted mix-in in JavaScript.<br />\n<br />\nObviously I would really really like for TypeScript to have something built in that makes authoring classes at least as easy as it already is for Dojo users, but barring that at least coming up with a reasonably sane solution here for now could be helpful. Also keep in mind that some of these mix-ins could have 10 or more methods so reducing code duplication would be fairly important.<br />\n<br />\nThanks for your thoughts,<br />\n",
    "PostedDate": "2013-11-25T22:17:59.847-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1129363",
    "ThreadId": "471154",
    "Html": "This is one of those areas where being conservative around which abstractions we adopt for 1.0 definitely shows through.  Extension methods(<a href=\"https://typescript.codeplex.com/workitem/100\" rel=\"nofollow\">https://typescript.codeplex.com/workitem/100</a>) and mixins have been suggested.  It looks like the latter would fit what you're looking to do, namely, mix together two partial classes (or mixins) together into a new class declaration.  This is definitely a powerful abstraction, and has a history in the JS community.<br />\n\r<br />\nOne solution, albeit ugly, would be to simulate multiple inheritance using subclasses of Stateful that include Evented's member.  You could generate the matrix of such combinations, similar to your #2 and #4 but using classes.  As we use structural inheritance, you wouldn't need to implement an interface.<br />\n\r<br />\nThe closest to what you're asking for that works today, aside from generating the mixins yourself, is #1.  Here you would call your own mixin function and would cast the output of the mixin function to be the interface that extends both interfaces.\r<br />\n<br />\nWe're definitely looking into ways we can improve abstractions further, and make cases like this easier to do, after 1.0.  \r<br />\n",
    "PostedDate": "2013-11-26T15:21:46.043-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1129533",
    "ThreadId": "471154",
    "Html": "Ideally, instead of providing a runtime feature that would create mixins or multiple inheritance, I would prefer a way to declare that a function returns a combination of type, and a less strict checking of what can be 'extended' :<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\n  <span style=\"color:Green;\">//mixin declarations </span>\n  <span style=\"color:Blue;\">declare</span> <span style=\"color:Blue;\">function</span> createMixin&lt;T,U&gt;(a: T, b: U): mixin(T,U);\n  <span style=\"color:Blue;\">class</span> A {\n    methodA() {}\n  }\n\n  <span style=\"color:Blue;\">class</span> B {\n    methodB() {}\n  }\n\n  <span style=\"color:Blue;\">var</span> mix = createMixin(<span style=\"color:Blue;\">new</span> A(), <span style=\"color:Blue;\">new</span> B())\n  mix.methodA();\n  mix.methodB();\n\n  <span style=\"color:Green;\">//extending non-class object</span>\n  <span style=\"color:Blue;\">interface</span> Foo { doSomething(); }\n  <span style=\"color:Blue;\">declare</span> <span style=\"color:Blue;\">var</span> Foo : { prototype: Foo; <span style=\"color:Blue;\">new</span>(): Foo };\n  <span style=\"color:Blue;\">class</span> Bar <span style=\"color:Blue;\">extends</span> Foo {\n  }\r\n</pre></div>By introducing this kind of features typescript could improve greatly its flexibility, while still providing a strong type-checking. (in my opinion)<br />\n",
    "PostedDate": "2013-11-27T03:52:59.063-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1129641",
    "ThreadId": "471154",
    "Html": "I agree, something that could mix at the typesystem level would be powerful.  We've already talked on the forums about an operator like ||, so you could say &quot;number || string&quot; to say that the type could be either.  The trick is to come up with a way to describe things like this that doesn't complicate the type system.  If we could come up with that, I think the next step might be to use annotations in a way very similar to your example:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\n<span style=\"color:Blue;\">class</span> A {\n   methodA() {}\n}\n\n<span style=\"color:Blue;\">class</span> B {\n   methodB() {}\n}\n\n@mixin(A, B)\n<span style=\"color:Blue;\">class</span> AB {}\r\n</pre></div>Where the user could create a function like mixin, and AB would be passed to the function, and then assigned what came out, in a way played nicely with the type system.  I'm not sure exactly how that would work, but if we did it right, then people could create their own extensions to the language, and would open the door to extension methods/mixins/etc<br />\n",
    "PostedDate": "2013-11-27T08:33:51.843-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1274619",
    "ThreadId": "471154",
    "Html": "@jonturner +∞<br />\n",
    "PostedDate": "2014-07-20T21:26:50.78-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]