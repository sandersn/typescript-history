[
  {
    "Id": "1221238",
    "ThreadId": "538574",
    "Html": "I'm having a hard time getting a UI project I'm working on to recognize types in a library that I've written in TypeScript and I'd love some help.\r<br />\n<br />\nThe library project and the UI project are both generated from the TypeScript HTML Application template and are in the same solution.  I have VS 2013 Pro and TypeScript 1.0 RC installed.  The structure is something like this:\r<br />\n<br />\nMyIdea.sln\r<br />\nMyIdea\\MyIdea.csproj\r<br />\nMyIdea\\MyIdea.ts\r<br />\nMyIdea\\src\\Class1.ts\r<br />\nMyIdea\\src\\Class ... etc.\r<br />\nMyIdea.WebUI\\MyIdea.WebUI.csproj\r<br />\nMyIdea.WebUI\\app\\UIStuff.ts\r<br />\n<br />\nIf this were C#, &quot;MyIdea&quot; would be the business DLL, and &quot;MyIdea.WebUI&quot; would be the app.\r<br />\n<br />\nThe code looks something like this:\r<br />\n<br />\nMyIdea\\MyIdea.ts:<br />\n<pre><code>export import Class1 = require(&quot;./src/Class1&quot;);\nexport import Class2 = require(&quot;./src/Class2&quot;);\n/* etc... export / import for each class */\nexport var Version: string = &quot;0.1.0-alpha.6&quot;;\n</code></pre>\n\nMyIdea\\src\\Class1.ts (and all of the other classes):<br />\n<pre><code>import MyIdea = require(&quot;../MyIdea&quot;);\nclass Class1 {\n   /* some stuff */\n}\nexport = Class1;\n</code></pre>\n\nThe library works great when minified using the optimizer that is part of Require.js (using AMD) and everything is usable via the MyIdea module, so you can do MyIdea.Class1, MyIdea.Class2, etc.\r<br />\n<br />\nSo here's the confusion I'm having: I can't seem to get types working in my UI project.\r<br />\n<br />\nI've tried the following:\r<br />\n<br />\nAdding the --declaration switch to tsc so that I get a d.ts file for each TypeScript file, then adding a MyIdea.WebUI\\Scripts\\_references.ts with this as the first line (this is where the tsc output goes):<br />\n<pre><code>///&lt;reference path=&quot;../../MyIdea/build/output/myidea.d.ts&quot; /&gt;\n</code></pre>\n\nAlso, I tried to reference the original myidea.ts file directly, but it didn't seem to make the MyIdea object appear in Intellisense.\r<br />\n<br />\nSince I'm using Durandal and I wanted require to work for both importing the TypeScript references and also for loading the required modules at runtime, I put this line in one of my UI pages:<br />\n<pre><code>import MyIdea = require('myidea');\n</code></pre>\n\nAnd in the _references.ts file, I added something like this:<br />\n<pre><code>declare module 'myidea' {\n    var MyIdeaStaticModule: any;\n    export = MyIdeaStaticModule;\n}\n</code></pre>\n\nMy require config looks like this:<br />\n<pre><code>requirejs.config({\n    paths: {\n        &quot;myidea&quot;: &quot;../lib/myidea.min&quot;\n        /* more ... */\n}\n</code></pre>\n\nThis worked to have TypeScript be happy about using &quot;MyIdea&quot;, and the resolution to the built and minified JS file worked at runtime (../lib/myidea.min.js), but of course MyIdea was of type &quot;any&quot; due to the fake module so it wasn't very useful.  What is the correct way to get MyIdea to show up in my UI page as a valid reference to the root module in my other project and to get strong typing in the UI project?\r<br />\n<br />\nIf you want to see the actual code, it's here on this branch: <a href=\"https://github.com/ShamnaSkor/WafleProject/tree/DurandalUI\" rel=\"nofollow\">https://github.com/ShamnaSkor/WafleProject/tree/DurandalUI</a>\r<br />\n<br />\nIt's a TypeScript project of reasonable size and scope, and who knows it might be useful for you guys to do some profiling...\r<br />\n<br />\nThanks very much<br />\n",
    "PostedDate": "2014-03-10T17:04:57.447-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1221520",
    "ThreadId": "538574",
    "Html": "Did you try importing the required class directly in UIStuff.ts:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n\n<span style=\"color:Blue;\">import</span> Class1 = require(<span style=\"color:#A31515;\">&#39;../../MyIdea/src/Class1&#39;</span>);\n\r\n</pre></div>The path is case sensitive. I'm not sure why you're carrying out the import/export in MyIdea.ts (I gues it's something to do with RequireJS finding the modules)<br />\n",
    "PostedDate": "2014-03-11T09:47:40.147-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1221579",
    "ThreadId": "538574",
    "Html": "I didn't try that specifically.  I was hoping to be able to achieve this via the generated d.ts files instead of the .ts files, and ideally by just referencing the root MyIdea.d.ts file which I assumed would then &quot;include&quot; the references to all of the individual class d.ts files.<br />\n<br />\nThe reason for the import/export is to generate essentially a common root namespace for the library.  I believe that this would allow code in MyIdea.Class1 to call static methods like MyIdea.Class2.DoStuff() or instantiate instances of MyIdea.Class3, but only use a single variable MyIdea in the global namespace.  Unless I am mistaken, it is also the only way to get this behavior without requiring every single class to be in a single .ts file.  Is this a mistaken premise?  If there is a better way to get the ability to keep separate classes in separate TS files, but be able to reference them via a common root, that would be very helpful to know; I'm writing a library, not a series of scripts.<br />\n<br />\nBy the way - at runtime, the UI doesn't use the individually compiled separate js files that correspond one-for-one with the ts files - it uses a built/minified version of the library that r.js generates.  I would like to avoid having to program each page to be aware of which classes are used if at all possible because it will cause difficulties with require.js - Ideally I'd like one require call that tells TypeScript which d.ts to import at design time and that will work with require.js at runtime to load the correct minified and bundled JavaScript file.<br />\n<br />\nAt the end of the day, all I want is for any of my ts files in the UI project to realize that there will be a MyIdea variable in the global JS namespace that is of type MyIdea.  This works automatically within the same VS project, but my problem is getting it to work in the different project within the same solution.  Any ideas are welcome but as I said, I would like to avoid having to reference each individual .ts project from the library project because I have d.ts files already compiled for each of them.<br />\n<br />\nMy ultimate goal is to allow other developers to download only a d.ts file (or worst case a collection of d.ts files) and the minified/bundled JS file for the library and let them create new experiences with it, so as you can see, directly referencing the .TS files in the other project kind of breaks this vision.<br />\n<br />\nThank you so much for the reply - your team has done amazing work with TypeScript and I would not have been able to create this library in the first place without your incredible efforts to date.<br />\n",
    "PostedDate": "2014-03-11T12:02:48.237-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1222979",
    "ThreadId": "538574",
    "Html": "I finally got my UI to recognize the d.ts file.\r<br />\n<br />\nOf course, something was wrong so I &quot;used Process Monitor&quot; (tm).\r<br />\n<br />\nI then observed that this line in my code:<br />\n<pre><code>import MyIdea = require('../../MyIdea/build/output/myidea.d.ts');\n</code></pre>\n\nWas resulting in the TypeScript compiler to search for:<br />\n<ul>\n<li>myidea.d.ts.ts</li>\n<li>myidea.d.ts.d.ts</li>\n<li>myidea.d.ts.str</li>\n<li>\nmyidea.d.ts.d.str<br />\n</li>\n</ul>\nAnd then it searched for all four of those files in every folder all the way back to my drive root... sort of.\r<br />\n<br />\nSince it was first searching for myidea.d.ts.ts, I changed my import statement to be this, and types started working correctly in my UI library.<br />\n<pre><code>import MyIdea = require('../../MyIdea/build/output/myidea.d');\n</code></pre>\n\nFunny stuff!\r<br />\n<br />\n@nabog - thanks again for your earlier answer.  I think I may have had a case issue because I tried again later and the .ts file did light up Intellisense properly.<br />\n",
    "PostedDate": "2014-03-14T19:46:46.07-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1223082",
    "ThreadId": "538574",
    "Html": "So in addition to the fact that I am a terrible programmer, I believe that there are two issues with TypeScript which, if they had not been the case, I would not have gotten stuck on this for nearly a week.  I've opened two issues:<br />\n<br />\n&quot;Requiring a d.ts file does the unexpected&quot;<br />\n<a href=\"https://typescript.codeplex.com/workitem/2316\" rel=\"nofollow\">https://typescript.codeplex.com/workitem/2316</a><br />\n<br />\n&quot;Separate finding the reference from the emitted JS&quot;<br />\n<a href=\"https://typescript.codeplex.com/workitem/2317\" rel=\"nofollow\">https://typescript.codeplex.com/workitem/2317</a><br />\n<br />\n<strong>To summarize the workaround for TypeScript 1.0 RC for others who may come across this:</strong><br />\n<br />\nIf you have a d.ts file (or set of d.ts files that are related) that defines an external module, <em>you have to put the d.ts file in either the same folder as your .ts file that imports it, or a folder closer to the drive root</em>.  if you put a line like import MyLibrary = require(&quot;MyLibrary&quot;), TypeScript 1.0 RC will case-sensitively search the current folder for both a MyLibrary.ts and MyLibrary.d.ts file (in that order), and then recursively search each folder back to the drive root (for .ts and .d.ts) to find it.  So if you want to use this import in many different .ts files in your project, you have to just accept the fact that the d.ts file needs to live at the root of your project or in a folder even up from that (closer to the root).  Then when you use require.js, you will have a clean library name to use in your config call.<br />\n<br />\nThanks to the TypeScript team for your amazing language.  It really is great, and I hope that this feedback is accepted in the manner in which it is intended - to hopefully help improve an already amazing product.  I would never have been able to create the project that I'm now writing a UI for had I had to do it in JS - I would have simply lost patience.  Thanks again.<br />\n<br />\nLastly, if I am just being a terrible programmer here (as usual), and there is an easy workaround for the above, I would appreciate it if someone would let me know.  Again - thanks so much.<br />\n",
    "PostedDate": "2014-03-15T08:14:45.94-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1223154",
    "ThreadId": "538574",
    "Html": "@nabog I've noticed <code>--d</code> used along with <code>external modules</code> do weird stuff and it only confuses people. Perhaps this particular combination should be disabled as its current state is not ideal? \r<br />\n<br />\ne.g almost the exact same question : <a href=\"http://stackoverflow.com/questions/22400806/how-to-use-auto-generated-typescript-declaration-files-in-separate-project\" rel=\"nofollow\">http://stackoverflow.com/questions/22400806/how-to-use-auto-generated-typescript-declaration-files-in-separate-project</a> \r<br />\n<br />\n<strong>A simple example to prove</strong> consider the file system: <br />\n<pre><code>foo\n|-- a.ts\n|-- b.ts</code></pre>\n\na.ts: <br />\n<pre><code>import b_lib = require('./b');\nexport var b = b_lib;\nexport class A{};</code></pre>\n\nb.ts: <br />\n<pre><code>export class B{};</code></pre>\n\nCompile with <code>--d --module amd</code> it generates: \r<br />\na.d.ts: <br />\n<pre><code>import b_lib = require('./b');\nexport declare var b: b_lib;\nexport declare class A {\n}</code></pre>\n\nb.d.ts: <br />\n<pre><code>export declare class B {\n}</code></pre>\n\nYou can see that <code>a.d.ts</code> is already invalid\r<br />\n<img src=\"http://i.imgur.com/gP02FLe.png\" alt=\"Image\" /><br />\n",
    "PostedDate": "2014-03-15T16:46:27.98-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]