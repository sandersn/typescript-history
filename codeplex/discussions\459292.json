[
  {
    "Id": "1099413",
    "ThreadId": "459292",
    "Html": "Searched for ages for this, but I'm maybe missing something simple. :)\r<br />\n<br />\nUsing say RequireJS and the modules AMD inside typescript it's very easy to use, but I have one problem.  Is there any reason the import/require cannot be used inside a function?.\r<br />\n<br />\nThe reason I ask is because I might say have a function that's called rarely, maybe controlled by some external event etc.  But because I can only put the require call at the begging of the file and not inside the function, the JS is always going to be loaded.\r<br />\n<br />\nAs an example..<br />\n<pre><code>import rareProcs = require('rareProcs'); //don't want it here.\n\nexport function doSomething(doRarely:boolean) {\n  if(doRarely) {\n     //import rareProcs = require('rareProcs'); \n     //The above uncommented gives &lt;- ERROR: Unexpected token; 'statement expected'\n     rareProcs.doSomethingNotOften();\n  }\n}</code></pre>\n\nIf the second commented &quot;import rareProcs&quot; could be done, late loading of rarely used functions/classes etc could be loaded on-demand.\r<br />\n<br />\nIt would also help, say with single Page AJax style websites, so that associated Javascript for pages can be loaded on-demand.<br />\n",
    "PostedDate": "2013-09-25T15:46:13.523-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1102696",
    "ThreadId": "459292",
    "Html": "Ok, no response.  So I assume it's not possible, and not on the roadmap.\r<br />\n<br />\nPersonally this make's TypeScript not usable for me.   I'm a big fan of late loading!!.\r<br />\nUsing TypeScript and AMD loading don't really work together.  I see no point in using an AMD loader, if on page load all modules implicitly get loaded.\r<br />\n<br />\nBut, I will say thanks to the TypeScript Team, the one thing TypeScript did do for me is make the transition from a OOP language to a Prototype one much easer.  After learning more about pure Javascript and prototype I believe in it's pure form it's already a beautiful language anyway.<br />\n",
    "PostedDate": "2013-10-02T05:06:42.753-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1102751",
    "ThreadId": "459292",
    "Html": "Here is what you would need to do:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">/// &lt;reference path=&quot;require.d.ts&quot;/&gt;</span>\n\n<span style=\"color:Blue;\">import</span> _rareProcs = require(<span style=\"color:#A31515;\">&#39;rareProcs&#39;</span>);\n\n<span style=\"color:Blue;\">export</span> <span style=\"color:Blue;\">function</span> doSomething(doRarely: <span style=\"color:Blue;\">boolean</span>) {\n    <span style=\"color:Blue;\">if</span> (doRarely) {\n        require([<span style=\"color:#A31515;\">&quot;rareProcs&quot;</span>], (rareProcs: <span style=\"color:Blue;\">typeof</span> _rareProcs) =&gt; {\n            rareProcs.doSomethingNotOften();\n        });\n    }\n}\r\n</pre></div>When an imported external module is referenced only in type positions the compiler optimizes away the dependency it would otherwise generate. So, in the example above, &quot;rareProcs&quot; is not included in the dependency array passed to the 'define' function. You can then manually load the module using your AMD loader's 'require' function, but since this loading will happen asynchronously so you need to provide the rest of your function as a callback. Also note that you can use the 'typeof' operator to strongly type the module object for the dynamically loaded module.\r<br />\n<br />\nBTW, the &quot;require.d.ts&quot; file I reference above can be found on Definitely Typed. Or you can just do a 'declare var require: any' and forego strong typing.<br />\n",
    "PostedDate": "2013-10-02T06:58:18.007-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1103086",
    "ThreadId": "459292",
    "Html": "Hi ahejsberg,\r<br />\n<br />\nThanks for your response.  The main problem here is that were basically hacking the import directive so that we can get Type information, so it doesn't really give you anything more than just using the /// &lt;reference&gt;  directive.   The other problem of course is that we also need to Typecast.\r<br />\n<br />\nOn the other hand if the import directive could have been extended to handle closures, rather than a top level directive, my example without comments would look very clean. <br />\n<pre><code>export function doSomething(doRarely: boolean) {\n    if (doRarely) {\n        import rareProcs = require('rareProcs'); \n        rareProcs.doSomethingNotOften();\n    }\n}</code></pre>\n\nIn the above there is no need for Typecasting, and no ///&lt;reference&gt; tags or import hacks that the compiler would need to optimize away.\r<br />\n<br />\nSaying all this, I believe I know the reason why imports inside closures are currently not allowed.  Looking at my code, you would think the code is running linear, when in fact it's Async.  So if I altered my code too -&gt;<br />\n<pre><code>export function doSomething(doRarely: boolean) {\n    if (doRarely) {\n        import rareProcs = require('rareProcs'); \n        rareProcs.doSomethingNotOften();\n    }\n    console.log('Do something done');\n}</code></pre>\n\nThe console &quot;Do something done' would most likely get fired before the doSomethingNotOften, and this is likely not what the programmer intended.  To handle this correctly the Typescript compiler would have to be very clever. \r<br />\n<br />\neg, it would require compiling too something like -&gt;<br />\n<pre><code>    export.doSomething = function(doRarely) {\n        function _outsideIf() { console.log('Do something done'); }\n        if(doRarely) {\n            require(['rareProcs'],function(rareProcs) {\n                rareProcs.doSomethingNotOften();\n                _outsideIf();\n            }\n        } else _outsideIf();\n    }</code></pre>\n\nBut even then, the doSomething has now potentially now become Async,..  Oh Heck!!!\r<br />\nOne solution would maybe if the TypeScript compiler was promise based, but that I think would be a massive undertaking.  Or maybe the Callee end of doSomething get's wrapped too, but I can see how this would turn the javascript code into spaghetti.<br />\n",
    "PostedDate": "2013-10-03T02:34:54.53-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1103189",
    "ThreadId": "459292",
    "Html": "@KpjComp,\r<br />\n<br />\nThe import is not buying you much in this situation. As you mentioned, another solution is to simply &lt;reference&gt; include the necessary types.\r<br />\n<br />\nIt shouldn't be too difficult to structure something like the following, with recourse to one or the other <a href=\"https://github.com/kriskowal/q\" rel=\"nofollow\">promise library</a>:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">/// &lt;reference &quot;MyAmdLoader.d.ts&quot; /&gt;</span>\n<span style=\"color:Green;\">/// &lt;reference &quot;MyPromiseLib.d.ts&quot; /&gt;</span>\n\n<span style=\"color:Blue;\">function</span> doSomethingRarely(doRarely) : MyPromiseLib.Promise&lt;<span style=\"color:Blue;\">void</span>&gt; {\n        <span style=\"color:Blue;\">if</span>(doRarely) {\n            \n            <span style=\"color:Blue;\">return</span> MyAmdLoader\n                .load&lt;RareProcs&gt;(<span style=\"color:#A31515;\">&quot;rareProcs&quot;</span>)\n                .then(rareProcs =&gt; {\n                \n                rareProcs.doSomethingNotOften();\n            });\n        }\n        <span style=\"color:Blue;\">else</span> {\n            \n             <span style=\"color:Blue;\">var</span> promise =  MyPromiseLib.create();          \n             console.log(<span style=\"color:#A31515;\">&#39;Do something done&#39;</span>);\n             promise.resolve();\n             <span style=\"color:Blue;\">return</span> promise;             \n        }\n}\r\n</pre></div>It is unavoidable that doSomethingRarely is an asynchronous function, hence it <em>must</em> return a promise. The AMD loader is also clearly asynchronous. So IMO all that is clearly spelled out in the code for anyone reading it to understand without confusion.\r<br />\n<br />\nIn a future version, TypeScript may well provide some shorthand syntax (sugar) for the code above, but even as it stands it's not really spaghetti. (Damn never knew there was an &quot;h&quot; in spaggetti. Thanks spell checker!)<br />\n",
    "PostedDate": "2013-10-03T07:20:02.69-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1103248",
    "ThreadId": "459292",
    "Html": "Hi @nabog,\r<br />\n<br />\nMy quote on promises, was for the compiler to implement them automatically.  IOW: to make what looks like linear code behave like linear code.  If typescript had the ability to flag a function as been a potential Async call, typescript could then maybe automatically wrap this inside promise calls.   I think that makes sense, well in my head it does.. :)   Of course this idea is unlikely to happen, as Typescript as best it can adheres to the ECMAScript standard, and I assume there is no standard for this.   But I'm not sure the current import is ECMAScript standard either,. eg. the current idea for import is something like -&gt; import $ from &quot;jquery&quot;;  And also ECMAScript seems to have late loading with the System.import &amp; system.Load directive,.  So I assume typescript will hopefully be implementing this.\r<br />\n<br />\nYour code is of course implementing promises using Typescript.\r<br />\n<br />\nAlthough for this simple example the code is indeed not spaghetti, compared to the 7 line typescript example I provided it it does look a little bit more, it's also got the same issue's as before, your still having to typecast, IMO: avoiding typecast's would be nice.\r<br />\n<br />\nA little note on your example, from what I can tell your returning different promises depending on if doRarely is called.   Would it not be better to always return the same type of promise?, this way you could send some sort of status back via the resolve..\r<br />\n<br />\neg.  (oh, just sussed how you get formatted code)<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">/// &lt;reference &quot;MyAmdLoader.d.ts&quot; /&gt;</span>\n<span style=\"color:Green;\">/// &lt;reference &quot;MyPromiseLib.d.ts&quot; /&gt;</span>\n\n<span style=\"color:Blue;\">function</span> doSomethingRarely(doRarely) : MyPromiseLib.Promise&lt;<span style=\"color:Blue;\">void</span>&gt; {\n        <span style=\"color:Blue;\">var</span> promise =  MyPromiseLib.create();          \n        <span style=\"color:Blue;\">if</span>(doRarely) {            \n            MyAmdLoader\n                .load&lt;RareProcs&gt;(<span style=\"color:#A31515;\">&quot;rareProcs&quot;</span>)\n                .then(rareProcs =&gt; {                \n                rareProcs.doSomethingNotOften();\n                promise.resolve(<span style=\"color:#A31515;\">&#39;did something once in a blue moon&#39;</span>);\n            });\n        }\n        <span style=\"color:Blue;\">else</span> {\n             console.log(<span style=\"color:#A31515;\">&#39;Do something done&#39;</span>);\n             promise.resolve(<span style=\"color:#A31515;\">&#39;not this time, maybe next time&#39;</span>);\n        }\n        <span style=\"color:Blue;\">return</span> promise;             \n}\r\n</pre></div>",
    "PostedDate": "2013-10-03T09:33:56.667-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1103256",
    "ThreadId": "459292",
    "Html": "Hi, @KpjComp,\r<br />\n<br />\nI was aware that you wanted the compiler to implement the promise. My point was that one could accomplish this even today relatively painlessly with an external library like Q.\r<br />\n<br />\nThere is also an issue out for TypeScript to <a href=\"https://typescript.codeplex.com/workitem/38\" rel=\"nofollow\">implement async/await a la C#</a>. The reason this was not implemented initially, as I understand it, is that it clashes with another TypeScript goal: that of generating &quot;clean&quot; JavaScript output. Wrapping up asynchronous code is likely to lead to some spaghetti as you note.\r<br />\n<br />\nI don't understand by what you mean when you say &quot;your still having to typecast, IMO: avoiding typecast's would be nice.&quot;.\r<br />\n<br />\nFinally, in my code I am not returning different promises. According to the promise spec <code>then</code> returns a promise whose resolved value is the return value from the on fulfilled callback. Since I'm not returning anything from on fulfilled the return value is undefined or void in the TypeScript world. <br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n        .then(rareProcs =&gt; {\n                \n                rareProcs.doSomethingNotOften();\n            <span style=\"color:Green;\">// void</span>\n            });\r\n</pre></div>My second promise is also resolved without a value <code>promise.resolve()</code>. Hence they are equivalent. In your code there is an extra overhead when the doRarely block is executed, because an additional promise is created.\r<br />\n<br />\nA very minor optimisation of course.<br />\n",
    "PostedDate": "2013-10-03T09:58:33.84-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1103389",
    "ThreadId": "459292",
    "Html": "Hi, <a href=\"mailto:@nabog.\" rel=\"nofollow\">@nabog.</a>.<br />\n<blockquote>\nI don't understand by what you mean when you say &quot;your still having to typecast, IMO: avoiding typecast's would be nice.&quot;. <br />\n</blockquote>\nBasically this bit -&gt;  return MyAmdLoader.load&lt;RareProcs&gt;(&quot;rareProcs&quot;)    &lt;- &lt;RareProcs&gt; is a typecast, when using pure imports in typescript this is not required.<br />\n<blockquote>\nFinally, in my code I am not returning different promises.<br />\n</blockquote>\nSorry, yes.  They both return a promise, and a promise is a promise after all.  It was if later on when you wanted to implement something in the resolve, for a return value, it's the resolve I see as the return and not the promise.  But then you can always re-factor as needed.  I suppose for me having the creation of the promise at the start of the function and returning this promise just seems to define the scope of the function to be more obvious.  In your example were both return void, it's of course not relevant but the example I showed returning a string for status it is.<br />\n<blockquote>\nIn your code there is an extra overhead when the doRarely block is executed<br />\n</blockquote>\nYes, but it's returning something extra in the resolve, that the &quot;then&quot; promise wouldn't be doing.  Like you say it's a minor optimization, as it is a doRarely after all. :)\r<br />\n<br />\nAnyway, I think we've gone slightly off track here. :)\r<br />\nMy main concern was with lazy loading, and if the Typescript team could implement ECMAScript 6   System.import &amp; System.load  that would be great, they both imply Async so no confusion either.   Because Typescript would understand  System.import, in theory we also have type safety again without typecasting.<br />\n",
    "PostedDate": "2013-10-03T14:43:31.793-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]